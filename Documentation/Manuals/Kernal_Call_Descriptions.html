<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>FLOS Kernal Calls</title></head>
<body>
<h3><span style="text-decoration: underline; font-weight: bold;">FLOS
v603 Kernal Manual</span><span style="text-decoration: underline; font-weight: bold;"> -
Last updated 22-09-2012</span></h3>
<pre><span style="text-decoration: underline; font-weight: bold;"></span><br>The following FLOS kernal routines can be executed simply by using a "CALL name"<br>instruction, with registers pre-set to the routines requirements. <br><br>EG:- <br><br>---------------------------------------------------------------------------------<br><br>         LD HL,  my_text<br>         CALL    kjt_print_string<br><br>         [rest of program..]<br>	<br>my_text  DB "HELLO WORLD!",0<br><br>----------------------------------------------------------------------------------<br><br><br><span style="text-decoration: underline;">Notes:</span><br><br>Kernal calls should not be made when the Video RAM is paged in. The only routine<br>that is guaranteed to work in that situation is "kjt_page_out_video"</pre>
<pre><span style="text-decoration: underline; font-weight: bold;"></span>It should be assumed that Kernal calls trash all registers, unless a routine's<br>documentation says otherwise.</pre>
<span style="text-decoration: underline; font-weight: bold;"><br>
Kernal Call Index:</span><br>
<pre><span style="text-decoration: underline;"><br>File System Routines:</span><br><br><a href="Kernal_Call_Descriptions.html#kjt_change_dir"><span style="font-weight: bold;">kjt_change_dir</span></a>           - Change to subdirectory<br><a href="Kernal_Call_Descriptions.html#kjt_change_volume"><span style="font-weight: bold;">kjt_change_volume</span></a>        - Selects drives VOL0: to VOL7:<br><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_check_volume_format">kjt_check_volume_format</a><span style="font-family: monospace;">  </span></span>- Checks if current volume is formatted to FAT16.<br><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_continue_file_read">kjt_continue_file_read</a>   - Same as KJT_READ_FROM_FILE except this does not set the<br>                           load address/bank (uses working values instead) <br><a href="Kernal_Call_Descriptions.html#kjt_create_file"><span style="font-weight: bold;">kjt_create_file</span></a>          - Makes a new file stub.<br><a href="Kernal_Call_Descriptions.html#kjt_delete_dir"><span style="font-weight: bold;">kjt_delete_dir</span></a>           - Deletes an (empty) directory<br><a href="Kernal_Call_Descriptions.html#kjt_dir_list_first_entry"><span style="font-weight: bold;">kjt_dir_list_first_entry</span></a>&nbsp;- Find first entry in current directory.<br><a href="Kernal_Call_Descriptions.html#kjt_dir_list_get_entry"><span style="font-weight: bold;">kjt_dir_list_get_entry</span></a>   - Returns data from directory list (see output registers)<br><a href="Kernal_Call_Descriptions.html#kjt_dir_list_next_entry"><span style="font-weight: bold;">kjt_dir_list_next_entry</span> </a> - Moves directory list pointer to the next entry <br><a href="Kernal_Call_Descriptions.html#kjt_erase_file"><span style="font-weight: bold;">kjt_erase_file</span></a>           - Deletes a file <br><a href="Kernal_Call_Descriptions.html#kjt_format_device"><span style="font-weight: bold;">kjt_format_device</span></a>        - Formats entire SD card to FAT16<br><a href="Kernal_Call_Descriptions.html#kjt_get_device_info"><span style="font-weight: bold;">kjt_get_device_info</span></a>&nbsp;     - Returns info about the storage devices. <br><a href="Kernal_Call_Descriptions.html#kjt_get_dir_name"><span style="font-weight: bold;">kjt_get_dir_name</span></a>         - Returns the name of the current directory. <br><a href="Kernal_Call_Descriptions.html#kjt_get_dir_cluster"><span style="font-weight: bold;">kjt_get_dir_cluster</span> </a>     - Returns the cluster address of the current dir<br><a href="Kernal_Call_Descriptions.html#kjt_get_fs_vars_location_"><span style="text-decoration: underline;"><span style="font-weight: bold;">kjt_get_fs_vars_location</span></span></a> - Returns address of&nbsp;Filesystem's control variables<br><a href="Kernal_Call_Descriptions.html#kjt_get_total_sectors"><span style="font-weight: bold;">kjt_get_total_sectors</span></a>    - Returns total sectors on current volume<span style="font-weight: bold;"><br></span><a href="#kjt_get_volume_info"><span style="font-weight: bold;">kjt_get_volume_info</span></a>      - Returns data about the volumes mounted<br><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_load_file">kjt_load_file</a> </span>           - Loads a file in its entirety from disk to RAM<br><a href="#kjt_make_dir"><span style="font-weight: bold;">kjt_make_dir</span></a>             - Creates a new sub directory in current directory<br><a href="#kjt_change_dir"><span style="font-weight: bold;"></span></a><a href="Kernal_Call_Descriptions.html#kjt_mount_volumes"><span style="font-weight: bold;">kjt_mount_volumes</span></a>        - Initializes the attached disk list.<br><a href="Kernal_Call_Descriptions.html#kjt_open_file"><span style="font-weight: bold;">kjt_open_file</span></a>            - Looks for a file on current disk, resets file pointer etc<br><a href="#kjt_parent_dir"><span style="font-weight: bold;">kjt_parent_dir</span></a>           - Move up a directory level<br><a href="#kjt_root_dir"><span style="font-weight: bold;">kjt_root_dir</span></a>             - Go to root directory of drive<br><a href="#kjt_delete_dir"><span style="font-weight: bold;"></span></a><a href="#kjt_get_total_sectors"><span style="font-weight: bold;"></span></a><a href="#kjt_save_file"><span style="font-weight: bold;"></span></a><a href="#kjt_read_from_file"><span style="font-weight: bold;">kjt_read_from_file</span></a>       - Reads data from the opened file to RAM<br><a href="Kernal_Call_Descriptions.html#kjt_rename_file"><span style="font-weight: bold;">kjt_rename_file</span></a>          - Renames files and directories<br><a href="Kernal_Call_Descriptions.html#kjt_restore_dir_position"><span style="font-weight: bold;">kjt_restore_dir_position</span></a>&nbsp;- Restores directory to that stored by above.<br><a href="#kjt_create_file"><span style="font-weight: bold;"></span></a><a href="Kernal_Call_Descriptions.html#kjt_save_file"><span style="font-weight: bold;">kjt_save_file</span></a>            - Creates and saves a file from RAM to disk<br><a href="Kernal_Call_Descriptions.html#kjt_set_dir_cluster"><span style="font-weight: bold;">kjt_set_dir_cluster</span></a>      - Sets the dir from a cluster address<br><a href="Kernal_Call_Descriptions.html#kjt_set_file_pointer"><span style="font-weight: bold;">kjt_set_file_pointer</span></a>     - Moves the read point from the start of a file<br><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_set_load_address">kjt_set_load_addres</a><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_set_load_address"><span style="font-weight: bold;">s</span></a>     - Specifies the load address and bank for a file read<br>                           (when using KJT_continue_file_read)<br><a href="Kernal_Call_Descriptions.html#kjt_set_read_length"><span style="font-weight: bold;">kjt_set_read_length</span></a>      - Sets the read length of a file transfer to a certain value<br><a href="Kernal_Call_Descriptions.html#kjt_store_dir_position"><span style="font-weight: bold;">kjt_store_dir_position</span></a>   - Internally remembers the current directory position.<br><a href="#kjt_write_to_file"><span style="font-weight: bold;">kjt_write_to_file</span></a>        - Appends new data to an existing file.<br><a href="#kjt_dir_list_first_entry"><span style="font-weight: bold;"></span></a><br><a href="#kjt_get_dir_name"><span style="font-weight: bold;"></span></a><br><br><a href="#kjt_mount_volumes"><span style="font-weight: bold;"></span></a><span style="text-decoration: underline;">Low-Level Sector Access Routines:</span></pre>
<pre><a href="Kernal_Call_Descriptions.html#kjt_file_sector_list"><span style="font-weight: bold;">kjt_file_sector_list</span></a>     - To list the disk sectors that files occupy<span style="font-weight: bold;"><br><a href="Kernal_Call_Descriptions.html#kjt_get_sector_read_addr">kjt_get_sector_read_addr</a> - </span>Returns data and pointers allowing&nbsp;sector buffer relocation etc.<br><a href="#kjt_read_sector"><span style="font-weight: bold;">kjt_read_sector</span></a>          - Loads 512 byte sector to the sector buffer<br><a href="#kjt_write_sector"><span style="font-weight: bold;">kjt_write_sector</span></a>         - Writes 512 byte sector to the current device<br><br><a href="#kjt_file_sector_list"><span style="font-weight: bold;"></span></a><span style="font-weight: bold;"></span></pre>
<pre><span style="font-weight: bold;"></span><span style="text-decoration: underline;">Kernal Serial Comms Routines:</span></pre>
<pre><a href="#kjt_serial_receive_header"><span style="font-weight: bold;">kjt_serial_receive_header</span></a> - Waits for a file header from serial port<br><a href="#kjt_serial_receive_file"><span style="font-weight: bold;">kjt_serial_receive_file</span></a>   - Receives serial file data<br><a href="Kernal_Call_Descriptions.html#kjt_serial_rx_byte"><span style="font-weight: bold;">kjt_serial_rx_byte</span></a>        - Wait for a byte from serial port<br><a href="#kjt_serial_send_file"><span style="font-weight: bold;">kjt_serial_send_file</span></a>      - Sends a file to serial port (Serial Link App format)<br><a href="#kjt_serial_tx_byte"><span style="font-weight: bold;">kjt_serial_tx_byte</span></a>        - Send a byte to serial port</pre>
<pre><br><br><span style="text-decoration: underline;">Kernal Keyboard And Mouse Routines</span></pre>
<pre><a href="Kernal_Call_Descriptions.html#kjt_enable_mouse"><span style="font-weight: bold;">kjt_enable_mouse</span></a>         - Activates mouse driver (enables IRQ etc).<span style="font-weight: bold;"><br><a href="#kjt_get_key">kjt_get_key</a> </span>             - Returns value of key, if one has been pressed (does not wait)<span style="font-weight: bold;"><br></span><a href="Kernal_Call_Descriptions.html#kjt_get_key_buffer"><span style="font-weight: bold;">kjt_get_key_buffer</span></a>       - Allows monitoring of the keyboard without affecting the buffer.<br><span style="font-weight: bold;"><a href="#kjt_get_key_mod_flags">kjt_get_key_mod_flags</a> </span>   - Returns status of the shift, ctrl, alt etc keys<br><a href="#kjt_enable_mouse"><span style="font-weight: bold;"></span></a><a href="#kjt_get_mouse_position"><span style="font-weight: bold;">kjt_get_mouse_position</span></a>   - Returns absolute mouse position and button data<br><a href="#kjt_get_mouse_motion_"><span style="font-weight: bold;">kjt_get_mouse_motion</span></a>     - Returns relative mouse displacement<br><a href="#kjt_keyboard_irq_code"><span style="font-weight: bold;">kjt_keyboard_irq_code</span></a>    - Allows external apps to invoke FLOS keybaord IRQ code<br><a href="#kjt_mouse_irq_code"><span style="font-weight: bold;">kjt_mouse_irq_code</span></a>       - Allows external apps to invoke FLOS mouse IRQ code<br><a href="Kernal_Call_Descriptions.html#kjt_wait_key_press"><span style="font-weight: bold;">kjt_wait_key_press</span></a>       - Pauses until a key is pressed<span style="font-weight: bold;"><br></span><br><span style="text-decoration: underline;"><br><br>Kernal Text and Display Routines</span></pre>
<pre><a href="Kernal_Call_Descriptions.html#kjt_clear_screen"><span style="font-weight: bold;">kjt_clear_screen</span></a>         - Clears OS screen and sets cursor position to top left (0,0)<br><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_draw_cursor">kjt_draw_cursor</a> </span>         - Draws (or removes) the cursor at the current cursor position<br><a href="#kjt_print_string"><span style="font-weight: bold;"></span></a><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_flos_display">kjt_flos_display</a> </span>        - Restores the video registers to the state used by the OS. <br><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_get_colours">kjt_get_colours</a>          - Returns RGB values of the FLOS border, paper, cursor and colour list location<br><a href="#kjt_get_cursor_position"><span style="font-weight: bold;">kjt_get_cursor_position</span></a>  - Returns the current cursor position<br><a href="Kernal_Call_Descriptions.html#kjt_get_display_size"><span style="font-weight: bold;">kjt_get_display_size</span></a>     - Returns size of OS_window<br><a href="Kernal_Call_Descriptions.html#kjt_get_charmap_addr_xy"><span style="font-weight: bold;">kjt_get_charmap_addr_xy</span></a>  - Returns the charmap address of coordinates x,y<span style="font-weight: bold;"><br></span><span style="font-weight: bold;"></span><a href="Kernal_Call_Descriptions.html#kjt_get_input_string"><span style="font-weight: bold;">kjt_get_input_string</span></a>     - Waits for user to enter a string of characters<span style="font-weight: bold;"><br></span><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_get_pen_">kjt_get_pen</a> </span>             - Returns current pen colour<span style="font-weight: bold;"><br></span><a href="Kernal_Call_Descriptions.html#kjt_patch_font"><span style="font-weight: bold;">kjt_patch_font</span></a>           - Allows easy (and individual) user defined characters in the FLOS font.<br><a href="Kernal_Call_Descriptions.html#kjt_plot_char"><span style="font-weight: bold;">kjt_plot_char</span> </a>           - Prints character at given coords using current pen colours<br><a href="Kernal_Call_Descriptions.html#kjt_print_string"><span style="font-weight: bold;">kjt_print_string</span></a>         - Prints ASCII text string at the current cursor position<br><a href="#kjt_scroll_up"><span style="font-weight: bold;">kjt_scroll_up</span></a>            - Scrolls the screen (and character map) up a line.<span style="font-weight: bold;"><br></span><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_set_colours_">kjt_set_colours</a>          - Sets FLOS border, paper and cursor colours and writes to&nbsp;the pen colour list<br><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_set_cursor_position">kjt_set_cursor_position</a> </span> - Repositions the text printing (cursor) position<br><a href="Kernal_Call_Descriptions.html#kjt_set_pen"><span style="font-weight: bold;">kjt_set_pen</span></a>              - Changes current pen colour<span style="font-weight: bold;"><br></span><span style="font-weight: bold;"><a href="#kjt_wait_vrt">kjt_wait_vrt</a> </span>            - Wait for vertical retrace (IE: last scanline of display)<br><br><span style="font-weight: bold;"></span><br><br style="text-decoration: underline;"><span style="text-decoration: underline;">Kernal Memory Management Routines:</span></pre>
<pre><a href="#kjt_set_bank"><span style="font-weight: bold;"></span></a><a href="Kernal_Call_Descriptions.html#kjt_inc_bank"><span style="font-weight: bold;">kjt_inc_bank</span></a>          - Change to the next bank<br><a href="#kjt_get_bank"><span style="font-weight: bold;">kjt_get_bank</span></a>          - Returns the current bank number in A<br><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_get_flos_bank">kjt_get_flos_bank</a>     - Returns the bank seelcted by FLOS before the current command executed.<br><a href="#kjt_page_in_video"><span style="font-weight: bold;">kjt_page_in_video</span></a>     - Pages video memory into $2000-$3FFF<br><a href="#kjt_page_out_video"><span style="font-weight: bold;">kjt_page_out_video</span></a>    - Pages system memory into $2000-$3FFF<br><a href="#kjt_read_sysram_flat"><span style="font-weight: bold;">kjt_read_sysram_flat</span></a>  - Rread flat system memory location (E:HL) into A<span style="font-weight: bold;"><br></span><a style="font-weight: bold;" href="#kjt_read_baddr">kjt_read_baddr</a>        - Reads a byte into A from address BANK:ADDRESS<br><a href="Kernal_Call_Descriptions.html#kjt_set_bank"><span style="font-weight: bold;">kjt_set_bank</span></a>          - Switches the upper RAM page to a specific bank<br><a style="font-weight: bold;" href="#kjt_write_baddr">kjt_write_baddr</a>       - Writes a byte from A into address BANK:ADDRESS<br><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_write_sysram_flat">kjt_write_sysram_flat</a> </span>- Write A into flat system memory location (E:HL)<br><a style="font-weight: bold;" href="#kjt_get_flos_bank"><br></a></pre>
<pre><span style="text-decoration: underline;">Kernal Misc Routines:</span></pre>
<pre><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_ascii_to_hex_word">kjt_ascii_to_hex_word</a> </span>   - Converts ascii hex number to numeric 16bit hex word<br><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_bchl_memfill_">kjt_bchl_memfill</a> </span>        - Fill memory with value in accumulator<br><a href="Kernal_Call_Descriptions.html#kjt_compare_strings"><span style="font-weight: bold;">kjt_compare_strings</span></a>      - Compares two ASCII strings<br><a href="Kernal_Call_Descriptions.html#kjt_dont_store_registers"><span style="font-weight: bold;">kjt_dont_store_registers</span></a> - Stops FLOOS updating the stored register values when program quits<br><a href="Kernal_Call_Descriptions.html#kjt_get_version"><span style="font-weight: bold;">kjt_get_version</span></a>          - Returns FLOS and OSCA version<br><span style="font-weight: bold;"><a href="#kjt_hex_byte_to_ascii">kjt_hex_byte_to_ascii</a>&nbsp;</span>   - Makes ASCII version of a numeric hex byte<span style="font-weight: bold;"><br></span><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_set_commander">kjt_set_commander</a> </span>       - Specifies a command string to be run when programs exit<br><a href="#kjt_timer_wait_"><span style="font-weight: bold;">kjt_timer_wait</span> </a>          - Waits n periods of 16 microseconds and returns<span style="font-weight: bold;"><br><br></span></pre>
<pre><span style="text-decoration: underline;">Environment Variable Routines:<br><br></span><span style="font-weight: bold;"><a href="Kernal_Call_Descriptions.html#kjt_delete_envar">kjt_delete_envar</a> </span> - Deletes an environment variable<br><a href="Kernal_Call_Descriptions.html#kjt_get_envar"><span style="font-weight: bold;">kjt_get_envar</span></a>&nbsp;&nbsp; &nbsp; - Gets (address of) value of an environment variable<span style="font-weight: bold;"><br><a href="#kjt_set_envar">kjt_set_envar</a>&nbsp;</span>&nbsp; &nbsp; - Sets/updates an environment variable<br><a href="#kjt_get_envar"><span style="font-weight: bold;"></span></a><span style="font-weight: bold;"><br><br></span></pre>
<hr style="width: 100%; height: 2px;">
<h3 style="text-decoration: underline;">FILE SYSTEM RELATED CALLS - &nbsp;Some Details:</h3><pre>There are two main ways to load a file, a simple single-call approach and a<br>more flexible random-access approach.<span style="font-family: monospace;"></span></pre>
<pre><span style="font-family: monospace;"></span><span style="font-family: monospace;"></span>To do a simple file load, set HL to a zero terminated ASCII filename string,<br>IX to the destination address and B to the destination bank, then call "<span style="font-weight: bold;">kjt_load_file</span>"<br>Check the return code - see table below - if the zero flag is set, everything is OK.</pre>
<pre>The more flexible way to load file data is as follows: Set HL to a zero terminated<br>ASCII filename string and call "<span style="font-weight: bold;">kjt_open_file</span>". If the zero flag is set on return,<br>the file was found and the length of the file will be in IX:IY (if the zero flag<br>is not set, check the error code).</pre>
<pre>Next, the following two routines can be called *if required*</pre>
<pre>"<span style="font-weight: bold;">kjt_set_file_pointer</span>" - This allows data to be read from anywhere within a file,<br> instead of right from the start. Registers required:<br><br> IX:IY = Offset in bytes from start of file. &nbsp;&nbsp; &nbsp;</pre>
<pre>"<span style="font-weight: bold;">kjt_set_read_length</span>" - This allows the length of transfer to be set.&nbsp;Registers required:<br> <br> IX:IY = Bytes to load. </pre>
<pre><br>Finally, call "<span style="font-weight: bold;">kjt_read_from_file</span>" to transfer the data to memory.&nbsp; Registers required:<br><br>&nbsp;&nbsp; HL = Load address.<br>&nbsp;&nbsp; B&nbsp; = Bank of load address.</pre>
<pre>Again, on return, if the zero flag is set then the operation completed OK.</pre>
<pre><br>The file pointer is automatically incremented by the number of bytes transferred,<br>therefore it is not necessary call "kjt_set_file_pointer" each time if&nbsp;chunks of<br>a file are required sequentially. Attempting to read beyond the end of a file will<br>return an error (code $1B). The load length MUST be set for each read (and load<br>address and bank set appropriately each call). </pre>
<pre>To maintain speed, a fresh seek from the start of the file is not performed each<br>time "kjt_read_from_file" is called unless the file pointer has been changed.<br>Internal variables must be maintained, therefore do not perform any other disk /<br>serial operations (or anything that changes the sector buffer) between successive<br>calls to this routine.</pre>
<pre>Whenever a disk file transfer reaches address $FFFF, it wraps around to $8000<br>and continues on into the next bank. </pre>
<pre>Most of the file system kernal calls return one of these standard error codes:</pre>
<pre> If the zero flag is set, the operation was a success.<br> If the zero flag is not set, there was an error. A = error code:</pre>
<pre>&nbsp;$01 - disk full<br>&nbsp;$02 - file not found <br>&nbsp;$03 - (root) dir table is full <br>&nbsp;$04 - directory requested is actually a file<br>&nbsp;$05 - cant delete dir, it is not empty<br>&nbsp;$06 - not a file<br>&nbsp;$07 - file length is zero<br>&nbsp;$08 - address error (file too big for memory)<br>&nbsp;$09 - filename already exists<br>&nbsp;$0a - already at root directory<br>&nbsp;$0e - invalid volume<br>&nbsp;$13 - unknown/incorrect disk format<br>&nbsp;$1b - requested bytes beyond end of file<br>&nbsp;$22 - device not present&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;$23 - directory not found&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;$24 - end of directory list<br>&nbsp;$2e - device does not use MBR</pre>
<pre><span style="text-decoration: underline;"><br><span style="font-weight: bold;">Advanced:</span></span></pre>
<pre>In FLOS v599 the following routines were added to allow external programs to hook into<br>the filesystem variables used by FLOS:<span style="text-decoration: underline;"></span></pre>
<pre><span style="text-decoration: underline;"><span style="font-weight: bold;"></span></span><span style="text-decoration: underline;"><span style="font-weight: bold;"><a href="#kjt_get_fs_vars_location_">kjt_get_fs_vars_location</a></span></span></pre>
<pre>The data at the returned location (see link for format) can be backed up and restored by a<br>user program, allowing multiple open files to managed etc.</pre>
<pre>Notes:</pre>
<pre>When restoring altered variable data, the first byte "fs_filepointer_valid" should always<br>be cleared so that filesystem correctly re-seeks from the start of files.</pre>
<pre>The current volume number&nbsp;must be handled seperarately if files on multiple volumes are<br>to be handled.</pre>
<pre>Additionally, the following two new routines were added:</pre>
<pre><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_continue_file_read">kjt_continue_file_read</a> <br><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_set_load_address">kjt_set_load_addres</a><a style="font-weight: bold;" href="Kernal_Call_Descriptions.html#kjt_set_load_address"><span style="font-weight: bold;">s</span></a> </pre>
<pre>The normal file read call KJT_READ_FROM_FILE&nbsp;requires the bank and address to be specified,<br>which may be a nuisance when working with multiple files. With the <span style="font-weight: bold;">kjt_continue_file_read</span><br>routine, the file bytes are written to an address from the end of the last read operation.<br><span style="font-weight: bold;">kjt_set_load_address</span> sets the address and bank to a specific location.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre>&nbsp;</pre>
<pre><span style="font-weight: bold;"><a name="kjt_check_volume_format"></a>&nbsp;kjt_check_volume_format</span></pre>
<pre><br>Action: Checks if current volume is available and formatted to FAT16</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre>Output Registers : Standard error codes </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_change_volume"></a>&nbsp;kjt_change_volume</span></pre>
<pre><br>Action: Selects a new volume (the directory will be that which was last selected in the new volume) </pre>
<pre><br>Input Registers&nbsp; :<br><br> A = volume to select</pre>
<pre><br>Output Registers : <br><br> Standard error codes </pre>
<pre><br>Notes: Will not allow a change to an invalid Volume (non-FAT16 etc)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_format_device"></a>&nbsp;kjt_format_device</span></pre>
<pre><br>Action: Formats a device (entire drive as single partition, no MBR)</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> A&nbsp; = Device to format (0 = DEV0: (SD_Card), 1 = DEV1: (user driver 1)<br><br> HL = Address of desired disk label ASCII string </pre>
<pre><br>Output Registers : Standard error codes </pre>
<pre><br>Notes: It is highly recommended that "kjt_mount_volumes" is called after this routine.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_make_dir"></a>kjt_make_dir</span></pre>
<pre><br>Action: Creates a new sub directory in current directory</pre>
<pre><br>Input Registers:</pre>
<pre> HL = zero terminated dir name</pre>
<pre><br>Output Registers : Standard error codes </pre>
<pre><br><a name="kjt_change_dir"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">&nbsp;kjt_change_dir</span></pre>
<pre><br>Action: Change to subdirectory</pre>
<pre><br>Input Registers:</pre>
<pre> HL = zero terminated dir name</pre>
<pre><br>Output Registers : Standard error codes </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_parent_dir"></a>kjt_parent_dir</span></pre>
<pre><br>Action: Move up a directory level</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre>Output Registers : Standard error codes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_root_dir"></a>&nbsp;kjt_root_dir</span></pre>
<pre><br>Action: Go to root directory of volume</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre>Output Registers : Standard error codes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_delete_dir"></a>kjt_delete_dir</span></pre>
<pre><br>Action: Deletes an (empty) subdirectory</pre>
<pre><br>Input Registers:</pre>
<pre> HL = zero terminated dir name</pre>
<pre><br>Output Registers : Standard error codes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_erase_file"></a>kjt_erase_file</span></pre>
<pre><br>Action: Deletes a file in the current directory</pre>
<pre><br>Input Registers:</pre>
<pre> HL = zero terminated file name</pre>
<pre><br>Output Registers : Standard error codes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre><span style="font-weight: bold;"><a name="kjt_get_total_sectors"></a>kjt_get_total_sectors</span></pre>
<pre><br>Action: Returns total sectors on current volume</pre>
<pre><br>Input Registers&nbsp; : none</pre>
<pre>Output Registers :</pre>
<pre> C:DE = number of sectors</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"></span></pre>
<pre><span style="font-weight: bold;"><a name="kjt_load_file"></a>kjt_load_file</span></pre>
<pre><br>Action: Loads the specified file from current directory in its entirity to the specifed address.</pre>
<pre><br>Input registers:</pre>
<pre> IX&nbsp;&nbsp; = address to load to</pre>
<pre> B&nbsp;&nbsp;&nbsp; = bank to load to</pre>
<pre> HL&nbsp;&nbsp; = zero terminated filename</pre>
<pre>Output registers: Standard error codes </pre>
<pre><br>Notes:</pre>
<pre>This routine both opens a file and reads all the data to RAM - for more<br>flexibility use "kjt_open_file", "kjt_set_file_pointer", "kjt_set_read_length"<br>and "kjt_read_file_data"</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_save_file"></a>kjt_save_file</span></pre>
<pre><br>Action: Saves a file to current directory.</pre>
<pre><br>Input registers:</pre>
<pre> IX&nbsp;&nbsp; = Source data start address</pre>
<pre> B&nbsp;&nbsp;&nbsp; = bank to save data from</pre>
<pre> C:DE = number of bytes to save</pre>
<pre> HL&nbsp;&nbsp; = zero terminated filename</pre>
<pre>Output registers: Standard error codes </pre>
<pre><br>Notes:</pre>
<pre>This routine both creates a new file and saves data to it - it cannot be<br>used append new data to an existing file (will return "file already<br>exists" error if attempted).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_open_file"></a>kjt_open_file</span></pre>
<pre><br>Action: Looks for a file in current directory and sets internal registers ready<br>        for "kjt_read_from_file" call.</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> HL = pointer to zero terminated filename to look for</pre>
<pre><br>Output Registers :</pre>
<pre>If the Zero Flag is set: All OK. Registers are:</pre>
<pre> IX:IY = Length of file</pre>
<pre> DE&nbsp;&nbsp;&nbsp; = First disk cluster used by file</pre>

<pre>If zero flag is not set: standard error codes.</pre>
<pre><br>Notes:&nbsp; File pointer is set to 0, default transfer length = total file size </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_set_file_pointer"></a>kjt_set_file_pointer</span></pre>
<pre><br>Action: Moves the read point from the start of a file</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre>IX:IY = Offset in bytes from start of file.</pre>
<pre><br>Output Registers :&nbsp; none</pre>
<pre>Notes: Use after "kjt_open_file" (if required)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_set_read_length"></a>kjt_set_read_length</span></pre>
<pre><br>Action: Forces the read length of the file transfer to a certain value</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> IX:IY = Bytes to load</pre>
<pre><br>Output Registers : none</pre>
<pre> Notes: Use after kjt_find_file (if desired)</pre>
<pre><br></pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_read_from_file"></a>kjt_read_from_file</span></pre>
<pre><br>Action:&nbsp; Loads data (from the previously opened file) to a specified address.</pre>
<pre>Input Registers&nbsp; :</pre>
<pre> HL = Destination address</pre>
<pre> B&nbsp; = Destination bank</pre>
<pre><br>Output Registers : Standard error codes</pre>
<pre><br>Notes:</pre>
<pre>"kjt_open_file" MUST be called first before using this routine.</pre>
<pre>Whenever a disk file transfer reaches address $FFFF, it wraps around to<br>$8000 and continues onto the next bank. </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_create_file"></a>kjt_create_file</span></pre>
<pre><br>Action: Makes a file stub for a new file in current directory.</pre>
<pre><br>Input Registers :</pre>
<pre>HL = address of zero-terminated filename.</pre>
<pre><br>Output Registers : Standard error codes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_write_to_file"></a>kjt_write_to_file</span></pre>
<pre><br>Action: Appends new data to an existing file in current directory.</pre>
<pre><br>Input Registers:</pre>
<pre> HL&nbsp;&nbsp; = null-terminated ascii filename of file to be appended to</pre>
<pre> IX&nbsp;&nbsp; = address of source data</pre>
<pre> B&nbsp;&nbsp;&nbsp; = bank of source data</pre>
<pre> C:DE = number of bytes to write</pre>
<pre><br>Output Registers : Standard error codes &nbsp;</pre>
<pre><br>Notes:</pre>
<pre>Returns "file not found" error if the file has not been previously created<br>with "kjt_create_file" or "kjt_save_file"</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_dir_list_first_entry"></a>kjt_dir_list_first_entry</span></pre>
<pre><br>Action: Finds the first listing of current directory, returns info.</pre>
<pre><br>Input registers: None</pre>
<pre><br>Output registers: If zero flag is set:</pre>
<pre> HL&nbsp;&nbsp;&nbsp; = Location of null terminated filename string</pre>
<pre> IX:IY = Length of file (if applicable)</pre>
<pre> B&nbsp;&nbsp;&nbsp;&nbsp; = File flag (1 = directory, 0 = file)</pre>
<pre><br>If zero flag is not set, standard error codes&nbsp; (EG: $24 = Reached end of directory)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_dir_list_get_entry"></a>kjt_dir_list_get_entry</span></pre>
<pre><br>Action: Returns data about the entry at the current position in the directory list.</pre>
<pre><br>Input registers: None</pre>
<pre><br>Output registers: If zero flag is set:</pre>
<pre> HL&nbsp;&nbsp;&nbsp; = Location of null terminated filename string</pre>
<pre> IX:IY = Length of file (if applicable)</pre>
<pre> B&nbsp;&nbsp;&nbsp;&nbsp; = File flag (1 = directory, 0 = file)<br><br> If zero flag is not set, standard error codes&nbsp;(EG: $24 = Reached end of directory)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_dir_list_next_entry"></a>kjt_dir_list_next_entry</span></pre>
<pre><br>Action: Moves the internal directory list pointer to the next entry and&nbsp;returns<br>        details about the entry found.</pre>
<pre><br>Input registers: None</pre>
<pre><br>Output registers: If zero flag is set:</pre>
<pre> HL&nbsp;&nbsp;&nbsp; = Location of null terminated filename string</pre>
<pre> IX:IY = Length of file (if applicable)</pre>
<pre> B&nbsp;&nbsp;&nbsp;&nbsp; = File flag (1 = directory, 0 = file)</pre>
<pre> If zero flag is not set, standard error codes&nbsp; (EG: $24 = Reached end of directory)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_dir_name"></a>kjt_get_dir_name</span></pre>
<pre><br>Action: Returns ascii string of current directory name (null terminated)</pre>
<pre><br>Input registers: None</pre>
<pre><br>Output registers :</pre>
<pre>If zero flag set: HL = ascii string.</pre>
<pre>If zero flag is not set, standard error codes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_store_dir_position"></a>kjt_store_dir_position</span></pre>
<pre><br>Action: Internally remembers the current directory position. </pre>
<pre><br>Input registers: None</pre>
<pre>Output registers :None</pre>
<pre><br>Notes: </pre>
<pre>All flags and registers are preserved.</pre>
<pre>Uses only a single level stack - <span style="font-weight: bold;">kjt_get_dir_cluster</span> is more useful.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_restore_dir_position"></a>kjt_restore_dir_position</span></pre>
<pre><br>Action: Restores the directory position to that set by "kjt_store_dir_position".</pre>
<pre><br>Input registers: None</pre>
<pre><br>Output registers :None</pre>
<pre><br>Notes:</pre>
<pre>All flags and registers are preserved.</pre>
<pre><span style="font-weight: bold;">kjt_get_dir_cluster </span>and<span style="font-weight: bold;"> </span><span style="font-weight: bold;">kjt_set_dir_cluster</span> are more useful.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_mount_volumes"></a>kjt_mount_volumes</span></pre>
<pre><br>Action: Reinitializes the drives and mount list</pre>
<pre><br>Input registers:</pre>
<pre>If A = 1, mount quietly (no text output)</pre>
<pre><br>Output registers :None</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_get_volume_info"></a>kjt_get_volume_info</span></pre>
<pre><br>Action: Returns info about the volumes mounted.</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers :</pre>
<pre> HL = address of volume mount list&nbsp;&nbsp; &nbsp;</pre>
<pre> B = Number of volumes mounted</pre>
<pre> A = currently Selected volume</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"></span></pre>
<pre><span style="font-weight: bold;"><a name="kjt_get_device_info"></a>kjt_get_device_info</span></pre>
<pre><br>Action: Returns info from the device list.</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers :</pre>
<pre><br>&nbsp;HL = address of device info table&nbsp;&nbsp; &nbsp;</pre>
<pre>&nbsp;DE = address of driver table</pre>
<pre>&nbsp;B =&nbsp; number of devices initialized </pre>
<pre>&nbsp;A = current active driver number</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_get_dir_cluster"></a>kjt_get_dir_cluster</span></pre>
<pre><br>Action: Returns the location of the directory cluster</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers :</pre>
<pre><br> DE = cluster pointed at by current directory</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_set_dir_cluster"></a>kjt_set_dir_cluster</span></pre>
<pre><br>Action: Sets the directory cluster (for use with above command)</pre>
<pre><br>Input Registers&nbsp; :<br><br> DE = desired cluster number to be used as current dir</pre>
<pre><br>Output Registers : None</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_rename_file"></a>kjt_rename_file</span></pre>
<pre><br>Action: Rename files / folders.</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre><br> HL = Pointer to filename to change (null terminated ASCII)</pre>
<pre> DE = Pointer to replacement filename (null terminated ASCII)</pre>
<pre><br>Output Registers : Standard error codes&nbsp;&nbsp; &nbsp;</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"></span><span style="font-weight: bold;"><a name="kjt_get_fs_vars_location_"></a>kjt_get_fs_vars_location</span></pre>
<pre><br>Action: Sets HL to the address of the fiilesystem's control variables<span style="font-weight: bold;"></span>.</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers : HL =&nbsp; location of the following data structure:</pre>
<pre><br>&nbsp;$00 byte&nbsp;&nbsp;&nbsp;   - fs_filepointer_valid</pre>
<pre>&nbsp;$01 longword &nbsp;- fs_file_pointer</pre>
<pre>&nbsp;$05 longword &nbsp;- fs_file_length</pre>
<pre>&nbsp;$09 longword &nbsp;- fs_bytes_to_go</pre>
<pre>&nbsp;$0d word&nbsp;&nbsp;&nbsp; &nbsp; - fs_file_start_cluster</pre>
<pre>&nbsp;$0f word&nbsp;&nbsp;&nbsp;&nbsp;  - fs_file_working_cluster</pre>
<pre>&nbsp;$11 word&nbsp;&nbsp;&nbsp; &nbsp; - fs_z80_address</pre>
<pre>&nbsp;$13 byte &nbsp; &nbsp;  - fs_z80_bank</pre>
<pre><br>Note: When restoring altered data, the first byte "fs_filepointer_valid" should always<br>be cleared. This causes the read operations to cleanly&nbsp; seek from the beginning<br>of&nbsp;files&nbsp;when&nbsp;file transfer (re)commences. &nbsp;(Access will be noticably slower than<br>a single continuous load.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_continue_file_read"></a>kjt_continue_file_read</span></pre>
<pre><br>Action: Same as KJT_READ_FROM_FILE except this does not set the load address/bank</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers : Standard error codes&nbsp;&nbsp; &nbsp;</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_set_load_address"></a>kjt_set_load_address</span></pre>
<pre><br>Action: Specifies the load address and bank for a file read (when using KJT_continue_file_read)</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> HL = &nbsp;Z80 address where data should load</pre>
<pre> B &nbsp; = FLOS bank where data should load</pre>
<pre><br>Output Registers : None&nbsp; &nbsp;</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre style="text-decoration: underline; font-weight: bold;">Low-Level Disk Sector Access Routines</pre>
<pre><br></pre>
<pre><span style="font-weight: bold;"><a name="kjt_read_sector"></a>kjt_read_sector</span></pre>
<pre><br>Action: Loads a 512 byte sector from the device and address selected to the sector buffer</pre>
<pre><br>Input registers:</pre>
<pre> A = Device number to access (normally 0)</pre>
<pre> BC:DE = absolute LBA address for desired sector</pre>
<pre><br>Output registers: Standard error codes (relevant errrors: $1e, $22)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_write_sector"></a>kjt_write_sector</span></pre>
<pre><br>Action: Writes a 512 byte sector from the sector buffer to the device and address selected</pre>
<pre><br>Input registers:</pre>
<pre> A = Device number to access (normally 0)</pre>
<pre> BC:DE = absolute LBA address for desired sector</pre>
<pre><br>Output registers: Standard error codes (relevant errrors: $1e, $22)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_file_sector_list"></a>kjt_file_sector_list</span></pre>
<pre><br>Action: Retrieves the location of the (next) disk sector that a file occupies.</pre>
<pre><br>Input registers:</pre>
<pre> A&nbsp; = Sector offset (within current cluster)</pre>
<pre> DE = Cluster number</pre>
<pre><br>Output registers:<br><br> A&nbsp; = Next sector offset</pre>
<pre> DE = Updated cluster</pre>
<pre> HL = Memory address of LSB of 4 byte sector location</pre>
<pre><br>How to use:</pre>
<pre>To obtain the list of sectors that a file uses, first call "<span style="font-weight: bold;">kjt_find_file</span>"<br>with the filename in HL as normal. On exit, DE will be equal the first<br>cluster that the file occupies. Clear the accumulator (as we're starting<br>at the first sector of this cluster), and call "<span style="font-weight: bold;">kjt_file_sector_list</span>".<br>On return A and DE are updated to the values required for the next time<br>the routine is called and HL points to the lowest significant byte of<br>the sector address (LBA0). Next, copy the 4 bytes from HL to HL+3 to<br>your sector list buffer and loop around, calling "<span style="font-weight: bold;">kjt_file_sector_list</span>"<br>for as many sectors as are used by the file (simply subtract 512 from<br>a variable holding the file size every call until variable is = &lt; 0)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_sector_read_addr"></a>kjt_get_sector_read_addr</span></pre>
<pre><br>Action: Returns the address of the selected drive's sector read routine,<br>        also LBA variable and sector_location_variable</pre>
<pre><br>Input Registers :</pre>
<pre> A = Device to access (normally 0)</pre>
<pre><br>Output Registers:<br><br>&nbsp;HL = Address of sector read routine</pre>
<pre>&nbsp;DE = Address of the LSB of the 32bit LBA variable</pre>
<pre>&nbsp;BC = Address of the sector buffer location variable </pre>
<pre><br>Notes: </pre>
<pre>This routine can be used to allow programs to read sectors <span style="text-decoration: underline;">directly</span><br>to an arbitrary location in memory (IE: A program can write to the<br>sector LBA and sector buffer location variables, and then call the<br>low-level sector read routine using the data obtained).</pre>
<pre>The sector buffer location is automatically reset to the location that the<br>OS requires whenever a filesystem routine is called (this includes the<br>KJT read/write sector calls above.) Similarly, altering the LBA<br>variable manually should not affect normal operation of the filesystem.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3 style="text-decoration: underline;">SERIAL I/O ROUTINES:</h3>
<hr style="width: 100%; height: 2px;">
<pre><br>To load a file serially you would call: <span style="font-weight: bold;">kjt_serial_receive_header</span>, setting<br>A and HL as appropriate (see docs below). Once it has been received,<span style="font-family: mon;"><span style="font-weight: bold;"><br></span></span><span style="font-weight: bold;">kjt_serial_receive_file</span> may be called (setting B and HL appropriately).<br><br>As with the disk routines, whenever a serial file transfer command reaches<br>address $FFFF, it wraps around to $8000 and continues onto the next bank.<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_serial_receive_header"></a></pre>
<pre><span style="font-weight: bold;">kjt_serial_receive_header</span></pre>
<pre>Action: Waits for a file header from serial port.</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre>&nbsp;HL = Location of null terminated filename (filename can be "*" if any file<br> is to be accepted.</pre>
<pre>&nbsp;A&nbsp; = Bits 5:0 Waiting time in seconds before time out error.</pre>
<pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit 6 = Allow abort with Enter Key (if 1)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit 7 = Allow abort with ESC Key (if 1)</pre>
<pre><br>Output Registers :</pre>
<pre> Zero Flag: If set, all OK</pre>
<pre> IX = location of serial file header (see <a href="serial_link_info.html">serial_link_info.html</a> for details)</pre>
<pre><br>If Zero Flag is NOT set, A = serial error code.</pre>
<pre> A = $07 : Save length is zero<br> A = $08 : File too big (IE: Memory address out of range)<br> A = $0f : Checksum bad<br> A = $11 : Comms error<br> A = $14 : Time out error<br> A&nbsp;= $25 : Filename mismatch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br> A = $2A : Aborted with ESC / Enter key<br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_serial_receive_file"></a>kjt_serial_receive_file</span></pre>
<pre><br>Action: Receives serial file data </pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> HL = Address to load file to</pre>
<pre> B&nbsp; = Bank to load file into </pre>
<pre><br>Output Registers :<br><br> Zero Flag: If set, all OK<br><br> IX = location of of serial file header</pre>
<pre>If Zero Flag is NOT set, A = serial error code.<br><br> A&nbsp;= $07 : Save length is zero<br>&nbsp;A = $08 : File too big (IE: Memory address out of range)<br>&nbsp;A = $0f : Checksum bad<br>&nbsp;A = $11 : Comms error<br>&nbsp;A = $14 : Time out error<br>&nbsp;A = $25 : Filename mismatch</pre>
<pre><br>Note: "<span style="font-weight: bold;">kjt_serial_receive_header</span>" MUST be called before this routine!</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_serial_send_file"></a>kjt_serial_send_file</span></pre>
<pre><br>Action: Sends a file to serial port (Serial Link App format)</pre>
<pre><br>Input Registers&nbsp; :</pre>

<pre> HL&nbsp;&nbsp;&nbsp;&nbsp; = filename<br><br> C:DE&nbsp;&nbsp; = length of file</pre>
<pre> B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Bank number that file starts in</pre>
<pre> IX&nbsp;&nbsp;&nbsp;&nbsp; = Start address</pre>
<pre><br>Output Registers : Zero flag, set if all OK.</pre>
<pre> If zero flag not set, A = serial error code.</pre>





<pre> A = $07 : Save length is zero<br> A&nbsp;= $08 : File too big (IE: Memory address out of range)<br> A = $0f : Checksum bad<br> A = $11 : Comms error<br> A = $14 : Time out error<br> A = $25 : Filename mismatch</pre>
<pre><br><span style="font-weight: bold;"></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_serial_rx_byte"></a>kjt_serial_rx_byte</span></pre>
<pre><br>Action: Wait for a byte from serial port</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre>&nbsp;A.&nbsp; Bits: [0:5] = max time to wait in seconds</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [6] = If set, the wait can be aborted with the ENTER key</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;[7] = If set, the wait can be aborted with ESCAPE key</pre>
<pre><br>Output Registers : If Carry flag is clear all OK, A = byte received.</pre>

<pre>If Carry flag is set, error code in A as follows:</pre>
<pre> A = $14 - Timed out</pre>
<pre> A = $2A - Aborted with key.</pre>
<pre><br>Notes: All registers except A are preserved</pre>
<pre><br><span style="font-weight: bold;"></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_serial_tx_byte"></a>kjt_serial_tx_byte</span></pre>
<pre><br>Action: Send a byte to serial port</pre>
<pre><br>Input Registers&nbsp; : none</pre>
<pre><br>Output Registers : A = byte to send</pre>
<pre><br>Notes: All registers except A preserved.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3 style="text-decoration: underline;">KEYBOARD AND MOUSE ROUTINES</h3>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_wait_key_press"></a>kjt_wait_key_press</span></pre>
<pre><br>Action: Pauses until a key is pressed (and returns value)</pre>
<pre><br>Input Registers&nbsp; : None</pre>

<pre><br>Output Registers :<br><br> A = Scancode of key pressed</pre>
<pre>&nbsp;B = ASCII code (B=$00 if no valid ascii char equivalent.)</pre>
<pre><br>Notes: ASCII code is modified by shift / Alt key status</pre>
<pre><br><span style="font-weight: bold;"></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_key"></a>kjt_get_key</span></pre>
<pre><br>Action: Returns value of key, if one has been pressed (does not wait)</pre>
<pre><br>Input Registers&nbsp; : None</pre>

<pre><br>Output Registers :<br><br>&nbsp;A = Scancode of key pressed (A = $00 if no key pressed)</pre>
<pre>&nbsp;B = ASCII code (B=$00 if no valid ascii char equivalent.)</pre>
<pre><br>Notes: ASCII code is modified by shift / Alt key status</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_key_mod_flags"></a>kjt_get_key_mod_flags</span></pre>
<pre><br>Action: Returns current status of key modifiers</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers : A, bits</pre>
<pre> [0] - left shift</pre>
<pre> [1] - left/right ctrl</pre>
<pre> [2] - left GUI</pre>
<pre> [3] - left/right alt</pre>
<pre> [4] - right shift</pre>
<pre> [5] - right GUI</pre>
<pre> [6] - Apps</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_keyboard_irq_code"></a>kjt_keyboard_irq_code</span></pre>
<pre><br>Action: Keyboard IRQ handler.</pre>

<pre>When a custom interrupt handler is set up but kernal-based keyboard handling<br>is required, this routine can be called when the keyboard IRQ flag is<br>set. The above kernal keyboard routines will then still work. (The call<br>clears the relevant IRQ flag).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_enable_mouse"></a>kjt_enable_mouse</span></pre>
<pre><br>Action: Activates mouse pointer (called by MOUSE.EXE) and sets x/y boundaries</pre>
<pre><br>Input Registers&nbsp; : </pre>
<pre> HL = Window size X</pre>
<pre> DE = Window size Y</pre>
<pre><br>Output Registers : None</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_mouse_position"></a>kjt_get_mouse_position</span></pre>
<pre><br>Action: Returns absolute mouse position and button data</pre>
<pre><br>Input Registers&nbsp; : none </pre>
<pre><br>Output Registers : Zero Flag - If not set, the mouse driver was not enabled, otherwise:</pre>
<pre> HL = x coordinate</pre>
<pre> DE = y coordinate</pre>
<pre> A = buttons status</pre>
<pre>The x and y coordinates cannot overflow from the boundaries set with &nbsp;"kjt_enable_mouse"</pre>

<pre>(Note: the mouse driver is currently somewhat primative - it may become out of<br>sync with the three-byte packets that the mouse sends if say, interrupts are disabled)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_get_mouse_motion_"></a>kjt_get_mouse_motion </span></pre>
<pre><br>Action: Returns relative mouse motion and button data. </pre>
<pre><br>Input Registers&nbsp; : none </pre>
<pre><br>Output Registers : Zero Flag: if not set, the mouse driver was not enabled, Otherwise:</pre>
<pre> HL = x motion since last called</pre>
<pre> DE = y motion since last called</pre>
<pre> A = buttons status</pre>

<pre><br>(Note: the mouse driver is currently somewhat primative - it may become out of<br>sync with the three-byte packets that the mouse sends if say, interrupts are disabled)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_mouse_irq_code"></a>kjt_mouse_irq_code</span></pre>
<pre><br>Action: Mouse IRQ handler</pre>

<pre>When a custom interrupt handler is set up but kernal-based mouse handling is<br>required, this routine can be called when the mouse IRQ flag is set. The above<br>kernal mouse routines will then still work. (The call clears the relevant IRQ flag).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_key_buffer"></a>kjt_get_key_buffer</span></pre>
<pre><br>Action: Returns values for monitoring the keyboard buffer</pre>
<pre><br>Input Registers: None</pre>
<pre><br>Output Registers:</pre>
<pre> HL&nbsp; = Location of the keyboard buffer WRITE index variable (The actual<br>       keyboard buffer starts 32 bytes lower in memory)</pre>
<pre> A = The value of the keyboard READ index variable.</pre>

<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>Notes: On return, if A = (HL) no key has been pressed (IE: the keyboard buffer is empty)</pre>
<pre><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;"><h3>&nbsp;<span style="font-weight: bold; text-decoration: underline;">MEMORY MANAGEMENT ROUTINES&nbsp;</span></h3>
<hr style="width: 100%; height: 2px;">
<pre><br>Under FLOS, Z80 Address space $5000-$FFFF is available for user programs.<br>FLOS allows the upper 32KB of Z80 address space ($8000-$FFFF) to be<br>paged. 15 pages of system RAM&nbsp;can appear in this region, starting<br>at system RAM address $08000 (FLOS does not normally allow the first<br>32KB of system RAM to be paged into $8000-$FFFF). Therefore, when using<br>the KJT routines for bank management, the figures are as follows:</pre>
<pre><br><span style="text-decoration: underline;">Bank | &nbsp;SYSTEM RAM&nbsp; |&nbsp; Z80 ADDRESS</span></pre>















<pre>$00 = $08000-$0ffff @ $8000-$ffff<br>$01 = $10000-$17fff @ $8000-$ffff<br>$02 = $18000-$1ffff @ $8000-$ffff<br>$03 = $20000-$27fff @ $8000-$ffff<br>$04 = $28000-$2ffff @ $8000-$ffff<br>$05 = $30000-$37fff @ $8000-$ffff<br>$06 = $38000-$3ffff @ $8000-$ffff<br>$07 = $40000-$47fff @ $8000-$ffff<br>$08 = $48000-$4ffff @ $8000-$ffff<br>$09 = $50000-$57fff @ $8000-$ffff<br>$0a = $58000-$5ffff @ $8000-$ffff<br>$0b = $60000-$67fff @ $8000-$ffff<br>$0c = $68000-$6ffff @ $8000-$ffff<br>$0d = $70000-$77fff @ $8000-$ffff<br>$0e = $78000-$7ffff @ $8000-$ffff<br><br>(Notice that the figures are different to the values used if<br>writing directly to the bank selection hardware port: <span style="font-weight: bold;">sys_mem_select</span>).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_set_bank"></a>kjt_set_bank</span></pre>
<pre><br>Action: Changes the currently selected upper RAM page</pre>
<pre><br>Input Registers: </pre>
<pre> A = bank number $00 to $0e</pre>
<pre><br>Output Registers : none</pre>
<pre>Trashes: A</pre>
<pre><br><a name="kjt_get_bank"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_get_bank</span></pre>
<pre><br>Action: Returns the upper bank number in A</pre>
<pre><br>Input Registers&nbsp; : none</pre>
<pre><br>Output Registers :</pre>
<pre> A = current bank number ($00 to $0e)</pre>
<pre><br>Trashes: none</pre>
<pre><br><a name="kjt_inc_bank"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_inc_bank</span></pre>
<pre><br>Action: change to the next bank</pre>
<pre><br>Input Registers&nbsp; : none</pre>
<pre><br>Output Registers :</pre>
<pre>&nbsp;If Zero flag set: all OK,</pre>
<pre>&nbsp;If Zero is not set: A = $08 - bank out of range</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_page_in_video"></a>kjt_page_in_video</span></pre>
<pre><br>Action: Pages 8KB of video memory specified by (hardware register vreg_vidpage)<br>        into Z80 address space $2000-$3FFF. </pre>
<pre>CAUTION: This area is used by part of FLOS so ideally no other FLOS call should<br>         be made until&nbsp;<span style="font-weight: bold;">kjt_page_out_video</span> is called.</pre>
<pre><br>Input Registers&nbsp; : none</pre>
<pre>Output Registers : none</pre>
<pre>Trashes: A</pre>
<pre><br><a name="kjt_page_out_video"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_page_out_video</span></pre>
<pre>Action: Pages normal system memory (part of the FLOS!) back into $2000-$3FFF</pre>
<pre>Input Registers&nbsp; : none</pre>
<pre>Output Registers : none</pre>
<pre>Trashes: A</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_read_sysram_flat"></a>kjt_read_sysram_flat</span></pre>
<pre><br>Action: Reads system memory in a flat, linear addressing mode</pre>
<pre>Input Registers&nbsp; :</pre>
<pre> E:HL = $00000 - $7FFFF (address to read)</pre>
<pre><br>Output Registers :</pre>
<pre> A (byte read from address)</pre>
<pre> Trashes: BC,DE,HL</pre>
<pre><br>Notes: &nbsp;</pre>

<pre>* The routine saves and restores the entire port byte "sys_mem_select" around the<br>  read&nbsp;so make sure any interrupt service routine is in unpaged memory (&lt;$8000) or<br>  disable interrupts to avoid problems.</pre>
<pre>* As this routine is very slow, only use if convenience is more important than speed.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_write_sysram_flat"></a>kjt_write_sysram_flat</span></pre>
<pre><br>Action: Writes to system memory in a flat, linear addressing mode</pre>
<pre><br>Input Registers&nbsp; </pre>
<pre> E:HL = $00000 - $7FFFF (address to write),</pre>
<pre> A = byte to write</pre>
<pre><br>Output Registers : None (but see below)</pre>
<pre>Trashes: BC, DE, HL</pre>
<pre>Notes: &nbsp;</pre>

<pre>* The routine saves and restores&nbsp;the entire port byte "sys_mem_select" around the<br>  write&nbsp; so make sure any interrupt service routine is in unpaged memory (&lt;$8000) <br>  or disable interrupts to avoid problems.</pre>
<pre>* As this routine is not fast, only use if convenience is more important than speed.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_read_baddr"></a><span style="font-weight: bold;">kjt_read_baddr</span></pre>
<pre><br>Action: Reads a byte from system memory (allows programs in paged RAM (8000-FFFF)<br>        to easily read data from a different bank)</pre>
<pre><br>Input Registers:</pre>
<pre> B = Bank</pre>
<pre> HL = Address</pre>
<pre><br>Output registers:</pre>
<pre> A = byte from memory location specified</pre>
<pre><br>Notes: &nbsp;</pre>

<pre>* The routine saves and restores the entire port byte "sys_mem_select"<br>  around the read so make sure any interrupt service routine is in unpaged<br>  memory (&lt;$8000) or disable interrupts to avoid problems.</pre>
<pre>* As this routine is not fast, only use if convenience is more important than speed.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_write_baddr"></a><span style="font-weight: bold;">kjt_write_baddr</span></pre>
<pre><br>Action: Writes a byte to system memory, allows programs in paged RAM (8000-FFFF) to write<br>        data to a different bank</pre>
<pre><br>Input Registers:</pre>

<pre>B = Bank<br><br>HL = Address</pre>
<pre>A = Byte to writes</pre>
<pre><br>Output Registers: None<br><br><br>Notes: &nbsp;</pre>

<pre>* The routine saves and restores the entire port byte&nbsp; "sys_mem_select" around the<br>  write so make sure any interrupt service routine is in unpaged memory (&lt;$8000)<br>  or disable interrupts to avoid problems.</pre>
<pre>* As this routine is not fast, only use if convenience is more important than speed.</pre>
<pre>* Hardware support for writing to alternative pages in provided via the port<br>  SYS_ALT_WRITE_PAGE (see hardware manual)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_get_flos_bank"></a><span style="font-weight: bold;">kjt_get_flos_bank</span></pre>


<pre><br>Action: Returns the value of the bank being used by FLOS before the current command executed.<br><br>This is useful when a location header places a program in paged memory ($8000-$FFFF)<br>thus changing the bank selection to that of the program, but&nbsp;the program wants to<br>act on the memory in the bank selected by FLOS as if it were an internal command.</pre>

<pre>Input Registers: None</pre>
<pre><br>Output Registers:</pre>
<pre> A - The bank which FLOS was referencing.</pre>
<pre><br></pre><hr style="width: 100%; height: 2px;"><h3 style="text-decoration: underline;">KERNAL TEXT AND DISPLAY ROUTINES&nbsp;</h3><hr style="width: 100%; height: 2px;"><pre><br><br><span style="font-weight: bold;"><a name="kjt_print_string"></a>kjt_print_string</span></pre>
<pre><br>Action: Prints null-terminated ASCII text string at cursor position</pre>
<pre><br>Input Registers :<br><br> HL address of string (zero terminated)</pre>
<pre><br>Output Registers: None</pre>
<pre><br>Notes:</pre>


<pre> ASCII Char $0a = Line Feed<br> ASCII Char $0d = Carriage Return<br> ASCII Char $0b = Line Feed and Carriage return</pre>
<pre> HL returns pointing to the zero byte at end of the string</pre>
<pre>All other registers are preserved by this routine.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_clear_screen"></a>kjt_clear_screen</span></pre>
<pre><br>Action: clears OS screen and set cursor position to top left (0,0)</pre>
<pre>Input Registers&nbsp; : None</pre>
<pre>Output Registers : None</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_plot_char"></a>kjt_plot_char</span></pre>
<pre><br>Action: Prints ASCII character at supplied coordinates using current pen colours</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> A = ASCII character</pre>
<pre> B = x coord</pre>
<pre> C = y coord</pre>
<pre><br>Output Registers : None</pre>
<pre><br>Notes: </pre>
<pre>Plot_char does not change the current cursor position.</pre>
<pre>If a coordinate is outside the window, it is taken as zero</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_pen_"></a>kjt_get_pen </span></pre>
<pre><br>Action: Returns current pen colour</pre>
<pre><br>Input Registers&nbsp; : None</pre>
<pre><br>Output Registers :</pre>
<pre> A = $nm where "n" is the background and "m" is the foreground colour (see colour table below)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br style="font-weight: bold;"><span style="font-weight: bold;"><a name="kjt_set_pen"></a>kjt_set_pen</span></pre>
<pre><br>Action: Changes current pen colour</pre>
<pre><br>Input Registers&nbsp; : A = $nm where "n" is the background and "m" is the foreground colour </pre>
<pre>Available (default) colours:</pre>















<pre>0 - transparent (shows UI "paper" colour)<br>1 - black<br>2 - blue<br>3 - red<br>4 - magenta<br>5 - green<br>6 - cyan<br>7 - yellow<br>8 - white<br>9 - dark grey<br>a - mid grey<br>b - light grey<br>c - orange<br>d - light blue<br>e - light green<br>f - brown</pre>
<pre>Output Registers : None</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_get_colours"></a><span style="font-weight: bold;">kjt_get_colours</span></pre>
<pre><br>Action: Returns the location of the FLOS colour list.</pre>
<pre><br>Input registers: none</pre>
<pre><br>Output registers: <br><br>HL = location of colour list: 18&nbsp;words (RGB values).<br><br>Colour List:<br><br>+$00 - Paper <br>+$02 - Border<br>+$04 - Cursor<br>+$06 - 15 pen colours starting with pen 1<br><br>Note: FLOS stores its colour list under the hardware registers so system<br>memory needs to paged into that region if <span style="font-weight: bold; text-decoration: underline;">writing</span> directly to the address<br>returned from this call. (Simply reading the list poses no such problem). <br>In all cases, <span style="font-weight: bold;">kjt_set_colours</span> needs to be called to actually change the<br>palette (unless writing directly to the Hardware Palette Registers)</pre><br>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_set_colours_"></a><span style="font-weight: bold;">kjt_set_colours </span></pre>
<pre><br>Action: Sets FLOS border, paper and cursor colours and updates the pen colour list</pre>
<pre><br>Input registers: HL = location of the&nbsp;colour palette list (18 RGB words)</pre><pre>Colour List:<br><br>+$00 - Paper <br>+$02 - Border<br>+$04 - Cursor<br>+$06 - 15 pen colours starting with pen 1</pre><pre><br>Output registers: Input registers are trashed.</pre>
<pre>Notes:</pre>
<pre>Changes persist until FLOS restarts (whereas any changes made with the FLOS<br>command "COLOUR" are permanent until reset)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_draw_cursor"></a>kjt_draw_cursor</span></pre>
<pre><br>Action: Draws (or removes) the cursor at the current cursor position</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> HL = Offset of cursor char image within VRAM font data:</pre>



<pre> $0000 - $07FF = All zeroes<br> $0800 - $0FFF = Raster font image (256 horizontal bytes * 8 vertical bytes)<br> $1000 - $17FF = As above but with the bits inverted<br> $1800 - $1FFF = All ones</pre>
<pre> EG: </pre>


<pre> HL = $0000 : No data, IE: Delete the cursor<br> HL = $085f&nbsp;: Underscore cursor ($800-$8ff = top line of&nbsp; ASCII chars 0-255)<br> HL=&nbsp; $1800 :&nbsp;Solid block cursor</pre>

<pre><br>Output Registers : None</pre>
<pre><br><a name="kjt_get_input_string"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_get_input_string</span></pre>
<pre>Action: waits for user to enter a string of characters followed by Enter<br>        (characters appear on screen)</pre>
<pre><br>Input Registers&nbsp; : A - maximum characters allowed (set to 255 if dont care)</pre>
<pre><br>Output Registers :</pre>
<pre> HL = string location (zero terminated)</pre>
<pre> A&nbsp; = number of characters of entered string (zero if aborted by pressing ESCAPE)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a name="kjt_set_cursor_position"></a></pre>
<pre><span style="font-weight: bold;">kjt_set_cursor_position</span></pre>
<pre>Action: Repositions the text printing (cursor) position. If a coordinate is out<br>        of range it will be set to 0.</pre>
<pre><br>Input Registers :</pre>
<pre> B = X coord</pre>
<pre> C = Y coord</pre>
<pre><br>Output Registers:</pre>
<pre>&nbsp;Zero flag set if all OK</pre>
<pre>&nbsp;If zero flag not set: Invalid coordinates</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_flos_display"></a>kjt_flos_display</span></pre>
<pre>Action: Restores the video registers to the state used by the OS. Can be called<br>by FLOS based programs that change the display mode etc, meaning the OS does<br>not have to be complete restarted on program exit.</pre>
<pre>Input registers: None</pre>
<pre>Output registers: None</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><span style="font-weight: bold;"><a name="kjt_get_cursor_position"></a>kjt_get_cursor_pos</span>ition</span></pre>
<pre>Action: Returns the current cursor position</pre>
<pre><br>Input Registers : None</pre>
<pre><br>Output registers :</pre>
<pre> B= x coord</pre>
<pre> C =y coord</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_scroll_up"></a>kjt_scroll_up</span></pre>
<pre>Action: Scrolls the screen (and character map) up a line, inserting a blank<br>        line at the bottom of the screen.</pre>
<pre><br>Input Registers : None</pre>
<pre>Output registers : None</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_display_size"></a>kjt_get_display_size</span></pre>
<pre><br>Returns size of OS_window.</pre>
<pre><br>Input registers: None</pre>
<pre><br>Output registers:</pre>
<pre> B= x width (usually 40)</pre>
<pre> C =y height (usually 25)</pre>
<pre>Notes: All other registers preserved.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_charmap_addr_xy"></a>&nbsp;kjt_get_charmap_addr_xy</span></pre>
<pre><br>Action: Returns the charmap address of the character at coordinates x,y</pre>
<pre><br>Input registers :</pre>

<pre> B= x coord<br><br> C =y coord</pre>
<pre><br>Output registers:<br><br> HL = character map address of coords</pre>
<pre><br>Notes: All other registers are preserved.</pre>
<pre><br><a name="kjt_wait_vrt"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_wait_vrt</span></pre>
<pre>Action: Wait for last scanline of display</pre>

<pre>Input Registers&nbsp; : none<br><br>Output Registers : none</pre>
<pre>Trashes: A</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><a style="font-weight: bold;" name="kjt_patch_font"></a><span style="font-weight: bold;">kjt_patch_font</span></pre>

<pre>Action: Change an individual character in the FLOS font.</pre>
<pre><br>Input registers:</pre>
<pre> A = char number (must be 0-255, but note: Some chars &lt; 32 are unprintable using "kjt_print_string")</pre>
<pre> HL = address of new character pattern (8 bytes)</pre>
<pre><br>Output registers: &nbsp;None</pre>
<pre></pre><hr style="width: 100%; height: 2px;"><h3 style="text-decoration: underline;">MISC KERNAL ROUTINES:</h3><hr style="width: 100%; height: 2px;">
<pre><a name="kjt_hex_byte_to_ascii"></a></pre>
<pre><span style="font-weight: bold;">kjt_hex_byte_to_ascii</span></pre>
<pre>Action: puts ASCII version of the hex byte value in A at HL (two chars), HL=HL+2</pre>
<pre><br>Input Registers&nbsp;:<br><br> A = Hex number to convert</pre>
<pre><br>Output Registers : None <br><br><br>Notes: HL=HL+2</pre>
<pre>Trashes A </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_ascii_to_hex_word"></a>kjt_ascii_to_hex_word</span></pre>
<pre><br>Action: converts text string version of hex number at HL (1 to 4 chars max) to actual hex word in DE</pre>
<pre><br>Input Registers&nbsp; : </pre>
<pre> HL = source text (the routine scans from this location to the first&nbsp;character that is not a space)</pre>
<pre><br>Output Registers :</pre>
<pre> DE = result</pre>
<pre> HL = location of first space character after the hex string (IE: usually a space or null character)</pre>
<pre> ZF = set if all OK (also A=$00), Else:</pre>
<pre> A = $0c : Bad chars for hex</pre>
<pre> A = $1F : No chars found</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_dont_store_registers"></a>kjt_dont_store_registers</span></pre>
<pre><br>Action: Prevents the OS from noting the register values when a program exits and returns to OS.</pre>
<pre>Input Registers&nbsp; : None</pre>
<pre>Output Registers : None</pre>
<pre>Trashes: A</pre>
<pre><br><span style="font-weight: bold;"><a name="kjt_get_version"></a></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_get_version</span></pre>
<pre><br>Action: Returns FLOS and OSCA version values</pre>
<pre><br>Input Registers&nbsp; : none</pre>
<pre><br>Output Registers :</pre>
<pre>&nbsp;HL = OS version word</pre>
<pre>&nbsp;DE = Hardware version word</pre>
<pre><br>Trashes: BC</pre>
<pre><br><a name="kjt_compare_strings"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_compare_strings</span></pre>
<pre><br>Action: Compares two ASCII strings (not case sensitive)</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre>&nbsp;DE = address of string 1</pre>
<pre>&nbsp;HL = address of string 2</pre>
<pre>&nbsp;B&nbsp; = maximum number characters to compare</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre>Output Registers :<br><br> Carry flag: Only set if strings are the same.</pre>
<pre><br>Notes:</pre>
<pre>* Both strings should be zero terminated.</pre>
<pre>* Compare fails if string lengths are different unless count is reached first.</pre>
<pre>* Original HL/DE values are preserved.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_bchl_memfill_"></a>kjt_bchl_memfill</span></pre>
<pre><br>Action: Fill memory with value in accumulator</pre>
<pre><br>Input Registers&nbsp; :</pre>
<pre> HL = start address</pre>
<pre> BC = number of bytes to write</pre>
<pre> A = value to write</pre>
<pre><br>Output Registers : none</pre>
<pre><br>Notes: </pre>
<pre>Does NOT overflow from $FFFF into next bank.</pre>

<pre>Trashes: HL, BC, A</pre>
<pre><br><a name="kjt_timer_wait_"></a></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;">kjt_timer_wait </span></pre>
<pre><br>Action: Waits n x 16 microseconds and returns.</pre>
<pre><br>Input Registers:<br><br> A = number of 16 microsecond periods to wait</pre>
<pre><br>Output Registers: None</pre>
<pre><br>Note: Preserves all registers except A</pre>
<pre><br><span style="font-weight: bold;"></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_set_commander"></a>kjt_set_commander</span></pre>
<pre><br>Action: Sets a "permanent" command string that is to be launched when progams exit</pre>
<pre><br>Input Registers:</pre>
<pre> HL = location of command string (40 chars max)</pre>
<pre><br>Output Registers: None</pre>
<pre><br>Notes: </pre>
<pre>* The "commander program" will run on when a program exits back to FLOS unless<br>  that program specifically&nbsp; tells FLOS to launch some other program (with A=$FE<br>  on exit). In this case, the commander program will&nbsp;eventually launch when control<br>  is passed back to FLOS (IE: A &lt;&gt; $FE on exit)</pre>
<pre>* To remove the commander string, point HL at a null string (a zero btyte in memory)<br>  and call the routine.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3 style="text-decoration: underline;">ENVIRONMENT VARIABLE RELATED CALLS&nbsp;</h3>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_set_envar"></a>kjt_set_envar</span></pre>
<pre>Action: Sets an environment variable (or updates a variable if it already exists)</pre>
<pre><br>Input Registers:</pre>
<pre> HL = name of variable (4 chars max, zero-termination required if less than 4 chars)</pre>
<pre> DE = address of data for variable (4 bytes)</pre>
<pre><br>Output Registers:<br><br> Zero Flag = set if all OK, not set if no space for new variable (A = $2c)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"><a name="kjt_get_envar"></a>kjt_get_envar</span></pre>
<pre><br>Action: gets (address of) value of an environment variable</pre>
<pre><br>Input Registers :</pre>
<pre> HL = name of variable (4 chars max, zero-termination required if less than 4 chars)</pre>

<pre><br>Output Registers:</pre>
<pre> Zero Flag = Set : all OK,&nbsp; HL = address of data for variable (4 bytes)</pre>
<pre> Zero Flag = Not set: variable was not found, (A = $2b, hl = location of envar list, b = max envars)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="kjt_delete_envar"></a>kjt_delete_envar</span></pre>
<pre><br>Action: deletes an environment variable</pre>
<pre><br>Input Registers :</pre>
<pre> HL = name of variable (4 chars max, zero-termination required if less than 4 chars)</pre>
<pre><br>Output Registers:</pre>
<pre> Zero flag = set if all OK, not set if named variable not found</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"></span></pre>
<br>
</body></html>