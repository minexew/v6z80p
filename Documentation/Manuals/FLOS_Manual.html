<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>FLOS Manual</title></head>
<body>
<h3>FLOS: A Simple Command Line Operating System for OSCA on the
V6Z80P by Phil Ruston</h3>
<pre>Last updated 21st Sept 2012, for FLOS v605</pre>
<pre><span style="text-decoration: underline;"><br>Description:</span></pre>
<pre>FLOS operates in a similar manner to the memory monitor / freezer cartridges of the home computer era.<br>In some ways it also behaves like a more modern DOS, allowing disk-based programs to be executed by<br>entering their filenames etc. </pre>
<pre><span style="text-decoration: underline;"><br>Installation and OS file details:</span></pre>
<pre>FLOS is normally loaded as a file from the root directory of a FAT16 formatted SD card &#8211; the bootcode<br>will load the first *.OSF file it finds to address $1000 and begin execution at $1010. The OS can also be<br>installed on the V6Z80P's EEPROM (by using the application &#8220;EEPROM.EXE&#8221;). The bootloader looks for the<br>OS on the SD card first, if it is not found it checks the EEPROM. If an OS is not found on either, then<br>the user is prompted to download an .OSF file via the serial link.</pre>
<pre>(The .OSF file is just a Z80 code binary file with a 16-byte header, the <a href="#Format_of_header">format</a> of which is given at<br>the end of this document.)</pre>
<pre><span style="text-decoration: underline;"><br>Using FLOS at command line level:</span></pre>
<pre><br>When FLOS starts, it looks for FAT16 partitions on the SD Card (if inserted), these are labeled VOL0:,<br>VOL1: etc. (Note that FLOS cannot automatically detect card swaps, so the drives must be remounted<br>with the command 'MOUNT' if this happens.)</pre>
<pre>There is a set of internal debugging and disk navigation commands. To run a command, type its name<br>(and any parameters it requires) and press Enter. (Entering &#8220;?&#8221; shows a list of the internal commands).</pre>
<pre>The UI is a full screen editor, so the cursor can be moved back to any previous command and Enter<br>pressed again to re-execute it if desired. Other keys active in the UI:</pre>
<pre>Home      - Puts cursor at left side<br><span style="font-family: monospace;"></span>Page Up   - Puts cursor at top<br>Page Down - Puts cursor at bottom, left on new line<br><span style="font-family: monospace;"></span>Insert    - Switches between overwrite and insert mode<br><span style="font-family: monospace;"></span>Alt       - Use alt_keymap character<br><span style="font-family: monospace;"></span>F1-F9     - Run an arbitrary command string (see "<a href="#Programmable_Function_Keys">Programmable Function keys</a>")</pre>
<pre><br><span style="text-decoration: underline;">Internal command list:</span></pre>
<pre><a href="#B_-_Bank_select">B</a>       - Set the bank of System RAM appearing in Z80 address space $8000-$FFFF<br><a href="#C_-_Copy_bytes">C</a>       - Copy bytes in memory (from currently selected bank)<br><a href="#CD_-_Change_Directory">CD</a>      - Change directory<br><a href="#CLS_-_Clear">CLS</a>     - Clear OS screen<br><a href="#COLOUR_-_Changes">COLOUR</a>  &#8211; Change the OS colour scheme<br><a href="#D_-_Disassemble">D</a> &nbsp;&nbsp; &nbsp;  - Disassemble Z80 code<br><a href="#DEL-_Delete_File">DEL</a>&nbsp;&nbsp;   - Delete a file<br><a href="#DIR_-_Show_Directory">DIR</a>&nbsp;&nbsp; &nbsp; - Show directory<br><a href="#EXEC_-_Execute">EXEC</a>&nbsp;&nbsp;  &#8211; Execute a script<br><a href="#F_-_Fill">F</a> &nbsp;&nbsp;&nbsp; &nbsp; - Fill memory<br><a href="#FORMAT">FORMAT</a>  - Format the (entire) SD card as a single FAT16 partition. <br><a href="#G_-_Goto">G</a> &nbsp;&nbsp; &nbsp;  - Goto location (IE: Call a Z80 routine) ("G 0" resets the Z80)<br><a href="#H_-_Hunt">H</a>&nbsp;&nbsp; &nbsp;   - Hunt in memory for hex bytes or text<br><a href="#LB_-_Loads_bytes">LB</a>&nbsp;&nbsp; &nbsp;  - Load Binary file from disk to system RAM<br><a href="#M_-_Show_memory">M</a> &nbsp;&nbsp; &nbsp;  - Show system RAM contents as hex bytes<br><a href="#MD_-_Make_new_dir">MD</a>&nbsp;&nbsp; &nbsp;  - Make a new directory<br><a href="#MOUNT_-_Rescans">MOUNT</a>&nbsp;  &#8211; Remount drives<br><a href="#R_-_Show_reg">R</a> &nbsp;&nbsp; &nbsp;  - Show CPU registers<br><a href="#RD_-_Remove_dir">RD</a>&nbsp;&nbsp; &nbsp;  - Remove directory<br><a href="#RX_-_Receive">RX</a> &nbsp;&nbsp; &nbsp; - Receive file (to RAM) from PC via serial link (and optionally, run it)<br><a href="#SB_-_Save_bytes">SB</a>&nbsp;&nbsp; &nbsp;  - Save Binary file from RAM to disk<br><a href="#T_-_Show_mem">T</a>&nbsp;&nbsp; &nbsp;   - Show system RAM as ASCII text<br><a href="#TX_-_Transmit">TX</a>&nbsp;&nbsp; &nbsp;  - Transmit bytes from system RAM (to PC) via serial link<br><a href="#VERS">VERS</a>&nbsp;&nbsp; &nbsp;- Show OSCA / FLOS version<br><a href="#VOLx:">VOLx:</a>&nbsp;&nbsp; - Switch volume without altering the directory position<br><a href="#:_-_Put_hex">:</a> &nbsp;&nbsp;&nbsp; &nbsp; - Put hex bytes in memory<br><a href="#_-_Put_text">&gt;</a> &nbsp;&nbsp;&nbsp; &nbsp; - Put text in memory<br><a href="#_-_Put_hex">&lt;</a>&nbsp;&nbsp; &nbsp;   - Put bytes in memory and disassemble</pre>
<pre>More detailed <a href="#Internal_Commands">descriptions</a> are given at the end of this manual and can be shown in FLOS itself with the<br>command HELP [command_name].</pre>
<pre>Throughout FLOS, all numeric data is in hexadecimal (apart from the free disk space reported by the<br>DIR command). The default keymap is that of the UK, but this can be changed with the command &#8221;Keymap&#8221;.<br>To assist with such settings, FLOS will run a batch file called &#8220;BOOT_RUN.SCR&#8221; at start-up if it is<br>present in the root directory of the SD card. (This script - along with any others launched from the<br>EXEC command - can be aborted by pressing CTRL+C).</pre>
<pre><br><span style="text-decoration: underline;"><a name="Programmable_Function_Keys"></a>Programmable Function Keys:</span></pre>
<pre>FLOS allows the function keys F1 to F9 to be assigned command strings. To use this feature simply<br>put text files (containing the desired command string) called "F1.CMD" (to "F9.CMD") in a directory<br>of your choice and set the environment variable &#8220;%KEY&#8221; to point to that directory. (Note: the default<br>BOOT_RUN.SCR script sets %KEY to VOL0:KEYMAPS by default so it is probably best to locate Fx.CMD<br>files there). Alternatively, just place the Fx.CMD file in the current working folder - the most<br>local version has priority at the time that a function key is pressed. The command strings can be<br>a maximum of 40 characters long but can be an EXEC command if desired.</pre>
<pre><br></pre>
<pre style="text-decoration: underline;">External Commands:</pre>
<pre>If the command entered is not recognized as one of the internal commands listed above, FLOS will look<br>in the current disk directory (and then check the &#8220;executables path&#8221;) for a file with an .exe extension<br>that matches the string entered. If found, the file is assumed to be a program, loaded and run.</pre>
<pre>The &#8220;executables path&#8221; is set up using the directory assignments %EX0 to %EX9. By default, FLOS itself<br>sets %EX0 to VOL0:COMMANDS (and the default BOOT_RUN.SCR file sets %EX1 to VOL0:UTILS).</pre>
<pre>The difference between programs deemed COMMANDS and those deemed UTILS is only that commands load to<br>the top of system memory (Bank $0E) to help avoid corrupting user programs which would usually be<br>located at $5000. (Such commands would ideally be <span style="font-style: italic;">internal FLOS commands</span> if there was space in the<br>OS for them.)</pre>
<pre><br><span style="text-decoration: underline;">EXTERNAL COMMAND LIST:</span></pre>

<pre><a href="#ASSIGN.EXE">ASSIGN.EXE</a>&nbsp;&nbsp; &nbsp;- Assigns a directory path to a short string of characters<br><a href="#BAUD.EXE">BAUD.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Sets the BAUD rate (57600/115200 supported)<br><a href="#BOOT.EXE">BOOT.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Reconfigure the FPGA from a given slot<br><a href="#CHFNT.EXE">CHFNT.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;- Changes the OS font<br><a href="#CMP.EXE">CMP.EXE</a> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Compares two areas of system memory, shows differences<br><a href="#ECHO.EXE">ECHO.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Displays short messages<br><a href="#FILEINFO.EXE">FILEINFO.EXE</a>&nbsp;&nbsp;- Shows info about a file<br><a href="#FILECMP.EXE">FILECMP.EXE</a>&nbsp;&nbsp; - Compares two files, shows differences&nbsp;&nbsp; &nbsp;<br><a href="#FILERX.EXE">FILERX.EXE</a>&nbsp;&nbsp; &nbsp;- Receive a file via Serial Link and put in current dir<br><a href="#FILETX.EXE">FILETX.EXE</a>&nbsp;&nbsp; &nbsp;- Send a file from current dir (to PC) via Serial Link<br><a href="#GOTO.EXE">GOTO.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Script control (see script section)<br><a href="#HELP.EXE">HELP.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Displays help files<br><a href="#IF.EXE">IF.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Script control (see script section)<br><a href="#INPUTSTR.EXE">INPUTSTR.EXE</a>&nbsp;&nbsp;- Get input from user, place in environment variable<br><a href="#INPUTNUM.EXE">INPUTNUM.EXE</a>&nbsp;&nbsp;- Get hex value from user, place in environment variable<br><a href="#KEYMAP.EXE">KEYMAP.EXE</a> &nbsp;&nbsp; - Changes the keyboard mapping for non-UK keyboards.<br><a href="#LCD.EXE">LCD.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - LineCop disassembler<br><a href="#LOADSPR.EXE">LOADSPR.EXE</a>&nbsp;&nbsp; - Loads a file to Sprite RAM<br><a href="#LOADVRAM.EXE">LOADVRAM.EXE</a>&nbsp;&nbsp;- Loads a file to Video RAM<br><a href="#MONO.EXE">MONO.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Sets the stereo panning to &#8220;All channels to both sides&#8221;<br><a href="#MOUSE.EXE">MOUSE.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;- Activates the mouse driver<br><a href="#SAVEVRAM.EXE">SAVEVRAM.EXE</a>&nbsp;&nbsp;- Saves data from Video RAM to a file<br><a href="#SET.EXE">SET.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - Sets an environment variable (or shows those defined)<br><a href="#STEREO.EXE">STEREO.EXE</a>&nbsp;&nbsp; &nbsp;- Sets the stereo panning to Channels 0+2: Left 1+3:right<br><a href="#TYPE.EXE">TYPE.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- Displays text files<br><a href="#VGA50.EXE">VGA50.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;- Sets VGA mode to 50Hz (non standard)<br><a href="#VGA60.EXE">VGA60.EXE</a>&nbsp;&nbsp; &nbsp;&nbsp;- Sets VGA mode to 60Hz<br> <br>Documentation for these programs is also available by typing "HELP [command]".</pre>
<pre style="text-decoration: underline;"><br>UTILS:</pre>
<pre>ASM.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Assemble Z80 source code<br>BULKFILE.EXE   - Makes a new file by joining the all files in dir (index at top)<br>DDIR.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;- Alernative DIR command - Decimal listing (By Stefano)<br>DISKTOOL.EXE&nbsp;&nbsp;&nbsp;- Allows partitioning of SD cards.<br>EDIT.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;- A simple text editor<br>EEPROM.EXE&nbsp;&nbsp; &nbsp;&nbsp;- An app to write FPGA configs etc to the onboard EEPROM<br>EMU.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Used to launch Alessandro&#8217;s cycle-perfect Spectrum Emulators<br>FILEMGR.EXE&nbsp;&nbsp; &nbsp;- A simple file manager<br>FIRMWARE.EXE &nbsp;&nbsp;- Writes blocks of data to the EEPROM 'wholesale'<br>FS.EXE &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- File viewer / launcher (by Valen)<br>HEXOR.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- File Hex Editor (by Enzo)<br>MEMCLR.EXE&nbsp;&nbsp; &nbsp;&nbsp;- Clears entire memory (apart from FLOS) (By Daniel)<br>MEMRND.EXE&nbsp;&nbsp; &nbsp;&nbsp;- Fills memory with random data (apart from FLOS) (By Daniel)<br>MODPLAY.EXE&nbsp;&nbsp; &nbsp;- Protracker format music player<br>PCXSHOW.EXE&nbsp;&nbsp; &nbsp;- Displays .pcx format graphic files (By Enzo)<br>PLAYCV6.EXE&nbsp;&nbsp; &nbsp;- Plays .cv6 video files (by Daniel)<br>PLAYMV6.EXE&nbsp;&nbsp; &nbsp;- Plays .mv6 video files (by Daniel)<br>PLAYWAV.EXE&nbsp;&nbsp; &nbsp;- Plays .wav format sound files<br>PT3PLAY.EXE&nbsp;&nbsp; &nbsp;- PT3 format music player (by Daniel)<br>SHOWBMP.EXE&nbsp;&nbsp; &nbsp;- Displays .bmp pictures<br>SHOWVRAM.EXE&nbsp;&nbsp;&nbsp;- Display section of video RAM<br>SQ.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; - File Packer (by Stefano)<br>USQ.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- File Unpacker (by Stefano)<br>ZPACK.EXE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;- File packer (by Enzo)</pre>
<pre>Documentation for most of these programs is also available by typing "HELP [command]",<br>or is provided in their respective folders.</pre>
<pre><span style="text-decoration: underline;"></span><br><br><span style="text-decoration: underline;">Environment Variables ("cookies")</span>:<br><br>Environment variables are a simple way for programs to use common, global settings stored<br>within FLOS itself. Each variable has a name of 1 to 4 ASCII characters (no spaces) and an<br>associated value 4 bytes long. The FLOS commands "SET", &#8220;INPUTSTR&#8221; and &#8220;INPUTNUM&#8221; can<br>set an environment variable at the command line (and kernal calls are provided to manipulate<br>them within programs).&nbsp;FLOS itself sets the environment variable &#8220;ERR&#8221; with the error code<br>returned in A whenever a program returns control to it. At present there is space for 16<br>environment variables - they are all deleted whenever FLOS restarts.<br><br>The environment variables can also hold shortcuts to long directory paths, these are set<br>up using the ASSIGN command. When an environment variable is used in this way, its name can<br>only be 3 characters long and is automatically prefixed with "%". Note that because of the<br>limited space, an entire path string cannot be stored for "assignments", instead a hook to<br>the ultimate target folder is used (the volume number and directory cluster). To help prevent<br>problems when assigned directories are deleted, associated environment variables are automatically<br>removed when a directory is deleted. All assigned environment variables apart from %EX0 are<br>deleted when a MOUNT command is performed.<br><br><br><span style="text-decoration: underline;">Scripts:<br><br></span>Simple scripts (batch files) with limited flow control can be used by FLOS. These are standard<br>text files launched with &#8220;EXEC script_name&#8221;. Note that FLOS scripts cannot run other scripts.<br>Script flow control is achieved with in-script labels (up to 4 characters in square brackets)<br>and the following commands:<br><br>IF          - Jump on condition<br>GOTO&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Unconditional jump to label<br>INPUTNUM&nbsp;&nbsp; &nbsp;- Get a hex number from user (up to 32 bit)<br>INPUTSTR&nbsp;&nbsp; &nbsp;- Get string (up to 4 chars) from user<br>FILEINFO&nbsp;&nbsp; &nbsp;- Get file size in envar &#8220;FSIZ&#8221;<br>SET&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; - Manage environment variables<br><br>As these are external commands they load to the top of system RAM to avoid corrupting any user<br>program/data. See the command list at the end of this document for full parameter possibilities<br>of the above commands (or use HELP within FLOS)<br><br>An example script:<br><br>ECHO CHOOSE AN OPTION<br>ECHO 1. RED TEXT<br>ECHO 2. GREEN TEXT<br>ECHO 3. YELLOW TEXT<br>INPUTNUM PEN<br>IF PEN = 1 GOTO RED<br>IF PEN = 2 GOTO GRN<br>IF PEN = 3 GOTO YEL<br>ECHO INVALID CHOICE<br>GOTO END<br>[RED]<br>COLOUR 3<br>GOTO DONE<br>[GRN]<br>COLOUR 5<br>GOTO DONE<br>[YEL]<br>COLOUR 7<br>[DONE]<br>ECHO CHOICE ACCEPTED<br>[END]<br><br>Notes: Comments are not supported in scripts. Lines must be left aligned. Labels are 4 chars max<br>and must be in square brackets when defining their locations. No other text can be on the same line<br>as a label location. The termination point is the end of the script file, so if a script is to break<br>before that point then a GOTO is required as in the above example.<br><br>Script control is achieved internally using the environment variables. Mainly, an environment<br>variable called GOTO is set by the IF command (and of course &#8220;GOTO&#8221;, which is essentially the<br>same as &#8220;SET GOTO = label&#8221;<br><br><br><br><span style="text-decoration: underline;">FLOS Programs and Banked memory</span>:<br><br>FLOS-friendly programs - by default - load and run from $5000. If the program file extends into the<br>paged memory area ($8000-$FFFF), its data will always follow on immediately into the first bank<br>(bank 0), and then (if large enough) the subsequent banks, looping around to $8000 whenever the<br>address overflows from $FFFF. When the program runs, bank 0 will be selected by FLOS and when<br>control is returned to FLOS the bank setting is restored to whatever bank was active before<br>the program ran.<br><br>It is possible to force programs to load and run from any address above $5000 by adding<br>a <a href="#Program_Location_header">special header</a> to the start of the code (see details below). The header specifies which bank<br>to use if the required location is within the paged memory area. If the program extends beyond<br>address $FFFF, the subsequent banks are used with the address counter looping around to<br>$8000 each overflow. When the program runs, the bank specified by the header is selected<br>and the original bank is restored by FLOS on exit. <br><br><br><br><span style="text-decoration: underline;">FLOS-friendly Programming:</span></pre>
<pre><br><span style="text-decoration: underline;">Startup:</span><br><br>When FLOS runs a program, the following registers are pre-set:</pre>
<pre>HL = contains the address of the first non-space character after the entered command name (if no<br>arguments were supplied, HL will be pointing at a zero). Apps can scan from this address for<br>parameters if required &#8211; when zero is encountered, the search should be terminated.</pre>
<pre>A&nbsp; = The volume number from which the program loaded.<br><br>DE = The directory cluster from which the program loaded. </pre>
<pre>The above values allow a program to know the folder / volume it loaded from. This is useful because<br>programs can be started indirectly via the exectuable path envars (%EX0 etc) in which case the &#8220;current&#8221;<br>folder and drive may not be the same as the source of the program.</pre>
<pre>IY = The location of a 32bit longword (little endian) that is the file length. Also, the 16bit word<br>at IY+8 is the first cluster of the file - these values may be useful for advanced loaders etc.</pre>
<pre><span style="text-decoration: underline;"><br>Execution:</span><br><br>Programs can hit the hardware as desired but bear in mind that if critical settings<br>used by FLOS have been altered by the user program, certain Kernal calls may not work<br>and it may not be possible to exit to FLOS. <br><br><span style="text-decoration: underline;"><br>Exit:</span></pre>
<pre>Programs returning control to FLOS should set the zero flag if no return message is to be<br>displayed (see list at end of this document). EG: end in XOR A, RET. If the zero flag is not set,<br>a message associated with the value in A is displayed. If the zero flag is not set and A = 0, then<br>a driver error code is assumed to be being passed back in B.&nbsp; A program&#8217;s return code returned in<br>A is also placed in the lowest byte of an environment variable called &#8220;ERR&#8221; (the value from B is<br>copied to the ERR Envar bits [15:8] when A is 0 and the Zero Flag is not set.)</pre>
<pre>In all cases, if upon return A = $FF then FLOS will restart. If A = $FE a new command will be<br>launched (Set HL to point to the required zero-terminated command string). It is also possible<br>to make FLOS always run a command upon return - this can be set up with the kernal call<br>&#8220;kjt_set_commander&#8221; (the commander persists even if FLOS is restarted with return code $ff,<br>however it can be cancelled by holding CTRL at restart).</pre>
<pre>If a program has made changes to the display registers, returning to FLOS without the restart<br>code ($FF) in A will NOT restore the registers the values which FLOS requires. To do this,<br>call &#8220;KJT_FLOS_DISPLAY&#8221; prior to program exit. (This is only useful if the video RAM area<br>$10000-$1ffff has not been overwritten. If it has, then it is necessary to use the restart<br>code $FF).</pre>
<pre>By default, FLOS logs the Z80 register set when programs return control to it (as displayed<br>with the R command). If for some reason this is not required the program can call the KJT<br>routine &#8220;kjt_dont_store_registers&#8221;.</pre>
<pre><br><br><span style="text-decoration: underline;"><a name="Program_Location_header"></a>Program Location header:</span></pre>
<pre>If necessary, programs (IE: files with .exe extensions) can be made to load and run from a<br>specific location and also be truncated to 'n' bytes. This is achieved by putting the following<br>header at the start of the code:</pre>
<pre>--------------------------------------------------------------------------------------------------</pre>
<pre>my_location equ $f000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre>my_bank     equ $00          ; desired bank (used if location is $8000 to $FFFF)<br><br>            org my_location&nbsp;&nbsp;; desired load address<br><br>load_loc    db $ed,$00&nbsp;&nbsp; &nbsp;   ; header ID (Invalid, but safe Z80 instruction)<br>            jr exec_addr&nbsp;&nbsp;   ; jump over remaining header data <br>            dw load_loc&nbsp;&nbsp; &nbsp;  ; Z80 address file should load to <br>            db my_bank&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ; upper 32KB bank that file should load into<br>            db xy&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  ; control byte: 1=truncate using next 3 bytes<br>            dw abcd&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;  ; Load length 15:0 (if truncate feature required)<br>            db ef            ; Load length 23:16 (""&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"")</pre>
<pre>exec_addr</pre>
<pre>---------------------------------------------------------------------------------------------------</pre>
<pre><br>Main program execution begins from "exec_addr". The labels "my_location" and "my_bank" obviously<br>should be set to suit the program. (Note: The header is loaded to "my_location" as a normal part<br>of the file).</pre>
<pre>The header source above is available as an include in "code library/program header" - (the version<br>there also checks to make sure the code has indeed been loaded to its correct location).</pre>
<pre>As mentioned above, when a program uses the header to load to paged memory ($8000-$FFFF), the bank<br>where it is located is selected prior to execution. When it returns control to FLOS, the original FLOS<br>bank is automatically restored. If a program itself wishes to know which bank was orignally seleced<br>by FLOS, the kernal call KJT_GET_FLOS_BANK can be used.</pre>
<pre><br><span style="text-decoration: underline;">Development tools:</span></pre>
<pre>Any preferred Z80 assembler can be used on a PC / other system (it is also possible to develop entirely<br>on the V6Z80P using the FLOS commands EDIT.EXE and ASM.EXE - note that the existing sources will need<br>slight modifictions however, due to 8.3 filenames etc). The project's source code was developed on<br>the PC using a plain text editor and assembled with the freeware assembler 'Pasmo'. In the project's<br>code folders there'll be a batch file called "assemble.bat". This contains the Pasmo commands required<br>to produce the Z80 binary. The .asm files can be dragged to this batch file and it'll produce a binary<br>file with the extension ".asm.bin". (For convenience, my Windows program "pasmo_rename.exe" takes the<br>.asm.bin and renames it to an 8.3 format filename with .exe extension.) See the "example_source"<br>folder for templates and simple examples.</pre>
<pre>When developing on the PC, it is sometimes desirable to automatically send the assembled code to<br>FLOS immediately upon assembly. Daniel's command line program "sendv6" (for Windows / Linux) can be<br>added to the batch file to do this, short-cutting the need to browse to the file with the Serial Link<br>application. See: Contributions / Daniel / Linux tools / for Sendv6.&nbsp; (Enter "RX !" under FLOS beforehand<br>to receive and run at the V6Z80P end).</pre>
<pre style="text-decoration: underline;"><br>Resources used by FLOS:</pre>
<pre>Default OSCA ROM : $0000-$01FF<br><br>System RAM       : $00200-$04FFF</pre>
<pre>Video RAM&nbsp;       : $10000-$1FFFF</pre>
<pre> OS display bitplanes: $10000,$12000,$14000,$16000,$18000,$1A000<br>&nbsp;Char colour buffer&nbsp; : $1C000-$1C3E8<br> <span style="font-style: italic;">Window routines : $1C400-$1DFFF (Note: Not actually used by FLOS itself)</span><br>&nbsp;Font bitplane images: $1E000-$1FFFF</pre>
<pre>Sprite RAM        : $1FF00-$1FFFF</pre>
<pre>Also used by FLOS: The video registers associated with bitmap planar display, The timer hardware,<br>IRQ mode 1 for keyboard (and mouse) and the Blitter.</pre>
<pre>If the user program has made radical changes to these systems, then it may be best to restart FLOS<br>on exit (clear the carry flag and set accumulator to $FF)</pre>
<pre>As FLOS internally uses the blitter and the first word of the hardware multiply table (index 0) &#8211;<br>user programs should take into account that these systems are reset to the values FLOS requires<br>every time control is passed to it (via KJT calls etc) and will not be restored upon return.</pre>
<pre><br><span style="text-decoration: underline;">Debugging:</span></pre>
<pre>FLOS sets the NMI vector to a freeze subroutine so that programs can be stopped and the memory /<br>registers examined.&nbsp; A push switch across the NMI pin to Ground (see pin header diagram in the<br>documentation folder) can be used to stop a program and return to the OS. Note: it is not possible<br>to restart the "frozen" program from the point it was stopped and also that the OSCA ROM must not be<br>paged out (and lower 32KB page selection bits = zero) at the point the button is pressed.</pre>
<pre><br></pre>
<pre><span style="text-decoration: underline;">Calling Kernal Routines:</span></pre>
<pre>The Kernal Jump Table is a simple way (indirect jumps) of allowing routines within the operating<br>system to be used by external programs (even if the OS code changes). IE: The location of the jump<br>table and the order of its entries should never change, so calls to FLOS routines can be made<br>indirectly via the KJT_* entries.</pre>
<pre>The KJT equates file (from the &#8220;equates&#8221; folder) should be included into the user program&#8217;s<br>source, allowing the routines to be called by name. In general, you should Push and Pop any<br>important registers around KJT routines unless it is specifically stated which registers are<br>preserved.</pre>
<pre>For full details about each kernal routine, see the document "<a href="Kernal_Call_Descriptions.html">kernal_call_descriptions.html</a>"<br>in the &#8220;documentation/&#8221; folder.</pre>
<pre>Note: Generally speaking, kernal routines should not be called when video memory is paged<br>into $2000-$3FFF or sprite RAM is paged in at $1000-$1FFF (the call KJT_PAGE_OUT_VIDEO is<br>guaranteed to be safe however).<br><br>An example FLOS program that calls a kernal routine to display a text message:</pre>
<pre>;---------------------------------------------------------------------------<br>; Standard header for OSCA and FLOS<br>;---------------------------------------------------------------------------</pre>
<pre>include "kernal_jump_table.asm"&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; useful equates<br>include "osca_hardware_equates.asm"&nbsp;&nbsp; &nbsp;; ""&nbsp;&nbsp; &nbsp;""<br>include "system_equates.asm"&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;; ""&nbsp;&nbsp; &nbsp;""</pre>
<pre><br>;==========================================================================<br><br>	org $5000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;; Start of free memory</pre>
<pre>	ld hl,my_text&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;; location of ASCII string<br>	call kjt_print_string&nbsp;&nbsp;; use OS print ascii string routine<br>	xor a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;; report no error on return <br>	ret&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; back to FLOS&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre>;--------------------------------------------------------------------------<br><br>my_text db "Hello World!",13,10,0&nbsp;&nbsp; &nbsp;; Text followed by &lt;CR+LF&gt; and zero</pre>
<pre>;----------------------------------------------------------------------------</pre>
<pre><br><span style="text-decoration: underline;">Interrupts:</span></pre>
<pre>The OSCA ROM has the instruction JP $0A00 at $38 (IRQ) and JP $0A03 at $66&nbsp;(NMI). OSCA is<br>designed to use Interrupt Mode 1. FLOS places the following code at these locations:</pre>
<pre>$0A00: JP aabb (where aabb is FLOS's default IRQ handler)<br>$0A03: JP ccdd (where ccdd is FLOS's default NMI handler)</pre>
<pre>FLOS uses the global labels <span style="font-style: italic;">irq_vector</span> and <span style="font-style: italic;">nmi_vector</span> for $0A01 and $0A04 respectively. As<br>indicated above, these are set by default to FLOS's IRQ/NMI routines but can be set by external<br>apps if desired. Also, the OSCA ROM can be banked out if desired, allowing direct access to the<br>IRQ vectors. See OSCA hardware manual for details about switching out the ROM.</pre>
<pre>FLOS's IRQ routine handles keyboard and mouse interrupts only (for operating the kernal keyboard<br>and mouse routines). If an external program wants to use its own interrupt handler (for example<br>to process timer, audio and/or video interrupts) but still use the kernal keyboard and mouse<br>routines, the FLOS IRQ routines can be called via two Kernal Jump Table entries: kjt_keyboard_irq<br>code and kjt_mouse_irq_code. (The user's interrupt handler just needs to test bits 0:1 of the<br>port sys_irq_ps2_flags and call the appropriate routine if the relevant bit is set.)</pre>
<pre>FLOS's NMI routine is used in association with a push switch across the V6Z80P pin header's<br>NMI pins. When an NMI is triggered, the running program stops, control is returned to FLOS <br>and the register set is displayed. (The NMI vector is changed to point to a RETN instruction<br>when FLOS itself is running).</pre>
<pre></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3><span style="text-decoration: underline; font-weight: bold;">GLOSSARY</span></h3>
<pre></pre>
<pre><br><a name="Internal_Commands"></a>Internal Commands &#8211; Full Descriptions:</pre>
<pre><br><span style="font-weight: bold;"><a name="B_-_Bank_select"></a>B</span> - Bank select (ie: select one of 15 32KB banks for Z80 address $8000-$FFFF)<br><br>	Use: B <span style="font-style: italic;">n</span>&nbsp;&nbsp; &nbsp;(n = 0 to E)<br>	<br>	Bank 0 pages in system RAM $08000-$0FFFF to $8000-$FFFF<br>	Bank 1 pages in system RAM $10000-$17fff to $8000-$FFFF</pre>
<pre>	and so on..</pre>
<pre>	FLOS does not allow system RAM $00000-$07fff to be paged into<br>	$8000-$ffff (though the OSCA architecture does allow it.)</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="C_-_Copy_bytes"></a>C</span> - Copy bytes in memory (from currently selected bank)<br><br>	Use: C <span style="font-style: italic;">start_address end_address destination_address [dest bank]</span></pre>
<pre><br><br><br><br><span style="font-weight: bold;"><a name="CD_-_Change_Directory"></a>CD</span> - Change Directory / Drive (or show path)</pre>
<pre>	Use: CD (no args)        (show current dir path)<br>             CD ..&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;        (go to parent dir)<br>             CD /&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(go to root dir)<br>             CD /dir             (go to a dir in root)<br>             CD ../../hats       (go up two dir levels and into "hats")<br>             CD subdir<span style="font-style: italic;">&nbsp;&nbsp;</span> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;(change to subdir)<br>             CD VOLn: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;(change to volume n)<br>             CD VOLn:hats/berets&nbsp;(change volume and subdir)<br>             CD %xyz&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; (change to assigned directory)<br><br></pre><pre><br><br><span style="font-weight: bold;"><a name="CLS_-_Clear"></a>CLS</span> - Clear OS screen</pre>
<pre>      Use: CLS (no args)</pre>
<pre><br><br><br><br><span style="font-weight: bold;"><a name="COLOUR_-_Changes"></a>COLOUR</span> - Changes the FLOS colour scheme</pre>
<pre>         Use: COLOUR <span style="font-style: italic;">pen [paper] [border] [cursor] </span></pre>
<pre>         Notes: <span style="font-style: italic;">'pen'</span> = $nm where 'n' is the font character's background colour<br>                and 'm' is the foreground colour as per the following table:<br><br>	0 - transparent (shows "paper" colour)<br>	1 - black<br>	2 - blue<br>	3 - red<br>	4 - magenta<br>	5 - green<br>	6 - cyan<br>	7 - yellow<br>	8 - white<br>	9 - dark grey<br>	a - mid grey<br>	b - light grey<br>	c - orange<br>	d - light blue<br>	e - light green<br>	f - brown</pre>
<pre>	: [Paper], [border] and [cursor] are 12 bit $RGB values</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="D_-_Disassemble"></a>D</span> - Disassemble Z80 code</pre>
<pre>	Use: D <span style="font-style: italic;">start_address end_address</span></pre>
<pre>	Note: To aid debugging, it is possible to cursor up to a line of code, edit the hex bytes and<br>	press enter to update the disassembly listing. (You cannot edit the mnemonics, however).</pre>
<pre><br></pre>
<pre><br></pre>
<pre><span style="font-weight: bold;"><a name="DEL-_Delete_File"></a>DEL</span>- Delete File</pre>
<pre>	Use:&nbsp;&nbsp; &nbsp;DEL <span style="font-style: italic;">filename</span> (name must be a file, not a dir)</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="DIR_-_Show_Directory"></a>DIR</span> - Show Directory Listing</pre>
<pre>	Use:&nbsp;&nbsp; &nbsp;DIR (no args)</pre>
<pre><br></pre>
<pre><br><br><span style="font-weight: bold;"><a name="EXEC_-_Execute"></a>EXEC</span> - Execute a script </pre>
<pre>	Use: EXEC <span style="font-style: italic;">filename</span> (note: scripts cannot execute further scripts)</pre>
<pre><br><br><br><br><span style="font-weight: bold;"><a name="F_-_Fill"></a>F</span>&nbsp; - Fill Memory</pre>
<pre>	Use: &nbsp;&nbsp; &nbsp;F <span style="font-style: italic;">start_address end_address fill_byt</span>e</pre>
<pre><br><br><br><br><span style="font-weight: bold;"><a name="FORMAT"></a>FORMAT</span> - Formats *entire disk* for FAT16 (no partition table)</pre>
<pre>	Use:&nbsp;&nbsp; &nbsp;FORMAT <span style="font-style: italic;">device_name</span> (EG: SD_CARD)</pre>
<pre><br><br><br></pre>
<pre><br><span style="font-weight: bold;"><a name="G_-_Goto"></a>G</span> - Goto location (IE: Call Z80 routine)</pre>
<pre>	Use: G <span style="font-style: italic;">address </span></pre>
<pre>	Notes: "G 0" resets the Z80</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; HL will be equal to the first non-space character after the address.</pre>
<pre><br><br><br>&nbsp;&nbsp; &nbsp;</pre>
<pre><span style="font-weight: bold;"><a name="H_-_Hunt"></a>H</span> - Hunt in memory for hex bytes or text (not case sensitive)</pre>
<pre>	Use:&nbsp;&nbsp; &nbsp; H <span style="font-style: italic;">start_address end_address byte1 [byte2 byte3 etc]</span><br><br>	H <span style="font-style: italic;">start_address end_address &#8220;string&#8221;</span></pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="LB_-_Loads_bytes"></a>LB</span> - Loads bytes to RAM from currently selected drive</pre>
<pre>	Use: &nbsp;&nbsp; LB <span style="font-style: italic;">filename address [bank]</span></pre>
<pre>	Notes: No path is allowed in the filename.</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; If no bank is specified, the current bank is used (only when <span style="font-style: italic;">address</span> is &gt; $7FFF)<br><br>	If <span style="font-style: italic;">address</span> is &lt; $8000, any data loading beyond $7FFF will load into bank 0<br><br>	If the load address counter goes beyond address $FFFF, bytes are loaded into the next<br>	bank (and the address wraps around to $8000). This does not affect the current bank<br>	as selected by the B command.<br>	<br><br></pre>
<pre><br><br><span style="font-weight: bold;"><a name="M_-_Show_memory"></a>M</span> - Show memory as hex bytes</pre>
<pre>        Use: M <span style="font-style: italic;">address</span><br><br>        Note: You can edit the displayed data and press return to update it in memory as the string<br>	      is displayed with the : prefix</pre>
<pre><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="MD_-_Make_new_dir"></a>MD</span> - Make new directory</pre>
<pre>	Use:&nbsp;&nbsp; &nbsp;MD <span style="font-style: italic;">new_subdir</span><br><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="MOUNT_-_Rescans"></a>MOUNT</span> - Rescans for connected drives<br><br>	Use:&nbsp;&nbsp; &nbsp;MOUNT (no args)<br><br>	Note: Deletes all environment variables except %EX0</pre>
<pre><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="R_-_Show_reg"></a>R</span> - Show registers (Updated on exit from external programs or NMI exception.)</pre>
<pre>	Use: &nbsp;&nbsp; &nbsp;R (no args)</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="RD_-_Remove_dir"></a>RD</span> - Remove directory<br><br>	Use:&nbsp;&nbsp; &nbsp;RD <span style="font-style: italic;">subdir</span> (name must be a dir, not a file)</pre>
<pre><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="RX_-_Receive"></a>RX</span> -&nbsp; Receive data from serial comms port (place it in RAM) and optionally execute it as code. <br><br>        Use: &nbsp;&nbsp; RX<span style="font-style: italic;"> filename address [bank]&nbsp; &nbsp;</span></pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Notes: If <span style="font-style: italic;">filename</span> is "*" whatever file is sent is accepted.</pre>
<pre>        If <span style="font-style: italic;">filename</span> is "!", the file is downloaded and immediately run (no other arguments<br>        are used. If the file being downloaded has a FLOS location header, it is loaded to<br>        the address and bank specified in the header (any truncation info in the header is <br>        ignored) otherwise it is loaded to $5000. HL will be set to the first non-space<br>        character after the &#8220;!&#8221;)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  If no bank is specified, the current bank is used (only when <span style="font-style: italic;">address</span> is &gt; $7FFF)<br><br>        If <span style="font-style: italic;">address</span> is &lt; $8000, any data loading beyond $7FFF will load into bank 0<br><br>        If the load address counter goes beyond address $FFFF, bytes are loaded into the next<br>        bank (and the address wraps around to $8000). This does not affect the current bank<br>        as selected by the B command.<br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="SB_-_Save_bytes"></a>SB</span> - Save bytes from RAM to currently selected drive</pre>
<pre>	Use: SB <span style="font-style: italic;">filename address length [bank] &nbsp;</span></pre>
<pre>	Notes: No path is allowed in the filename <br><br>	When address &lt; $8000 any data eventually sourced from the paged memory area will be<br>	taken from bank 0 first.<br><br>	If no bank is specified, the current bank is used (but only when <span style="font-style: italic;">address</span> is &gt; $7FFF)&nbsp;<br><br>	When the length + address extends beyond address $FFFF, bytes are fetched from the<br>	next bank (ie: the address wraps around to $8000 and the bank number increases. This<br>	does not affect the currently selected bank as set with the B command.</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="T_-_Show_mem"></a>T</span> - Show memory as ASCII text</pre>
<pre>	Use: &nbsp;&nbsp; &nbsp;T <span style="font-style: italic;">address</span></pre>
<pre>	Note: you can edit the displayed data and press return to update it in memory as the string<br>	is displayed with the &gt; prefix</pre>
<pre><br><br><br><br><br><br><span style="font-weight: bold;"><a name="TX_-_Transmit"></a>TX</span> - Transmit bytes from RAM to serial comms port (using Serial Link app)</pre>
<pre>	Use: &nbsp;&nbsp;&nbsp;TX <span style="font-style: italic;">filename address length [bank]</span></pre>
<pre>	Notes: When address &lt; $8000 any data eventually sourced from the paged memory area will be<br>	taken from bank 0 first.<br><br>	If no bank is specified, the current bank is used (but only when <span style="font-style: italic;">address</span> is &gt; $7FFF)&nbsp;<br><br>	When the length + address extends beyond address $FFFF, bytes are fetched from the<br>	next bank (ie: the address wraps around to $8000 and the bank number increases. This<br>	does not affect the currently selected bank as set with the B command.<br> <br><br><br>&nbsp;&nbsp; &nbsp;<br></pre>
<pre><span style="font-weight: bold;"><a name="VERS"></a>VERS</span> - Shows the OS and Hardware version numbers<br><br>	Use: VERS (no args)</pre>
<pre><br><br><br><br><br><a name="VOLx:"></a><span style="font-weight: bold;">VOLx:</span> - Switches to another volume (goes to the directory that was last active on that volume)<br><br>	Use: VOL0: VOL1: VOL2: etc<br><br>&nbsp;<br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="_-_Put_text"></a>&gt;</span>&nbsp; - Put text in memory<br><br>	Use: &nbsp;&nbsp; &nbsp;T <span style="font-style: italic;">address "text"</span></pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name=":_-_Put_hex"></a>:</span>&nbsp; - Put hex bytes in memory</pre>
<pre>	Use: &nbsp;&nbsp; <span style="font-style: italic;">&nbsp;address byte1 [byte2 etc]</span></pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="_-_List"></a>?</span> - List internal commands</pre>
<pre>	Use: &nbsp;&nbsp; &nbsp;? (no args)</pre>
<pre><br></pre>
<pre><br><br><span style="font-weight: bold;"><a name="_-_Put_hex"></a>&lt;</span> - Put hex bytes in memory and disassemble</pre>
<pre>	Use: &lt; <span style="font-style: italic;">address hexbytes</span></pre>
<pre><br><br><br><br><span style="text-decoration: underline;">External Commands (created by Phil Ruston)</span></pre>
<pre>(These are located in the Commands directory and load high in memory - usually Bank $0E, address $F000)<br><br></pre>
<pre><span style="font-weight: bold;"><a name="ASSIGN.EXE"></a>ASSIGN.EXE</span>&nbsp; - Assigns a directory to an environment variable</pre>
<pre>	Use: ASSIGN <span style="font-style: italic;">xyz [path]</span></pre>
<pre>	'xyz' is the name of the path "proxy" which will have a "%" prefix.<br><br>	If the path is omitted then the current folder is assigned.</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="BAUD.EXE"></a>BAUD.EXE</span> - Sets the BAUD rate used in FLOS</pre>
<pre>	Use: BAUD <span style="font-style: italic;">speed</span></pre>
<pre>	'Speed' is 115200 or 57600 (default Baud rate is 115200)</pre>
<pre><br><br><br></pre>
<pre><span style="font-weight: bold;"><br><a name="BOOT.EXE"></a>BOOT.EXE -</span> Reconfigure the FPGA from the specified slot<br><br>	Use: Boot n<br><br>	Where n is the slot to boot from<br><span style="font-weight: bold;"><br><br><br><br><br><a name="CHFNT.EXE"></a>CHFNT.EXE</span> - Changes the OS font</pre>
<pre>	Use: CHFNT <span style="font-style: italic;">fontfile [xx]</span></pre>
<pre>	CHFNT looks in the current directory and then in the root/fonts directory for the font file.</pre>
<pre>	<br>	FONT FILE DESCRIPTION:</pre>
<pre>	Two types of font files are supported - both use raw bitmap data but are formatted differently.<br>	The original (.fnt) files hold 96 character definitions (for ASCII codes 32 to 127) and are<br>	stored in a raster-like format: 96 bytes wide * 8 lines high</pre>
<pre>	FLOS 6.02+ supports all 256 ASCII characters, so the font file can be 1 to 256 characters long.<br>	The new FLOS font files (.fff) are formatted in the linear &#8220;8-bytes-per-character-defintion&#8221;<br>	grouped style. When an .fff file is specified, the first character image to be overwritten<br>	can be set by adding a hex value to the end of the command line. This allows, for example,<br>	the extended ASCII char images (128-255) to be patched onto the current font. (If no value<br>	is supplied, patching starts at ASCII char $00)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre><br></pre>
<pre><span style="font-weight: bold;"><br><br><br><a name="CMP.EXE"></a>CMP.EXE</span> - Compares two areas of system RAM and shows differences</pre>
<pre>	Use: CMP <span style="font-style: italic;">[#] start_address end_address target_address [bank]</span></pre>
<pre>	If # is included, the operation is carried out silently (apart from FLOS error messages<br>	such as incorrect syntax)</pre>
<pre>	The source bank is always that currently seleced by FLOS, the target bank is the same as<br>	the source bank unless specified.</pre>
<pre><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="ECHO.EXE"></a>ECHO.EXE</span> - Displays a line of text<br><br>	Use: ECHO some text to display<br><br><br><br><br><br><span style="font-weight: bold;"><br><br><a name="FILEINFO.EXE"></a>FILEINFO.EXE</span> - Shows file length / load address, sets the Envar &#8220;FSIZ&#8221;<br><br>	Use: FILEINFO <span style="font-style: italic;">(#) filename</span></pre>
<pre>	If # is included, the operation is carried out silently (any FLOS error message is also muted to $80)</pre>
<pre>	A load and bank address is only shown if the file is a program with the location header.</pre>
<pre><br><br><span style="font-weight: bold;"><br><br><br><a name="FILECMP.EXE"></a>FILECMP.EXE</span> - Compares two files and shows any differences.</pre>
<pre>	Use: <span style="font-style: italic;">FILECMP [#] FILENAME_1 FILENAME_2</span></pre>
<pre>	If # is included, the operation is carried out silently (apart from FLOS error messages such as<br>	incorrect syntax)</pre>
<pre>	If the files are not the same size the comparison runs to the end of the shortest file.</pre>
<pre>	If any bytes are different, the "ERR" envar is set to $80.</pre>
<pre>	If the filesizes are different but the bytes up to the end of the shortest are the same, "ERR" is set to $81.</pre>
<pre><br></pre>
<pre><br><span style="font-weight: bold;"><br><br><a name="FILERX.EXE"></a>FILERX.EXE</span> - Receives files over Serial Link and saves them to the current dir.<br><br>	Use: FILERX (no args)</pre>
<pre><br><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="FILETX.EXE"></a>FILETX.EXE</span> - Sends a file from the current dir (to PC) over Serial Link</pre>
<pre>	Use: FILETX <span style="font-style: italic;">filename</span><br><br></pre>
<pre><br><br><br><br><span style="font-weight: bold;"><a name="GOTO.EXE"></a>GOTO.EXE</span> - Causes a jump within scripts (IE: sets the GOTO envar)</pre>
<pre>	Use: GOTO <span style="font-style: italic;">label</span></pre>
<pre>	Where <span style="font-style: italic;">&#8216;label&#8217;</span> is a 4 character ASCII label within a script.</pre>
<pre>	This command is essentially the same as: &#8220;SET GOTO label&#8221;</pre>
<pre><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="HELP.EXE"></a>HELP.EXE</span> - Shows the help file for a particular command<br><br>	Use: HELP command<br><br><br><br><br><br><br><span style="font-weight: bold;"><a name="IF.EXE"></a>IF.EXE</span> - Main script control function.</pre>
<pre>	Use: IF <span style="font-style: italic;">xxxx cond yyyy </span>GOTO<span style="font-style: italic;"> zzzz</span><br><br>	Where <span style="font-style: italic;">xxxx</span> is the name of an Envar cond is "=" or &#8220;&lt;&gt;&#8221; for maths/strings or "&lt;" or "&gt;" for maths only. </pre>
<pre>	<span style="font-style: italic;">yyyy </span>= is a hex number, another Envar name if enclosed in brackets or a literal string if enclosed in quotes.</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="font-style: italic;">zzzz</span> = a 4 character (max) label</pre>
<pre>	EG:-<br>	IF ERR &gt; 0 GOTO FAIL<br>	IF STR = &#8220;THIS&#8221; GOTO THAT<br>	IF NUM1 &lt; (NUM2) GOTO LESS</pre>
<pre>	(Remember: Envars names/values and labels are 4 characters max)</pre>
<pre><br></pre>
<pre><br><br><a name="INPUTNUM.EXE"></a><br><span style="font-weight: bold;">INPUTNUM.EXE</span> - Get user input (hex number) and apply to an environment variable.</pre>
<pre>               Use: INPUTNUM <span style="font-style: italic;">envar</span></pre>
<pre><br><br></pre>
<pre><br></pre>
<pre><span style="font-weight: bold;"><a name="INPUTSTR.EXE"></a>INPUTSTR.EXE</span> - Get user input (4 chars max string) and apply to an environment variable.</pre>
<pre>               Use: INPUTSTR <span style="font-style: italic;">envar</span></pre>
<pre><br><br></pre>
<pre><br></pre>
<pre><span style="font-weight: bold;"><a name="KEYMAP.EXE"></a>KEYMAP.EXE</span> - Change the keymap</pre>
<pre>	Use: KEYMAP <span style="font-style: italic;">keymap_file</span></pre>
<pre>	Keymap looks in the current directory and then in the root/keymaps directory for the keymap file.<br>	The current keymap list is</pre>
<pre>	UK.bin - UK (default)<br>	US.bin - USA<br>	DE.bin - Germany<br>	IT.bin - Italy<br>	PT.bin - Portugal</pre>
<pre><br>	KEYMAP FILE DESCRIPTION:</pre>
<pre>	Keymap files are "PS/2 set 2" scancode-to-ASCII translation tables.<br>	They can contain two or three "banks" of the translation table: one<br>	for unshifted keys, one for shifted keys and optionally one for<br>	Alt-modified keys. Each bank is 98 bytes long, covering scancodes $00-$61</pre>
<pre><br><br><br><br><br><span style="font-weight: bold;"><a name="LCD.EXE"></a>LCD.EXE</span> - Disassembles a Linecop program<br><br>          Use: LCD linecop_address<br><br>           Notes: "linecop_address" is in the range 0-FFFE and refers to the LineCop accessible area of<br>           system RAM from $70000-$7ffff. (The least significant bit is ignored)<br><br><br><br><br><br><a name="LOADSPR.EXE"></a><br style="font-weight: bold;"><span style="font-weight: bold;">LOADSPR.EXE</span> - Loads a file to Sprite RAM<br><br>	Use: LOADSPR <span style="font-style: italic;">filename address</span><br><br>	Notes: address is flat sprite memory location between 0-1FFFF<br><br><br><br><br><br><br style="font-weight: bold;"><span style="font-weight: bold;"><a name="LOADVRAM.EXE"></a>LOADVRAM.EXE</span> - Loads a file to Video RAM<br><br>	Use: LOADVRAM <span style="font-style: italic;">filename address</span></pre>
<pre>	Notes: <span style="font-style: italic;">address</span> is a flat video memory location between 0-7FFFF</pre>
<pre><br><br><br><br><br><span style="font-weight: bold;"><a name="MONO.EXE"></a>MONO.EXE</span> - Direct all 4 sound channels to both left and right speakers<br><br>	Use: MONO<br><br><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="MOUSE.EXE"></a>MOUSE.EXE</span> - Activate the mouse driver</pre>
<pre>	Use: MOUSE (no parameters)</pre>
<pre>	Notes: The mouse command initializes the mouse driver. If a mouse is detected it calls the<br>	kernal routine "kjt_enable_mouse".</pre>
<pre><br><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="SAVEVRAM.EXE"></a>SAVEVRAM.EXE</span> - Saves data from Video RAM to a file</pre>
<pre>	Use: SAVEVRAM <span style="font-style: italic;">filename address length</span></pre>
<pre>	Notes: <span style="font-style: italic;">address</span> is flat video memory location between 0-7FFFF</pre>
<pre><br><br><br><br><br></pre>
<pre><span style="font-weight: bold;"><a name="SET.EXE"></a>SET.EXE</span> - Sets / deletes / adjusts environment variables</pre>
<pre>	Use: SET <span style="font-style: italic;">abcd (=) value</span></pre>
<pre>	Where: <span style="font-style: italic;">abcd</span> is the 4 character ascii name for the envar.<br><br>	&#8220;=&#8221; can be omitted if desired.</pre>
<pre>	<span style="font-style: italic;">Value </span>is either:</pre>
<pre>	A 32 bit max hex value string EG: 1234AAFF<br>	A 4 character (max) string in quotes EG: &#8220;BEEP&#8221;<br>	Another envar name in round brackets. EG: (NAME)<br>	+ To increment the value of the envar <br>	- To decrement the value of the envar<br>	# To delete the envar if it exists.</pre>
<pre>	If no arguments are given, the current environment variables are listed.</pre>
<pre>	EG: SET HATS = &#8220;CATS&#8221;<br>	SET BEAN = 12345678<br>	SET BEAN -<br>	SET BEAN +<br>	SET HATS #<br>	SET BLAH = (HATS)</pre>
<pre><br><br><br><br><br><span style="font-weight: bold;"><a name="STEREO.EXE"></a>STEREO.EXE</span> - Directs sound channels 0+2 to left speaker, and 1+3 to right speaker<br><br>         Use: STEREO<br><br><br><br><br><br><span style="font-weight: bold;"><a name="TYPE.EXE"></a>TYPE.EXE</span> - Shows the contents of a text file<br><br>         Use: TYPE filename<br><br><br><br><br><br><span style="font-weight: bold;"><a name="VGA50.EXE"></a>VGA50.EXE</span> - Sets VGA Mode to non-standard 50Hz<br><br>        Use: VGA50<br><br><br><br><br><br><span style="font-weight: bold;"><a name="VGA60.EXE"></a>VGA60.EXE</span> - Sets VGA Mode to Standard 60Hz<br><br>        Use: VGA60<br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="text-decoration: underline; font-weight: bold;">FLOS return messages</span></pre>
<pre><br>When a program returns to FLOS with a value in A other than zero, (and the zero flag is not set)<br>one of the following messages will be displayed:</pre>
<pre>$01 - Volume Full<br>$02 - File Not Found<br>$03 - Dir Full<br>$04 - Not A Dir <br>$05 - Dir Is Not Empty<br>$06 - Not A File<br>$07 - File Length Is Zero<br>$08 - Address out of Range<br>$09 - Filename Already Exists<br>$0a - Already at root<br>$0b - Unknown command<br>$0c - Invalid Hex<br>$0d - No filename<br>$0e - Invalid Volume<br>$0f - Checksum bad<br>$10 - [Space] Bytes Loaded<br>$11 - Comms error<br>$12 - Bad arguments<br>$13 - Not FAT16<br>$14 - Serial time out<br>$15 - Filename too long <br>$16 - No start address<br>$17 - No file length<br>$18 - Save aborted<br>$19 - Save error at destination<br>$1a - Bank ** selected<br>$1b - Data after EOF request<br>$1c - No end address<br>$1d - No destination address<br>$1e - Bad range<br>$1f - Missing arguments<br>$20 - OK<br>$21 - Invalid bank<br>$22 - Device not present<br>$23 - Dir not found<br>$24 - End of Dir<br>$25 - Filename mismatch<br>$26 - OS RAM protected)<br>$27 - "?" <br>$28 - No Volumes<br>$29 - None Found<br>$2a - Receive Aborted<br>$2b - Envar not found<br>$2c - Envar file full<br>$2d - Aborted<br>$2e - No MBR&nbsp;&nbsp; &nbsp;</pre>
<pre>$80-$f0 = Silent, unspecified errors (No text is shown by FLOS, but "ERR" envar is set to the value in A)</pre>
<pre>Note: Please refer to the individual Kernal Call documentation for the exact error codes those routines return.<br> <br> </pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="text-decoration: underline;">MISC:</span><br><br><a name="Format_of_header"></a>Format of header for .OSF files:<br><br>$00 - $07 : ASCII Characters: Z80P*OS*<br>$08 - $0B : Length of file (excluding header)<br>$0C - $0D : CRC checksum of file<br>$0E - $0F : Not currently used &#8211; set to $0000</pre>
<pre>(A Windows utility is provided to attach this header onto a raw OS file. See the project folder<br>&#8220;PC_based_apps/&#8221; - PureBasic source code also supplied.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>FLOS INTERNALS:</h3>
<pre><br><span style="text-decoration: underline;">Volume Mount List</span><br><br>The address of this table is returned in HL by the KJT routine "kjt_get_volume_info"<br>Each volume entry is 16 bytes long and contains the following data:<br><br>OFFSET DATA<br>------ ----<br> $00 - 1 = Volume is present, else zero (note: this does not mean it is a valid FAT16 volume.)<br> $01 - Volume's host driver number <br> $02 - [reserved]<br> $03 - [reserved]<br> $04 - Volume's total capacity in sectors (3 bytes)<br> $07 - Partition number on host drive (0/1/2/3)<br> $08 - Offset in sectors from MBR to partition boot sector (2 words, little endian)<br> $0c - [reserved]<br> $0d - [reserved] <br> $0e - [reserved]<br> $0f - [reserved]<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="text-decoration: underline;">Host Device Hardware Info</span><br><br>The address of this table is returned in HL by the KJT routine"kjt_get_device_info"<br>Each device entry is 32 bytes long and contains the following data:<br><br>OFFSET DATA<br>------ ----<br> $00 - Device driver number<br> $01 - Device's TOTAL capacity in sectors (4 bytes)<br> $05 - Zero terminated hardware name (22 ASCII bytes max followed by $00)<br> (remaining bytes to $1F currently unused)<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="text-decoration: underline;">Driver Table</span><br><br>The address of this table is returned in DE by the KJT routine "kjt_get_device_info"<br>Each driver entry is the absolute address of the driver in memory. There are 4<br>driver slots available, if an entry is zero, the slot is free for use (a user program<br>can place an address there, and remount drives to update the device and volume<br>tables).<br><br>$00 - Driver 0 address (normally the SD card driver on V6Z80P)<br>$02 - Driver 1 address<br>$04 - Driver 2 address<br>$06 - Driver 3 address<br><br><br>Each FLOS device driver has the following structure:<br><br>$00-$07 : 7 ASCII bytes, name of driver EG: "SD_CARD"<br>$07 : Zero<br>$08 : Z80 code: JP read_sector routine<br>$0B : Z80 code: JP write_sector routine<br>$0E : "get_id" routine starts here.<br><br>The three routines should return with the Zero Flag set if the operation was a success.<br>Otherwise, if an error was encountered a hardware error code can be placed in A.<br>The "get_id" (initialization) routine should additionally return with BC:DE set<br>to the total capacity of the device in sectors, and HL set to the location of a<br>zero-terminated hardware ID ASCII string (this string is used for reference only).<br><br>Driver routines should use these standard labels (used throughout FLOS):<br><br> "sector_buffer" - 512 bytes<br><br> "sector_lba0" - LBA of desired sector LSB<br> "sector_lba1" <br> "sector_lba2"<br> "sector_lba3" - LBA of desired sector MSB<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br></pre>
<pre>[END]</pre>
<pre><br>(*Kernal is &#8220;misspelled&#8221; throughout as a nod to the C64:)<br></pre>
</body></html>