<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>OSCA_Hardware_Manual</title>

<style type="text/css">
<!--
A:link {text-decoration: none}
A:active {text-decoration: none}
A:vlink {text-decoration: none}
A:visited {text-decoration: none}
A:hover {color: #00ffff}
-->
</style></head>
<body>
<h1 style="text-decoration: underline;">OSCA - An FPGA
Config For The V6Z80P</h1>
<pre style="font-style: italic;">By Phil Ruston 2008-2012 - Last updated 29-09-2012 (OSCA v672)</pre>
<pre><br>OSCA (Old School Computer Architecture) provides a home-computer era hardware platform for<br>the V6Z80P. As well as basic memory and peripheral control, its features include bitmap and<br>character mapped displays, sprites, a raster line synchronized co-pro ("LineCop"), blitter,<br>hardware line draw and four channels of 8 bit digital sound.<br>  <br><span style="font-weight: bold;">Quick Links:</span></pre>

<ul>
<li><a href="#Port_List:">Port Index</a></li>
<li><a href="#Video_Register_List:">Video Register
Index</a></li>
<li><a href="#The_Video_System:">Video System</a></li>
<li><a href="#Sprites:">Sprite System</a></li>
<li><a href="#Sound_System_Detail:">Audio System</a></li>
<li><a href="#Blitter:">Blitter</a></li>
<li><a href="#LineCop">LineCop</a></li>
<li><a href="#Maths_Assist">Maths Assist</a></li>
<li><a href="#OSCAs_ROM">OSCA ROM</a><br>
</li>
</ul>
<pre style="text-decoration: underline;"><br>Hardware Control:</pre>
<pre>In OSCA, memory and peripheral controls are accessed via the Z80's In/Out Ports. Video<br>settings such as the palette, display controls, sprite registers etc are accessed via<br>locations in Z80 address space (these can be paged in and out as desired). Sections of<br>Z80 address space are also assigned to video RAM etc.<br></pre>
<pre style="text-decoration: underline;"><br>Z80 Address Space Overview:</pre>
<pre>As the V6Z80P has 512KB of system RAM (and the Z80 can only see 64KB at a time), OSCA<br>allows the user to select the sections of System RAM that appear in Z80 address space.<br>The page size is 32KB and both the lower and upper halves of the Z80 address space can<br>be assigned different pages of system RAM. In addition, the upper memory area can direct<br>CPU writes to an alternative page, making data copying quicker and easier.</pre>
<pre>Depending on the memory control settings, certain sections of Z80 address space<br>will - instead of system RAM - access components such as video/sprite memory, the video<br>palette etc. <br>  <br>  <br><span style="text-decoration: underline;">Diagram of Z80 Address space options under OSCA (not to scale):</span></pre>
<pre><img style="width: 798px; height: 997px;" alt="Memory Map Diagram" src="images/memory_map.png"><br><br><span style="text-decoration: underline;"><br>Z80 Address Space 'Partitions':</span><br><br>$0000-$07FF: First 2KB section of the lower 32KB System RAM Page. Or ROM, Palette, Video Registers,<br> Sprite Control Registers and Maths Table (this is the default mode)</pre>
<pre>$0800-$0FFF: The next 2KB Section of the lower 32KB System RAM page (Note: OSCA's default ROM code<br> stipulates that IRQ Mode 1 vector jumps to $A00, and NMI vector jumps to $A03)<br><br>$1000-$1FFF: The next 4KB Section of the lower 32KB System RAM page or a write-only 4KB page of<br> sprite definition RAM (note: Reads between $1000-$1fff always fetch data<br> from System RAM).</pre>
<pre>$2000-$3FFF: Next 8KB section of the lower 32KB system RAM page (or the default location<br> of the video RAM access window.)<br><br>$4000-$7fff: The remaining 16KB Section of the lower 32KB System RAM page</pre>
<pre>$8000-$FFFF: The Upper 32KB System RAM page</pre>
<pre><br><span style="font-weight: bold;"></span><span style="text-decoration: underline;"><br>Paged RAM areas in Detail:</span></pre>
<pre><span style="font-weight: bold;">System Memory:</span> The System RAM chip is 512KB. OSCA allows separate 32KB pages of<br>this memory to appear at Z80 $0000-$7fff and $8000-$ffff. The 32KB chunk of system RAM<br>that appears to the Z80 at $0000-$7FFF is set with the port "<a href="#Port_20">sys_low_page</a>" and the 32KB<br>of system RAM that appears to the Z80 at $8000-$FFFF is set with the port "<a href="#Port:_00">sys_mem_select</a>".<br>If required, WRITES between $8000-$FFFF can access a different page to that of READS <br>in the same range - the write page is set with port "<a href="#Port_0B">sys_alt_write_page</a>", and this feature<br>is enabled with bit 4 of "<a href="#Port:_00">sys_mem_select</a>".</pre>
<pre><br><span style="font-weight: bold;">Writing</span> to Z80 address space between $0000 - $07FF:</pre>
<pre>&nbsp;$0000 - $01FF: Write only Video Colour Palette or 512 bytes of system RAM*<br>&nbsp;$0200 - $03FF: Write only Video Control Registers or 512 bytes of system RAM* <br>&nbsp;$0400 - $05FF: Write only Sprite Control Registers or 512 bytes of system RAM*<br>&nbsp;$0600 - $07FF: Write only Maths Table or 512 bytes of system RAM*</pre>
<pre><br><span style="font-weight: bold;">Reading</span> from Z80 address space between $0000 - $07FF:</pre>
<pre>&nbsp;$000 - $1FF: 512 byte boot ROM (contained in the FPGA) or 512 bytes of system RAM*<br>&nbsp;$200 - $6FF: 1280 Bytes of System RAM<br>&nbsp;$700 - $7FF: Video Status Register and Maths unit result or 256 bytes of system RAM*</pre>
<pre>* Bits in the port &#8220;<a href="#Port_0B">sys_alt_write_page</a>&#8221; control whether the ROM and hardware registers<br>&nbsp; or system RAM appears in locations $0000-$07ff. The default scheme (IE: when the<br>&nbsp; port sys_alt_write_page is clear) is:<br><br>&nbsp;&nbsp; $000-$1ff: Write palette but read from ROM<br>&nbsp;&nbsp; $200-$6ff: Write video registers but read from System RAM<br>&nbsp;&nbsp; $700-$7ff: Write video registers but read only the video status register and maths result.</pre>
<pre><br><br><span style="font-weight: bold;">Video Memory:</span> Video memory is a seperate 512KB RAM chip. It is normally accessed by the<br>CPU through an 8KB window in Z80 address space. The window is located at $2000 by default but<br>can also be at $4000, $6000, $8000, $A000, $C000 or $E000. The location of this window is set <br>with the port "<a href="#Port_21_-_Write">sys_vram_location</a>" and the 8KB section of Video RAM that the window 'contains' is<br>selected by writing to the video register "<a href="#206">vreg_vidpage</a>" with bit 7 clear. To access video RAM<br>at the location specified (instead of normal System RAM), video RAM must be paged in by setting<br>bit 6 of the port "<a href="OSCA_Hardware_Manual.html#Port:_00">sys_mem_select</a>".<br></pre>
<pre><span style="font-weight: bold;"> Direct Video Write Mode</span>: (see bit 5 of "<a href="#Port:_00">sys_mem_select</a>"). This settings allows a 64KB page of<br> video RAM to occupy the entire Z80 address space. This mode overrides all other paging options<br> and forces memory <span style="font-weight: bold;">WRITES</span> from the CPU to video RAM at the page selected with bits [5:3] of<br> &#8220;<a href="#206">vreg_vidpage</a>&#8221;). The CPU still reads data from ordinary system RAM (so that program code is always<br> accessible). Because devoting the entire 64KB of Z80 address space to video RAM severely limits the<br> CPU (calls, stack ops, IRQs, system variables etc are not possible) there is the option of excluding<br> the first 4KB of Z80 address space from Direct Video Write Mode (set bit 6 of "<a href="#Port:_00">sys_mem_select</a>"<br> as well as bit 5) - this allows access to the video registers and 2KB of system RAM at the<br> cost of losing access to the first 4KB of each 64KB video page.</pre>
<pre><br><br><span style="font-weight: bold;">Sprite Memory:</span> Sprite RAM is another seperate RAM chip, this time 128KB in size. It is accessible to<br>the CPU via a 4KB window at $1000-$1FFF. To enable this window, set bit 7 of "<a href="#Port:_00">sys_mem_select</a>". Note<br>that in OSCA, sprite RAM is <span style="font-weight: bold;">write only</span> and reading from $1000-$1fff always returns values from system RAM.<br>The 4KB page of sprite RAM that is visible to the CPU is selected by writing to the video register<br>"<a href="#206">vreg_vidpage</a>" with bit 7 set.<br><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><span style="text-decoration: underline;">IO
Ports:</span></h3>
<pre>$00-$2F: System Control / Peripheral / Audio Ports:</pre>
<pre>These port locations are mainly both readable and writeable. However, the read (IN) functions<br>can differ from the write (OUT) functions &#8211; see the individual port descriptions for details.<br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><a name="Port:_00"></a>Port: $00 - Read / Write: <span style="font-weight: bold;">"sys_mem_select</span>"</pre>
<pre>Bit 0:3 - Upper 32KB memory page select (see table below)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 - Use alternate page for upper memory writes **<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 - Set Direct Video Write Mode (All Z80 address space memory writes go to VRAM).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 - Page in Video RAM at selected location (In DVW Mode: 1 = exclude $0000-$0FFF).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 - Page Sprite RAM in at $1000-$1FFF for writes (Ignored in DVW Mode)</pre>
<pre>&nbsp;</pre>
<pre>System RAM Upper Page Selection Table:</pre>
<pre><span style="text-decoration: underline;">Bits:&nbsp;3 2 1 0&nbsp;&nbsp;|&nbsp;Area of System RAM paged into Z80 $8000-$FFFF</span><br><br>     0 0 0 0&nbsp; =&nbsp;$08000 - $0FFFF #<br>     0 0 0 1&nbsp; =&nbsp;$08000 - $0FFFF #<br>     0 0 1 0&nbsp; =&nbsp;$10000 - $17FFF<br>     0 0 1 1&nbsp; =&nbsp;$18000 - $1FFFF<br>     0 1 0 0&nbsp; =&nbsp;$20000 - $27FFF <br>     0 1 0 1&nbsp; =&nbsp;$28000 - $2FFFF <br>     0 1 1 0&nbsp; =&nbsp;$30000 - $37FFF <br>     0 1 1 1&nbsp; =&nbsp;$38000 - $3FFFF <br>     1 0 0 0&nbsp; =&nbsp;$40000 - $47FFF <br>     1 0 0 1&nbsp; =&nbsp;$48000 - $4FFFF <br>     1 0 1 0&nbsp; =&nbsp;$50000 - $57FFF<br>     1 0 1 1&nbsp; =&nbsp;$58000 - $5FFFF<br>     1 1 0 0&nbsp; =&nbsp;$60000 - $67FFF <br>     1 1 0 1&nbsp; =&nbsp;$68000 - $6FFFF<br>     1 1 1 0&nbsp; =&nbsp;$70000 - $77FFF / LineCop program area address $0000-$7fff*<br>     1 1 1 1&nbsp; =&nbsp;$78000 - $7FFFF / LineCop program area address $8000-$ffff*</pre>
<pre><br>Notes: </pre>
<pre># Notice 0000 and 0001 both select SYS_RAM $08000-$0FFFF at Z80: $8000-$FFFF. This prevents<br> system RAM locations $00000-$07FFF being paged into the upper memory area. However, it is<br> possible to override this prohibition by setting the &#8220;Any Page Mode&#8221; bit (bit 5 of port<br> &#8220;<a href="#Port_0B">sys_alt_write_page</a>&#8221;) - selection 0000 will then select SYS_RAM $00000-$07FFF at Z80<br> $8000-$FFFF</pre>
<pre>* The System RAM area where Linecop programs need to be placed are normal memory<br> locations as far as the CPU is concerned, IE: they are not dedicated to the Linecop. </pre>
<pre>** When bit 4 (Alternate Write Page) is set, the UPPER 32KB page selection DURING<br> CPU WRITES is taken from Port $0B (<a href="#Port_0B">sys_alt_write_page</a>).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><a name="Port:_01_-_Read"></a>Port: $01 - Read: "<span style="font-weight: bold;">sys_irq_ps2_flags</span>" - Interrupt status flags and PS2 port line status: </pre>
<pre>Bit: 0 - Keyboard IRQ flag (1 = interrupt occurred)<br> &nbsp;&nbsp;&nbsp; 1 - Mouse IRQ flag ("")<br> &nbsp;&nbsp;&nbsp; 2 - Timer IRQ flag ("")<br> &nbsp;&nbsp;&nbsp; 3 - Video IRQ flag ("")<br> &nbsp;&nbsp;&nbsp; 4 - Keyboard Clock line status (input)<br> &nbsp;&nbsp;&nbsp; 5 - Keyboard Data line status (input)<br> &nbsp;&nbsp;&nbsp; 6 - Mouse Clock status (input)<br> &nbsp;&nbsp;&nbsp; 7 - Mouse Data status (input)<br><br></pre>
<pre><a name="Port_01_-_Write"></a>Port $01 - Write: "<span style="font-weight: bold;">sys_irq_enable</span>"</pre>
<pre>Interrupt masks: Allow devices to interrupt CPU. (Note: The video IRQ enable bit is<br>in the video register <a href="#204">vreg_rasthi</a>)</pre>
<pre>Bit: 0 - Keyboard IRQ enable (1 = allow interrupt)<br>  &nbsp;&nbsp; 1 - Mouse IRQ enable ("")<br> &nbsp;&nbsp;&nbsp; 2 - Timer IRQ enable ("")<br> &nbsp;&nbsp;&nbsp; 3 - Audio IRQ enable ("")<br> &nbsp;&nbsp;&nbsp; 4 - n/u<br>&nbsp; &nbsp;&nbsp; 5 - n/u<br>&nbsp; &nbsp;&nbsp; 6 - n/u<br>&nbsp; &nbsp;&nbsp; 7 - Master IRQ enable (must be set to allow ANY interrupt to occur)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><a name="Port:_02_-_Read"></a>Port: $02 - Read:&nbsp; "<span style="font-weight: bold;">sys_keyboard_data</span>"<br><br>&nbsp;&nbsp;&nbsp; 0:7 - Data byte received from keyboard<br><br><br><a name="Port:_02_-_Write"></a>Port: $02 - Write: "<span style="font-weight: bold;">sys_clear_irq_flags</span>"</pre>
<pre>(Bits written with ones clear the relevant IRQ flag)</pre>
<pre>Bit: 0 - Clear Keyboard IRQ<br>&nbsp;&nbsp;&nbsp;  1 - Clear Mouse IRQ<br>&nbsp;&nbsp; &nbsp; 2 - Clear Timer IRQ<br>&nbsp;&nbsp; &nbsp; 3 - n/u<br>&nbsp;&nbsp; &nbsp; 4 - Clear Audio Channel 0 Loop IRQ Flag<br>&nbsp;&nbsp; &nbsp; 5 - Clear Audio Channel 1 Loop IRQ Flag<br>&nbsp;&nbsp; &nbsp; 6 - Clear Audio Channel 2 Loop IRQ Flag<br>&nbsp;&nbsp; &nbsp; 7 - Clear Audio Channel 3 Loop IRQ Flag</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><span style="font-family: monospace;"><br>
</span>
<pre><a name="Port:_03_-_Read"></a>Port: $03 - Read: "<span style="font-weight: bold;">sys_mouse_data</span>"</pre>
<pre> 0:7 - Data byte received from mouse</pre>
<pre><br><a name="Port:_03_-_Write"></a>Port: $03 - Write: "<span style="font-weight: bold;">sys_ps2_joy_control</span>"</pre>
<pre>Bit: 0 - Joystick port 0/1 select - determines which port is active.<br>     1 - n/u<br>     2 - n/u<br>     3 - n/u<br>     4 - Keyboard Clock Control output - (Set to 1 to PULL DOWN the signal)<br>     5 - Keyboard Data Control output - ("")<br>     6 - Mouse Clock Control output - ("")<br>     7 - Mouse Data Control output - ("")</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><a name="Port_04"></a>Port $04 - Read/write: "<span style="font-weight: bold;">sys_serial_port</span>"</pre>
<pre>Incoming or outgoing data byte for RS232 com port</pre>
<pre>Note: Reading clears the "serial byte received" flag (bit 6 in Port $05)</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre><a name="Port_05_-_Read"></a>Port $05 - Read:&nbsp; "<span style="font-weight: bold;">sys_joy_com_flags</span>" - Joystick inputs and RS232 status</pre>
<pre>Bit: 0 - Up<br>     1 - Down<br>     2 - Left<br>     3 - Right<br>     4 - Fire 1<br>     5 - Fire 2<br>     6 - RS232 Byte received<br>     7 - RS232 Output Buffer Busy</pre>
<pre><br><a name="Port_05_-_Write"></a>Port $05 - Write: "<span style="font-weight: bold;">sys_sdcard_ctrl1</span>"<br><br>Bit: 0:5 - n/u <br>       6 - Enable FPGA to SD card data output<br>       7 - SD card port's SPI speed: 0 = 250KHz, 1 = 8MHz</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre><a name="Port_06"></a>Port $06 - Read/Write: "<span style="font-weight: bold;">sys_sdcard_ctrl2</span>"</pre>
<pre>Bit: 0:1 - n/u (ignore / mask these bits when reading. No write function.)<br>       2 &#8211; Read/Write SD card /CS line (active low)<br>       3 &#8211; Read/Write SD card /Power control (active low)<br>     4:7 - n/u&nbsp; (ignore / mask off these bits when reading. No write function.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre><a name="Port:_07_-_Read"></a>Port: $07 - Read: &#8220;<span style="font-weight: bold;">sys_vreg_read</span>&#8221; - Video status register (same value as address $700)</pre>
<pre>Bit: 7 - Interlace field 0 = short field, 1 = long field <br>     6 - LSB of scanline count<br>     5 - 60Hz mode (1 = NTSC config / VGA mode jumper installed and 50Hz not forced.)<br>     4 - Blitter / linedraw status (1 = busy) check before changing relevant registers <br>     3 - Raster IRQ status (for manual polling)<br>     2 - Y Window (1 = display area, 0 = border)<br>     1 - X Window&nbsp; (1 = display area, 0 = border) *<br>     0 - Last line (VRT). Reads as 1 during the last line of each frame.</pre>
<pre><br>* Remember, in VGA mode each scanline's data is output twice at double the normal frequency.<br> This flag reflects the x-window of the normal PAL/NTSC ~15KHz scanline.</pre>
<pre><br><a name="Port:_07_-_Write"></a>Port: $07 - Write: "<span style="font-weight: bold;">sys_timer</span>" - The timer internally counts *upwards* from this value<br> at 62.5KHz (ie: every 256 clock ticks) when it overflows, it sets the timer<br> IRQ flag, then reloads the count from the value that was written here.</pre>
<pre><br>Note: Writing to this port immediately sets the timer to the written value and clears<br>the internal prescaler count. </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><a name="Port:_08_-_Read"></a>Port: $08 - Read: <span style="font-weight: bold;">"sys_audio_flags"</span></pre>
<pre>Bit:&nbsp;0 - Channel 0 is playing<br>     1&nbsp;- Channel 1 is playing<br>     2 - Channel 2 is playing<br>     3 - Channel 3 is playing<br>     4 - Channel 0 has looped (IE: internal length countdown has reached 0)<br>     5 - Channel 1 has looped (use bits 7:4 of port 2 to clear these flags)<br>     6 - Channel 2 has looped ("")<br>     7 - Channel 3 has looped ("")</pre>
<pre><br><a name="Port:_08_-_Write"></a>Port: $08 - Write: "<span style="font-weight: bold;">sys_audio_enable</span>"</pre>
<pre>Bit: 0 - Channel 0 - 1 = Play audio, 0 = Stop audio<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 - Channel 1 - ("")<br>&nbsp; &nbsp;&nbsp;&nbsp;2 - Channel 2 - ("")<br>     3 - Channel 3 - ("")<br>   4:7 - n/u</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<br>
<pre><a name="Port_09_-_Read"></a>Port $09 - Read: "<span style="font-weight: bold;">sys_hw_flags</span>"</pre>
<pre>Bit: 7 - Hardware version serial data (16 bit value)<br>     6 - SD card serializer status (1 = busy)<br>     5 - Video Mode jumper status (0 = TV mode, 1 = VGA mode)<br>     4 - Config EEPROM serializer status (1 = data byte ready for read)<br>     3 - Configuration PIC's RB7 port status<br>   2:0 - n/u: Ignore / mask off these undefined bits </pre>
<pre><br>To read the hardware version word, set the address bus bits 11:8 to $0-$F when reading<br>this port (ie: use the "OUT (C),A" instruction, presetting register B with 0 to 15).<br>The bit addressed by B will appear in bit 7 of this port.</pre>
<pre><br><a name="Port_09_-_Write"></a>Port $09 - Write: "<span style="font-weight: bold;">sys_hw_settings</span>"</pre>
<pre>Bit: 0 - NMI switch inhibit. Default = 0, NMI switch enabled<br>     1 - Reset switch inhibit. Default = 0, Reset switch enabled <br>     2 &#8211; No effect (was originally PAL/NTSC mode select)<br>     3 &#8211; Force VGA to 50Hz mode (no effect in TV mode)<br>   4:7 - Not used</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><a name="Port_0A"></a>Port $0A - Read / Write: "<span style="font-weight: bold;">sys_spi_port</span>"</pre>
<pre>The SPI port is used by the V6Z80P to send bytes serially (MSB first, SPI mode 0) to<br>its SD Card interface. Also, serial data received from the card's D_out line appears<br>here for reading. See also: SPI speed setting in Port $05 and busy flag in port $09</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><a name="Port_0B"></a>Port $0B - Read/Write: "<span style="font-weight: bold;">sys_alt_write_page</span>" *</pre>
<pre>Bit: 0 - Write Page select Bit 0 - Relevant when bit 4 of Port 0 is set <br>     1 - Write Page select Bit 1 - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""<br>     2 - Write Page select Bit 2 - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""<br>     3 - Write Page select Bit 3 - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""<br><br> (Note: uses same 32KB page selection table as "<a href="#Port_20">sys_low_page</a>")<br><br><br> 4 - "Write Palette/Read System RAM" - When set, CPU writes between $0-$1FF<br> are directed to the palette registers, whilst CPU reads in this memory<br> range return bytes from system RAM (instead of the ROM). This mode<br> overrides bit 6 status<br><br> 5 &#8211; &#8220;Any page mode&#8221;. When set this allows the first 32KB of system RAM to be<br> paged into locations $8000-$ffff of Z80 address space when bits 0:3<br> of <a href="#Port:_00">sys_mem_select</a> are zero. (Originally this was prohibited.)<br><br> 6 &#8211; "Read/Write First 512 bytes of System RAM" - When set, the system RAM<br> &#8220;underneath&#8221; the ROM/palette at $000-$1ff is accessible as normal System RAM<br> locations for read and write. Note: If bit 4 is set, this setting is ignored.<br><br> 7 &#8211;&nbsp;&#8220;Access RAM under video registers&#8221; - When set, the system RAM &#8220;underneath&#8221;<br> the video registers at $200 - $7ff is accessible. As well as redirecting<br> CPU writes to system RAM this control causes reads in the range $700-$7ff<br> to return bytes from system RAM (READs from $200-$6ff return bytes from<br> system RAM whether this bit is set or not). This means that the video<br> status register and maths unit result word is not available (however,<br> the video status register can always be read from port 7 - &#8220;<a href="#Port:_07_-_Read">sys_vreg_read</a>&#8221;)</pre>
<pre>* To ensure the ROM is paged in upon reset and the system can start, this port register<br> is reset to $00 when the reset button is pressed.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br>Port $0C - Read: No function</pre>
<pre><br><a name="Port_0C_-_Write"></a>Port $0C - Write: "<span style="font-weight: bold;">sys_baud_rate</span>"</pre>
<pre>Bit: 0 - Set serial port RS232 comms speed: 0 = 57600 BAUD, 1 = 115200 BAUD</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre><a name="Port_0D_-_Read"></a>Port&nbsp; $0D - Read: "<span style="font-weight: bold;">sys_eeprom_byte</span>"</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This port contains data bytes from the SPI FPGA configuration EEPROM, which<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can be read under CPU control. It should be read only when the "serializer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status flag" (bit 4 of port "<a href="#Port_09_-_Read">sys_hw_flags</a>") is 1. Reading this port clears<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the internal bit count and status flag. </pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Handshaking: When a databurst has been initiated (see PIC comms section) the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PIC issues a new byte every time the PIC CLOCK (bit 1 of "<a href="#Port_0D_-_Write">sys_pic_comms</a>") is raised.</pre>
<pre><a name="Port_0D_-_Write"></a><br>Port&nbsp; $0D - Write: "<span style="font-weight: bold;">sys_pic_comms</span>"</pre>
<pre>Bit: 0 - Write to Configuration PIC port RB1 (data to PIC)<br>     1 - Write to Configuration PIC port RA5 (clock to PIC)<br>   2:7 - Not used, write with zeroes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><a name="Port_0E"></a>Port $0E - Read/Write: "<span style="font-weight: bold;">sys_io_pins</span>" (see data direction in port $0F)</pre>
<pre><br>Bit:&nbsp;0 - Read/Write data bit for IO pin A<br>     1 - Read/Write data bit for IO pin B (pulled up)<br>     2 - Read/Write data bit for IO pin C (on PCBs that support it)<br>   3:5 - n/u <br>     6 - Reads: RESET switch status (pulled up)* - Write: N/A<br>     7 - Reads: NMI switch status (pulled up)* - Write: N/A</pre>
<pre>* Only relevant when Reset / NMI functions are disabled by port 9 bits 0:1<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><a name="Port_0F_-_Read"></a>Port $0F - Read: No function</pre>
<pre><a name="Port_0F_-_Write"></a>Port $0F - Write: "<span style="font-weight: bold;">sys_io_dir</span>" </pre>
<pre>Bit: 0 - Data direction for IO pin A (0 = output, 1 = input)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 - Data direction for IO pin B ( &#8220;&#8221; )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 - Data direction for IO pin C (on PCBs that support it)<br> 3:7 - n/u</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><a name="Port_20"></a>Port $20 &#8211; Read / Write: &#8220;<span style="font-weight: bold;">sys_low_page</span>&#8221;</pre>
<pre>&nbsp;Bit: 0:3 &#8211; Lower 32KB page select<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4:7 &#8211; Not Used &#8211; mask / ignore these undefined bits.</pre>
<pre> This port selects which 32KB page from the 512KB system RAM appears at Z80 $0000-$7fff<br>&nbsp;(see table below). Bear in mind the ROM/Palette, video registers and sprite page will<br> still occupy Z80 address space locations: $0000-$01ff, $0200-$07ff and $1000-$1fff<br> respectively regardless of which 32KB page is selected UNLESS these locations are<br> specifically banked out of the address space with their respective control bits.</pre>
<pre><br>System RAM Lower Page Selection Table:</pre>
<pre><span style="text-decoration: underline;">Bits: 3 2 1 0&nbsp;&nbsp;|&nbsp;System RAM paged into Z80 $0000-$7FFF</span><br><br>     0 0 0 0&nbsp;&nbsp;= $00000 - $07FFF <br>     0 0 0 1&nbsp;&nbsp;= $08000 - $0FFFF <br>     0 0 1 0&nbsp;&nbsp;= $10000 - $17FFF<br>     0 0 1 1&nbsp;&nbsp;= $18000 - $1FFFF<br>     0 1 0 0&nbsp;&nbsp;= $20000 - $27FFF<br>     0 1 0 1&nbsp;&nbsp;= $28000 - $2FFFF<br>     0 1 1 0&nbsp;&nbsp;= $30000 - $37FFF<br>     0 1 1 1 &nbsp;=&nbsp;$38000 - $3FFFF<br>     1 0 0 0&nbsp;&nbsp;= $40000 - $47FFF <br>     1 0 0 1&nbsp;&nbsp;= $48000 - $4FFFF<br>     1 0 1 0&nbsp;&nbsp;= $50000 - $57FFF<br>     1 0 1 1&nbsp;&nbsp;= $58000 - $5FFFF<br>     1 1 0 0&nbsp;&nbsp;= $60000 - $67FFF <br>     1 1 0 1&nbsp;&nbsp;= $68000 - $6FFFF<br>     1 1 1 0&nbsp;&nbsp;= $70000 - $77FFF / LineCop program area ($0000 - $7fff)<br>     1 1 1 1 &nbsp;= $78000 - $7FFFF / LineCop program area ($8000 - $ffff)</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><a name="Port_21_&#8211;_Read"></a>Port $21 &#8211; Read - No function</pre>
<pre><br><a name="Port_21_-_Write"></a>Port $21 - Write: &#8220;<span style="font-weight: bold;">sys_vram_location</span>&#8221;</pre>
<pre>Bit: 0:2 - Location of the video memory access window in Z80 address space (see table)<br>     3:7 &#8211; Not Used &#8211; write with zeroes</pre>
<pre><br><span style="text-decoration: underline;">Bits: 2 1 0&nbsp; |&nbsp; VRAM Location:</span></pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 0&nbsp; =&nbsp; $2000 *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 1&nbsp; =&nbsp; $2000 *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1 0&nbsp; =&nbsp; $4000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1 1&nbsp; =&nbsp; $6000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 0&nbsp; =&nbsp; $8000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 1&nbsp; =&nbsp; $a000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 0&nbsp; =&nbsp; $c000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1&nbsp; =&nbsp; $e000</pre>
<pre><br>Note: The video window is paged in and out of Z80 address space with bit 6 of "<a href="#Port:_00">sys_mem_select</a>"</pre>
<pre>* 000 and 001 both set the VRAM window location at Z80 address $2000 (It is not possible to set<br>the VRAM window to Z80 $0000)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br>Ports $22 - $27: Used by sound system, see following section.<br><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><a name="Sound_System_Detail:"></a><br>
<span style="font-family: monospace;"></span><a name="Sound_System"></a>Sound
System&nbsp;Detail:</h3>
<pre>Note: The audio channel location registers were expanded to 18 bit in OSCA v672. Previously,<br>only 128KB of System RAM ($20000-$3FFFF) was accessible to the audio system.<br><br><span style="text-decoration: underline;"><br>Port assignments:</span><br><br>Ports $10-$1F and $22-$27 are assigned to the audio functions: <span style="text-decoration: underline;"></span><br><br><span style="font-weight: bold;"><a name="Port_10"></a>Port $10 -&nbsp;"audchan0_loc"</span> Location of sound wave in System RAM Bits [bits 16:1 of sample address] (16 bit register)<br><span style="font-weight: bold;"><a name="Port_11"></a>Port $11&nbsp;- "audchan0_len"</span> Length of sound wave (in words) (16 bit register)<br><span style="font-weight: bold;"><a name="Port_12"></a>Port $12 - "audchan0_per"</span> Period of sound wave (number of 16MHz clock ticks between sample bytes) (16 bit register)<br><span style="font-weight: bold;"><a name="Port_13"></a>Port $13&nbsp;- "audchan0_vol"</span> Volume of sound wave ($00-$40) (Linear scale: $40 = maximum volume) (8 bit register)</pre>
<pre>(<a name="14-17"></a><span style="font-weight: bold;">$14-$17</span>: Same for channel 1 - <span style="font-weight: bold;">"audchan1_loc", "audchan1_len", "audchan1_per", "audchan1_vol"</span>)<br>(<a name="18-1b"></a><span style="font-weight: bold;">$18-$1b</span>: Same for channel 2 - <span style="font-weight: bold;">"audchan2_loc", "audchan2_len", "audchan2_per", "audchan2_vol"</span>)<br>(<a name="1c-1f"></a><span style="font-weight: bold;">$1c-$1f</span>: Same for channel 3 - <span style="font-weight: bold;">"audchan3_loc", "audchan3_len", "audchan3_per", "audchan3_vol"</span>)<br><br><br><span style="font-weight: bold;"><a name="Port_22"></a>Port $22 - 'aud_panning'</span> (8 bit register)<br><br>Bit 0:3 - Select which channels go to the right side <br> &nbsp;&nbsp;&nbsp;4:7 - Select which channels go to the left side&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;(Each bit position = one channel, IE: bit0=channel0, bit1=channel1 etc)<br><br><br><span style="font-weight: bold;">Port $23 - Not implemented</span><br><br><br style="font-weight: bold;"><span style="font-weight: bold;"><a name="Port_24"></a>Port $24</span> - '<span style="font-weight: bold;">audchan0_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 0<br><span style="font-weight: bold;"><a name="Port_25"></a>Port $25</span> - '<span style="font-weight: bold;">audchan1_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 1<br><span style="font-weight: bold;"><a name="Port_26"></a>Port $26</span> - '<span style="font-weight: bold;">audchan2_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 2<br><span style="font-weight: bold;"><a name="Port_27"></a>Port $27</span> - '<span style="font-weight: bold;">audchan3_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 3<br><br>(These 4 location_high ports are 8 bit registers - only bits 0:1 are used)<br><br><br><span style="text-decoration: underline;">Notes:</span><br><br>The sound location registers are 18 bits long in total and refer to WORD addresses (not<br>byte addresses) in System RAM (samples need to placed at word boundaries). Basically you<br>write (the actual RAM address / 2) into the location registers. <br><br>Samples must be an even number of bytes in length - you write the length in WORDS into<br>the Length registers (IE: Actual byte length/2). Maximum sample length is therefore 128KB.<br><br>The location (low), length and period values are 16 bit registers and should be updated<br>by using the Z80 "OUT (C),r" instruction where C is the port number, r holds the low 8 bits<br>of data and B holds the high 8 bits of data. The volume and location (high) ports are 8 bit<br>registers and can be updated with the normal "OUT (n),A" instruction if desired. <br><br>The volume is a linear scale value (range: $00 = silence to $40 = full volume).<br><br>The sound sample data needs to be in signed 8-bit format and located in System RAM<br>(it is read by the hardware using DMA). The audio hardware ignores any memory paging<br>settings and always reads directly from the system RAM when fetching data.<br><br>The sound system operates in a similar fashion to that of the Amiga Hardware, ie: You<br>set the location, length, period and volume of a channel, then start the channel<br>playing with the relevant "<a href="#Port:_08_-_Write">sys_audio_enable</a>" port bit. Once the channel is playing,<br>its Location and Length registers can be updated - the channel will only fetch the<br>new values once its original length value has counted down to zero (or you stop<br>the channel for a while and restart it). If the registers are not changed, the<br>channel simply loops around playing the same sample data until it is stopped.</pre>
<pre>Because of the way the sound hardware pre-fetches sample data, some care needs<br>to be taken when setting up the registers.&nbsp; The recommended audio register setup<br>procedure is as follows:</pre>
<pre>1. Wait for post-audio DMA time (EG: wait for bit 6 of "<a href="#Port:_07_-_Read">sys_vreg_read</a>" to change)<br>2. Stop the relevant audio channel(s) and write location, length, period and volume.<br>3. Wait for next post-audio DMA time (IE: At least one scanline delay)<br>4. Start the relevant audio channel(s)</pre>
<pre>(Once a sample is playing, the <span style="font-weight: bold;">volume and period</span> <span style="font-weight: bold;"></span>registers can generally be updated<br>on the fly without special regard to the DMA timing)</pre>
<pre>It's possible to use an interrupt to seamlessly switch between two or more sample<br>buffers in order to play long samples without worrying about the exact timing. To<br>do this you would start a channel playing, reload it with the second buffer ready<br>for the first loop as normal, and then set up the audio interrupt so that it occurs<br>upon the first loop (IE: just as the second buffer starts to play). In the IRQ<br>service routine, you would set the channel location and length to point back to<br>the first buffer, and on subsequent IRQs switch between the two buffers.</pre>
<pre>Note: The four audio loop flags are OR'd into a single interrupt source. It is up<br>to the IRQ service routine to read bits 4:7 of the "<a href="#Port:_08_-_Read">sys_audio_flags</a>" port, see<br>which bits are set (and clear them on exit from the IRQ).<br><br><br>Other sound related ports (see port breakdown detail above):</pre>
<pre>Port $01 ("<a href="#Port_01_-_Write">sys_irq_enable</a>")- to enable/disable the audio IRQ<br>Port $02 (<a href="#Port:_02_-_Write">"sys_clear_irq_flags"</a>)- to clear audio IRQ loop flags<br>Port $08 (<a href="#Port:_08_-_Write">"sys_audio_enable" / "sys_audio_flags"</a>) - to enable channels / read loop flags.</pre>
<pre><br><span style="text-decoration: underline;">CALCULATING THE AUDIO PERIOD VALUE:</span></pre>
<pre>The period value is not the same as the Amiga uses, however, it has 4 times the resolution<br>so a close match value can be obtained if desired.</pre>
<pre>Period = 16,000,000 / desired sample output rate<br><br>EG: To playback at 22050Hz, set the period to (16,000,000/22050) = 725</pre>
<pre>The minimum period value is around 512 (corresponding to a sample rate of ~31KHz) - this is<br>because the hardware only pre-fetches 2 samples during DMA per scanline (and there is a couple<br>of cycles overhead etc)</pre>
<pre>For pure tones, the output frequency depends on the number of samples in your waveform<br>that constitute one cycle, so if the sample has EG: 16 bytes in one cycle, the period<br>value required to play it at a desired frequency is calculated thus:</pre>
<pre>Period = 16,000,000 / (samples per cycle * frequency) </pre>
<pre><br><span style="text-decoration: underline;">Panning:</span></pre>
<pre>The default set-up is for channels 0 and 2 to go to the left side, whilst channels 1 and 3<br>go to the right side,&nbsp; but by writing to port $22 "<a href="#Port_22">sys_audio_panning</a>" all 4 channels can be<br>individually directed to the left, right or both sides.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h2>Hardware
<a name="Maths_Assist"></a>Maths Assist &#8211; multiply /
scale unit</h2>
<pre>The maths assist unit consists of 3 elements: a) A 256 word table which can hold values (such as<br>sine constants), b) A 16bit value that is multiplied by the values in the table and c) An index<br>byte to select which word in the table to multiply by. The multiplication is a sign extended<br>16 bit x 16 bit operation, but only 16 bits from the resulting 32 bit longword are available to<br>be read, these bits are taken from bit 29 to bit 14. (Therefore care should be taken with the<br>values used in the multiplication operation to a) get correct results for unscaled multiplies<br>and b) prevent overflows.)</pre>
<pre><img style="width: 491px; height: 357px;" alt="Maths Assist Diagram" src="images/maths_assist.png"><br><br>The maths unit can be used for fast scaling of values using just the first entry of the table.<br>For example you could write some value to be scaled into the mult_table(0), set the mult_index<br>at 0 and write the scaling factor from 0 to 16384 into &#8220;mult_write&#8221;. The output from &#8220;mult_read&#8221;<br>will be mult_table(0) * mult_write/16384</pre>
<pre>To use the maths unit as a simple 256 x 16bit look-up table, write your 16 bit words in the<br>mult_table, put 16384 into mult_write and simply select the value by setting mult_index and reading<br>from mult_read.</pre>
<pre>To do an unscaled "multiply by a constant" (using only a single entry in the table) you need<br>to adjust the multiplier and multiplicand to counter the scaling of the output. EG: To multiply<br>$0087 by $0025 you could write $8700 into mult_write - (IE: a simple LSB/MSB byte swap) and<br>$0940 into mult_table(0) (IE: $25 * $40). As the second word needs more processing, this would<br>be your pre-set constant (you could fill the rest of the table with other constants if desired).</pre>
<pre>The maths unit makes sin/cos calculations straightforward: Write the table with 256 sine values<br>(maximum positive amplitude = 16384), set the multiplier word to coordinate x and the index byte<br>to the angle a, the resulting word will be SIN (a) * x</pre>
<pre>Registers / locations used by the maths unit:</pre>
<pre>$208-$209 &nbsp;: "<a href="#208__209">mult_write</a>" 16 bit multiplier (word - write only)<br>$20A &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;: "<a href="#20A">mult_index</a>" Maths table index (byte - write only)<br>$600-$7FF&nbsp; : "<a href="#mult_table">mult_table</a>" Data table&nbsp; (word - write only)<br>$704-$705&nbsp; : "<a href="#704-705">mult_read</a>"&nbsp; Maths unit result (word - little endian - read only)</pre>
<br>
<hr style="width: 100%; height: 2px;">
<h3><span style="text-decoration: underline;"><a name="The_Video_System:"></a>The
Video System:</span> </h3>
<pre>There is 512KB of &#8220;background video&#8221; RAM available (separate to sprite, audio and system memory).<br>It is normally accessible to the CPU in 8KB pages (at Z80 address $2000, $4000, $6000, $8000,<br>$A000, $C000 or $E000 depending on the port setting "<a href="#Port_21_-_Write">sys_vram_location</a>") with the page selected<br>by the video register "<a href="#206">vreg_vidpage</a>". However, a special write-only mode also allows the entire Z80<br>address space to be mapped onto a 64KB page of video RAM.</pre>
<pre><br>There are two main video modes, bitmap and tilemap - both allow up to 256 colours. The display<br>is normally non-interlaced, PAL ~50Hz or VGA/NTSC ~60Hz (there is an option to force VGA to<br>non-standard 50Hz). CPU access TO VIDEO MEMORY whilst the display window is being generated is<br>blocked by the video system. The different video modes affect how long the CPU is kept<br>waiting - Dual Playfield tilemap mode is the most demanding. <br><br></pre>
<pre style="font-weight: bold; text-decoration: underline;">BITMAP "CHUNKY" MODE:</pre>
<pre><br>&nbsp;In standard chunky bitmap mode pixel data is fetched in a simple 1 byte = 1 pixel<br>&nbsp;fashion (it is called "chunky" as all the bits for each pixel come from the same<br>&nbsp;'chunk' - IE: location - in memory).</pre>
<pre>&nbsp;The byte fetched from VRAM represents an index in the video palette, therefore a $00 &nbsp;<br>&nbsp;shows a &#8220;palette entry 0&#8221; coloured pixel, $01 shows a &#8220;palette entry 1&#8221; coloured pixel<br>&nbsp;and so on. Data is fetched linearly from VRAM left to right, top to bottom of the screen.<br>&nbsp;The data-fetch start address can be manipulated to achieve smooth scrolling effects.</pre>
<pre><span style="text-decoration: underline;"><br>Line draw system:</span><br>&nbsp;<br> Fast line draws (125ns per 256 colour pixel) are possible in chunky mode. The<br>&nbsp;hardware requires Bresenham constants, octant number, video start address and<br>&nbsp;length of line to be set up in the line draw registers, then the hardware carries<br>&nbsp;out the algorithm. The registers are doubled up, allowing line set-up data for a<br>&nbsp;new line to be loaded up whilst the previous line is being drawn.</pre>
<pre><br><span style="text-decoration: underline;">Flood mode:</span> (Simplified in OSCA 672)<br><br>&nbsp;Chunky mode also offers "pixel flooding" (see bit 6 of <a href="#201">vreg_vidctrl</a>) which<br>&nbsp;repeats the last pixel colour to achieve flood fill effects. In this mode,<br>&nbsp;the hardware XOR's each new pixel with the value of the last. The stored<br> colour is reset to zero at the start of each scan line.</pre>
<pre><br><span style="text-decoration: underline;">Pixel Expand</span>:<br><br> Finally, in chunky mode pixels can be horizontally expanded from 1 to 8 times<br> (see bit 3 of "<a href="#201">vreg_vidctrl</a>" and bits 0:2 "<a href="#203">vreg_yhws_bplcount</a>")<br></pre>
<pre><br><span style="text-decoration: underline; font-weight: bold;">BITMAP "PLANAR" MODE:</span><br><br>&nbsp;In planar mode the display can have up to 8 bitplanes which are internally combined<br>&nbsp;to form a palette index for each pixel. As the number of&nbsp;bitplanes can be set<br>&nbsp;(see <a href="#203">vreg_yhws_bplcount</a>), the maximum number of colours on screen (without reloading<br> the palette registers mid-screen) can be 2,4,8,16,32,64,128 or 256. This can offer<br> efficiencies in terms of video memory use and update speed. The main disadvantage is<br> that fine pixel-level access&nbsp;is more difficult. <span style="font-weight: normal;">The bitplane location address registers<br> c</span><span style="font-weight: normal;">an be manipulated to achieve scrolling effects etc. (Fine horizontal pixel scrolling<br> </span><span style="font-weight: normal;">is provided via a hardware scroll register (</span><a style="font-weight: normal;" href="OSCA_Hardware_Manual.html#200">vreg_xhws</a><span style="font-weight: normal;">).</span><span style="font-weight: normal;"><br><br></span> The diagram below shows how bitplane data is combined to form a pixel's palette index:</pre>
<pre><img style="width: 471px; height: 234px;" alt="Bitplane system diagram" src="images/bitplane.png"><br><br></pre>
<pre><br><span style="text-decoration: underline;">Bitplane Location Registers and Modulo:</span><br><br>To set the location of display data, write to the <a href="#240">Bitplane Location Registers</a> at $240-$27F<br>(see register index for details). The location registers need only be written once, an internal<br>counter adds an offset internally as the frame is built up (this offset register can be reset at<br>any time). For convenience, there are in fact two sets of location registers - the video hardware<br>uses the set determined by bit 5 of the video register "<a style="font-weight: normal;" href="OSCA_Hardware_Manual.html#201">vreg_vidctrl</a>". <br><br>A modulo register is provided also - this can be used to skip bytes at the end of each scan<br>line - Useful for hiding new scroll data, interlaced displays etc.<br><br></pre>
<pre><br><span style="font-weight: bold; text-decoration: underline;">TILE-MAP MODES:</span>
</pre>
<pre>&nbsp;In tile-map mode the display is built up in a less direct manner: The hardware reads<br> a look-up table to display a predefined block for each tile position. The blocks can<br> be 8x8 or 16x16 pixels in size (defined in a simple, linear &#8220;1 byte = 1 pixel<br> colour index&#8221; left to right, top to bottom fashion). Dual playfield capability is<br> provided so that one map can be overlaid on top of the other (pixels of value 0<br> are taken as transparent). The playfield priority is selectable. Each playfield<br> can be offset by 0-15 pixels in the vertical or horizontal direction allowing<br> smooth scrolling. There are two map buffers per playfield which allows double<br> buffering if desired. The registers <a href="#201">vreg_vidctrl</a>, <a href="#20c">vreg_ext_vidctrl</a>, <a href="#200">vreg_xhws</a><br> and <a href="#203">vreg_yhws_bplcount</a> contain the control bits for the tilemap modes.</pre>
<pre><br></pre>
<pre style="text-decoration: underline;">LEGACY AND EXTENDED TILE MODES:</pre>
<pre>&nbsp;The most basic OSCA tilemap mode limits tiles to 16x16 pixels, indexed with single<br> bytes allowing a maximum of 256 different tiles. Two sets of tile definitions are<br> available with 248 and 256 tile images respectively (Tile set A has fewer definition<br> blocks available because the video memory for blocks 0-7 (VRAM $0-$7ff) is assigned<br> for use as the four available tile maps.) This simplistic system is referred to as<br> &#8220;Legacy Tilemap mode&#8221;.&nbsp; Extended Tile Mode provides more flexibility and may be a<br> better choice for new programs.</pre>
<pre><br>In Legacy Tile Mode: The Video RAM is organized as follows:<br><br>&nbsp;&nbsp;&nbsp; $00000 - $001FF:&nbsp; Playfield A - tilemap 0<br> &nbsp;&nbsp; $00200 - $003FF:&nbsp; Playfield A - tilemap 1<br>&nbsp;&nbsp;&nbsp; $00400 - $005FF:&nbsp; Playfield B - tilemap 0<br>&nbsp;&nbsp;&nbsp; $00600 - $007FF:&nbsp; Playfield B - tilemap 1</pre>
<pre>&nbsp;&nbsp;&nbsp; $00800 - $0FFFF: Tile definition set A (Tile defs 0-7 cannot be used)<br>&nbsp;&nbsp;&nbsp; $10000 - $1FFFF: Tile definition set B (All 256 tiles available)</pre>
<pre>&nbsp;&nbsp;&nbsp; The horizontal size of the tile map buffer is always 32 bytes, no matter what<br>&nbsp;&nbsp;&nbsp; the size of the display window.</pre>
<pre><br><span style="text-decoration: underline;">EXTENDED TILE MODE:</span><br><br>&nbsp;In Extended Tilemap Mode (IE: when bit 0 of <a href="#20c">vreg_ext_vidctrl</a> is set), tiles are<br>&nbsp;indexed by 2 bytes and can be 16x16 or 8x8 pixels. There is a single set* of 2048<br>&nbsp;16x16 tiles or 8192 8x8 tiles (the &#8220;tile set select&#8221; bits used in legacy mode have<br>&nbsp;new meanings in Extended Tilemap Mode.) The tile maps are located between at $70000-<br>&nbsp;$73fff in video memory, well clear of the tile definitions which are located at<br>&nbsp;VRAM $0 (The memory space used by the tile maps will produce garbage tiles if<br>&nbsp;indexed). Bits 6:7 of the upper byte of the tile indices control x_mirror (Bit 6)<br>&nbsp;and y_flip (Bit 7) of each tile definition.</pre>
<pre>*&nbsp;Although the tile definitions are normally indexed in a straightforward linear manner,<br> there is an option to switch between the definitions held at VRAM $0-$3FFFF and $40000-$7ffff.</pre>
<pre>In Extended Tile Mode with 16x16 tiles: VRAM is organised as follows:</pre>
<pre>&nbsp;&nbsp; $00000-$6FFFF: Tile definitions (256 bytes each)<br>&nbsp;&nbsp; $70000-$701FF: Playfield A Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $70200-$703FF: Playfield A Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $70400-$705FF: Playfield A Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $70600-$707FF: Playfield A Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $70800-$709FF: Playfield B Buffer 0 tilemap MSBs (incl. tile flip control)<br>&nbsp;&nbsp; $70A00-$70BFF: Playfield B Buffer 1 tilemap MSBs ("")<br>&nbsp;&nbsp; $70C00-$70DFF: Playfield B Buffer 0 tilemap MSBs ("")<br>&nbsp;&nbsp; $70E00-$70FFF: Playfield B Buffer 1 tilemap MSBs ("")</pre>
<pre>In 16x16 tilemap mode, the width of each horizontal map line is 32 bytes no matter what the<br>size of the display window. Each tilemap has room for 16 rows of tiles (ie: a 256 scanline display),<br>however when using vertical hardware scroll, the maximum y window should be 240 lines to mask<br>off the last tile-line (where the internal tilemap line pointer wraps back to 0)</pre>
<pre>In Extended Tile Mode with 8x8 tiles: VRAM is organised as follows:</pre>
<pre>&nbsp;&nbsp; $00000-$6FFFF: Tile definitions (64 bytes each)<br>&nbsp;&nbsp; $70000-$707FF: Playfield A Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $70800-$70FFF: Playfield A Buffer 0 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $71000-$717FF: Playfield A Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $71800-$71FFF: Playfield A Buffer 1 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $72000-$727FF: Playfield B Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $72800-$72FFF: Playfield B Buffer 0 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $73000-$737FF: Playfield B Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $73800-$73FFF: Playfield B Buffer 1 tilemap MSBs (incl. flip control)<br><br>(Notice that the LSB/MSB arrangement is slightly different to that of the 16x16 mode.)</pre>
<pre>In 8x8 tilemap mode, the width of each horizontal map line is 64 bytes no matter what the<br>size of display window. The hardware scroll registers still provide a 0-15 pixel offset.</pre>
<pre>Each tilemap has room for 32 rows of tiles (ie: a 256 scanline display), however<br>when using vertical hardware scroll, the maximum y window should be 248 lines to<br>mask off the last tile-line (where the internal tilemap line pointer wraps back to 0)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3><a name="Sprites:"></a>Sprites:</h3>
<pre>There is 128KB of dedicated RAM for sprite definitions (enough space for 512 16x16 256<br>colour sprite blocks). This (write only) memory is accessed in 4KB pages through a<br>window in Z80 address space located at $1000-$1FFF. The 4KB page from within the total<br>128KB sprite RAM is selected by the register <a href="#206">vreg_vidpage</a> (write the page number 0-31,<br>with bit 7 set). The 4KB window is opened and closed with Bit 7 of the port "<a href="#Port:_00">sys_mem_select</a>".<br>(Note: When the CPU reads from $1000-$1FFF, data is ALWAYS returned from system RAM<br>regardless of the setting in <a href="#Port:_00">sys_mem_select</a>.)</pre>
<pre>Sprite definition memory accepts writes at full speed when the sprites are disabled.<br>When sprites are enabled, writes from the CPU are forced to wait until the sprite<br>hardware releases the RAM buses. The length of the wait during contention depends<br>how busy the sprite hardware is on any given scanline. Access to the sprite control<br>registers is never subject to contention.</pre>
<pre>Each sprite definition block is 256 bytes long, with pixel data in a linear format<br>"1 byte = 1 pixel" fashion, left to right, top to bottom of the sprite definition.<br>Colour index zero is considered transparent by the sprite video hardware. Sprites<br>are always 16 pixels wide but can be up to 240 pixels tall (the height of an<br>individual sprite (in 16 line blocks) is set by its control register). The additional<br>definition data for sprites taller than 16 lines comes from the blocks of sprite data<br>following the specified sprite definition. Sprite images can be individually mirrored<br>horizontally by setting a bit in their control registers - see detail below.</pre>
<pre>There is enough time on any one scanline to show 55 sprites, but there are 127 sprite<br>control registers. Therefore, this can be thought of as hardware multiplexing: Because<br>it is uncommon for 55 sprites to appear on the same line, sprite images from all the<br>registers will normally be displayed if spread throughout the entire display window.</pre>
<pre>A double buffering mode allows half the sprite registers to be updated whilst the<br>sprite hardware builds the display from the other half (the buffers are typically<br>switched by the user's program each frame). This removes possible on-screen glitches<br>and/or the need to dump data to the sprite registers off-screen. Bits in <a href="#207">vreg_sprctrl</a><br>are used operate this mode.</pre>
<pre><br><span style="text-decoration: underline;">Sprite to Background Priority:</span></pre>
<pre>In the most basic mode, non-zero sprite pixels appear in front of all background<br>display data. However there are controls to allow sprites to be masked by sections<br>of the background colour palette. For the purposes of priority, the background palette<br>is divided into 16 x 16 colour groups, sprites can then appear in front or behind<br>one or more of these groups. There are two sets of background mask selections,<br>sprites use the mask set based on bit 7 of their pixel colours. To dynamically<br>switch a sprite from one set of masks to the other (EG: to move it from foreground<br>to background) bits from a sprite&#8217;s control register can be used to modify its<br>pixels&#8217; MSBs (without this it would be necessary to have copies of the same sprites<br>drawn using different colour indexes and switch the definitions.) </pre>
<pre>The main priority control &#8220;interleave mode&#8221; is bit 1 of <a href="#207">vreg_sprctrl</a>, when this bit<br>is zero, sprite pixels appear in front of all background data. When this bit is<br>set to one, sprites use their pixel colour index MSBs to select one of the two<br>background mask sets.</pre>
<pre><br>To assist with individual sprite priorities, an option called "modify_colour_MSBs"<br>is available, this is enabled by bit 4 in <a href="#207">vreg_sprctrl</a>. When set, the MSB of each<br>individual sprite's height control is sacrificed and transferred the MSB of all<br>the sprite&#8217;s pixel colours. Of course, the sprite would normally change colour<br>if the palette indices 1-127 and 129-255 are different, therefore another control<br>bit is available that forces sprites only to be shown using colours 1-127 (IE:<br>their pixel colour MSBs are reset to zero, but only after the priority has been<br>determined). This option is called &#8220;fix_colours_low&#8221; and is enabled with bit 6<br>of <a href="#207">vreg_sprctrl</a>. (As these options sacrifice the MSB of the sprites&#8217; height settings,<br>it limits how tall a sprite can be.)</pre>
<pre>One last sprite feature is "matte mode" - this forces all non-zero pixels in a sprite<br>to a single colour, an effect which is sometimes used in games to indicate a character<br>has taken a hit. The feature is enabled with bit 5 in <a href="#207">vreg_sprctrl</a>, afterwards bit 2<br>of each sprite&#8217;s height control register is used to switch individual sprites to single<br>colour. Internally, this feature sets bits 0:6 of the sprite pixels (but not bit 7, as that<br>could affect its priority). Therefore all the sprite&#8217;s pixels will be shown as colour<br>127 or colour 255 depending on the sprite&#8217;s original bit 7 (if in doubt simply make<br>palette colours 127 and 255 the same). As another bit of the sprite height control<br>register is sacrificed, sprites are limited to 16/32/48/64 pixels tall (also 128,144,<br>160,176 if "modify_colour_MSBs" is not required.)</pre>
<pre>In general, bear in mind the sprite layer is generated separately (and concurrently)<br>to the background, and because priorities work solely on colour indexes care must be<br>taken (especially in dual playfield tile mode) when designing the colour palette and<br>the order in which sprites are assigned to registers.</pre>
<pre><br><span style="text-decoration: underline;">Background priority mask registers:</span></pre>
<pre>The mask registers are located at $280-$28F. Only two bits of each location are used:<br>Bit 0 is the mask for &#8220;level 0&#8221; (where a sprite&#8217;s colour index MSB is 0) and Bit 1 is<br>the mask for &#8220;level 1&#8221; (where a sprite&#8217;s colour index MSB is 1). The register at $280<br>holds the masks for background colours 0-15, the register at $281 holds the masks for<br>background colours 16-31, the register at $282 holds the masks for background colours<br>32-47 and so on.</pre>
<pre>Where each register mask bit is zero, the range of colours it will represents will<br>appear behind sprites. Where a mask bit is one, the range of colours it represents<br>will appear in front of sprites.</pre>
<pre>An example:</pre>
<pre>$280: (background 00-0f) = 00b&nbsp;&nbsp; &nbsp;$288: (background 80-8f) = 01b<br>$281: (background 10-1f) = 00b&nbsp;&nbsp; &nbsp;$289: (background 90-9f) = 01b<br>$282: (background 20-2f) = 00b&nbsp;&nbsp; &nbsp;$28A: (background a0-af) = 01b<br>$283: (background 30-3f) = 00b&nbsp;&nbsp; &nbsp;$28B: (background b0-bf) = 01b<br>$284: (background 40-4f) = 00b&nbsp;&nbsp; &nbsp;$28C: (background c0-cf) = 01b<br>$285: (background 50-5f) = 00b&nbsp;&nbsp; &nbsp;$28D: (background d0-df) = 01b<br>$286: (background 60-6f) = 00b&nbsp;&nbsp; &nbsp;$28E: (background e0-ef) = 01b<br>$287: (background 70-7f) = 00b&nbsp;&nbsp; &nbsp;$28F: (background f0-ff) = 01b</pre>
<pre>In the above example (when interleave mode is enabled) sprites with pixel indexes<br>in the range 00-7f will be occluded by background colours 80-ff. This is the default<br>OSCA setting.</pre>
<pre style="text-decoration: underline;"><br><a name="Sprite_Control_Registers"></a>Sprite Control Registers (4 bytes per sprites)</pre>
<pre><br>Memory addresses of registers:</pre>
<pre>&nbsp;$400-$5fb (127 registers - single set of sprite control registers)</pre>
<pre>&nbsp; or</pre>
<pre>&nbsp;$400-$4fb (Register bank 0) (63 registers - double buffered register mode)<br>&nbsp;$500-$5fb (Register bank 1) (63 registers - double buffered register mode)</pre>
<pre><br>Each sprite register is 4 sequential bytes:</pre>
<pre>$00 : X coordinate (low 8 bits)</pre>
<pre>$01 : Bits 7:4 = Height of sprite (in blocks of 16 lines) - If the four height<br> bits are zero, the sprite is 240 pixels tall.</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 = X Mirror enable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 = Definition MSB<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 = Y coordinate MSB <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 = X coordinate MSB</pre>
<pre><br>$02 : Y coord (low 8 bits)</pre>
<pre>$03 : Sprite definition number (low 8 bits)<br><br><br><span style="text-decoration: underline;">Coordinates:</span></pre>
<pre><span style="font-family: monospace;"></span><span style="font-family: monospace;"></span>X and Y coordinates are 9 bits in size, the MSBs are stored in the second byte of the register.<br>The coordinate positions are fixed and are not relative to the display window position,<br>IE: the X/Y coordinates are the same absolute positions as those used by the window<br>location / size set up. (X sprite positions are actually one pixel less than x_window_start<br>position).</pre>
<pre><span style="text-decoration: underline;"><br>Size</span>:<br><br>As mentioned, sprites are always 16 pixels wide, but can normally be up to 240 pixels high,<br>with a granularity of 16 lines (as set by bits 7:4 of the second byte in each sprites<br>control register). However, some height control bits can be sacrificed for other features:<br><br>If "<span style="font-weight: bold;">modify_colour_MSBs</span>" mode is enabled (bit 4 in <a href="#207">vreg_sprctrl</a> = 1) the four bits normally<br>assigned to height work as follows:</pre>
<pre>bit 7 - Use priority mask set 0 or 1<br>&nbsp;&nbsp;&nbsp; 6 - Height (bit 2)<br>&nbsp;&nbsp;&nbsp; 5 - Height (bit 1)<br>&nbsp;&nbsp;&nbsp; 4 - Height (bit 0)</pre>
<pre>Therefore in this mode sprites can be 16,32,48,64,80,96,112 (or 240 when the three height<br>bits are all zero) lines tall.</pre>
<pre><br>If <span style="font-weight: bold;">"matte_mode</span>" is enabled (bit 5 in <a href="#207">vreg_sprctrl</a> = 1) the four bits normally assigned to<br>height work as follows: </pre>
<pre>bit 7 - Height (bit 3)<br>&nbsp;&nbsp;&nbsp; 6 - Force non-zero colours to 127 or 255<br>&nbsp;&nbsp;&nbsp; 5 - Height (bit 1)<br>&nbsp;&nbsp;&nbsp; 4 - Height (bit 0)</pre>
<pre>Therefore in this mode sprites can be 16,32,48,64, and 128,144,160,176 lines tall<br>(64 lines are used when bit 0 and 1 are zero)</pre>
<pre><br>If both "<span style="font-weight: bold;">matte_mode</span>" and "<span style="font-weight: bold;">modify_colour_MSBs</span>" modes are selected, the four bits normally<br>used for height are interpreted as follows:</pre>
<pre>bit 7 - Use priority mask set 0 or 1<br>&nbsp;&nbsp;&nbsp; 6 - Force non-zero colours to either 127 or 255<br>&nbsp;&nbsp;&nbsp; 5 - Height (bit 1)<br>&nbsp;&nbsp;&nbsp; 4 - Height (bit 0)<br><br>In this mode sprites can be 16,32,48,64 lines tall (64 lines are used when bit 0 and<br>1 are zero).<br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3><a name="Display_Window:"></a>Display
Window:</h3>
<pre>The positions of the edges of the display window are programmable (which of course<br>also sets the size of the display). There are 4 bits of precision for each of the left,<br>right, top and bottom edges. The horizontal resolution is 16 pixels and the vertical<br>resolution is 8 lines. Values obtained from the tables below should be written to the<br>register <a href="#202">vreg_window</a> (note that both vertical and horizontal settings share this same<br>register - the horizontal/vertical function is switched by bit 2 of <a href="#204">vreg_rasthi</a> - see<br>the example at the end of this section).</pre>
<pre><br>Positioning a display window within the maximum possible display area:</pre>
<pre><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X stop</pre>
<pre>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! <br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V<br>!---!------------------------------------.<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8220;BORDER&#8221;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! &lt;- Y start<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTIVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISPLAY WINDOW&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! &lt;- Y Stop<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&lt;-- MAX VISIBLE AREA OF TV SCREEN--&gt;!<br>!---'------------------------------------'<br>!&nbsp;&nbsp; !<br>^&nbsp;&nbsp; ^</pre>
<pre>Sync etc</pre>
<pre><br><span style="text-decoration: underline;">Horizontal Positions:</span></pre>
<pre>There are theoretically 512 horizontal pixel positions along a scan line. The x_start<br>values are n * 16 pixels in from the left hand side. The x_stop values are n * 16 pixels<br>from theoretical pixel 256 (note: this is not the exact centre of the TV screen, due to<br>sync periods etc). When writing to the <a href="#202">vreg_window</a> register, the left side setting<br>nybble goes in bits [7:4] and the right side setting nybble goes in bits [3:0]<br><br><br>Display Window Register "<a href="#202">vreg_window</a>" Values:</pre>
<pre><span style="text-decoration: underline;">Nybble&nbsp;&nbsp;&nbsp;X_start&nbsp; X_stop</span><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $0 &nbsp;&nbsp;=&nbsp; 00 *&nbsp;&nbsp;&nbsp; 256&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;$1   =  16 *&nbsp;&nbsp;&nbsp; 272&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br> $2 &nbsp; =&nbsp; 32 *&nbsp;&nbsp;&nbsp; 288&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $3 &nbsp; =&nbsp; 48 *&nbsp;&nbsp; &nbsp; 304&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $4 &nbsp; =&nbsp; 64 *&nbsp;&nbsp; &nbsp; 320&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $5 &nbsp; =&nbsp; 80 *&nbsp;&nbsp; &nbsp; 336&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $6 &nbsp;&nbsp;= &nbsp;96&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 352&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $7 &nbsp;&nbsp;= &nbsp;112&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 368&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $8 &nbsp;&nbsp;= &nbsp;128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 384&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> $9 &nbsp;&nbsp;= &nbsp;144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 400&nbsp;&nbsp; &nbsp;<br> $a &nbsp;&nbsp;= &nbsp;160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 416&nbsp;&nbsp; &nbsp;<br> $b &nbsp;&nbsp;= &nbsp;176&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 432&nbsp;&nbsp; &nbsp;<br> $c &nbsp;&nbsp;= &nbsp;192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 448<br> $d &nbsp;&nbsp;= &nbsp;208&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 464&nbsp;&nbsp; &nbsp;<br> $e &nbsp;&nbsp;= &nbsp;224&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 480<br> $f &nbsp;&nbsp;= &nbsp;240&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 496&nbsp;&nbsp; &nbsp;</pre>
<pre>*&nbsp; = Outside of the normally visible TV frame - there's no point using these values.</pre>
<pre>Note: Width of display in pixels = ((x_stop nybble + 16) - x_start nybble) * 16</pre>
<pre><br><br><span style="text-decoration: underline;">Vertical Positions:</span></pre>
<pre>The Y_start value refers to the position of the top line of your active display window.<br>(This is counting from 16 lines above the first visible scanline of the screen - these<br>"redundant" 16 lines allow sprites to be masked off at the top of the display). The<br>Y_stop value refers to the position of the last line of your display window, also<br>counting from 16 lines above the first visible scanline of the screen. </pre>
<pre>Values for Y_Start (<a href="#202">vreg_window</a> register bits 7:4): <br><br><span style="text-decoration: underline;">Nybble&nbsp;&nbsp; Lines from 1st visible&nbsp;&nbsp; (Sprite Y coord)&nbsp;</span>&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; $0&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;-16 * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $1&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;-8&nbsp; * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$09&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $2&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$11&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $3&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$19&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $4&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;16&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$21 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $5&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;24&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$29&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $6&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;32&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$31&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $7&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;40&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$39&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $8&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;48&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$41&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $9&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;56&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$49&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $a&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;64&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$51&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $b&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;72&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$59&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $c&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;80&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$61&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $d&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;88&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$69&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $e&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;96&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$71&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $f&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;104 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$79&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre><br>*&nbsp; This is above the top of the visible screen, these values should not normally be used.<br>&nbsp; (IE: A value of $2 written to the Y_start register gives the highest available start<br>&nbsp; line on PAL/NTSC/VGA displays.)</pre>
<pre><br></pre>
<pre>Values for Y_Stop Window (<a href="#202">vreg_window</a> register bits 3:0): <br><br><span style="text-decoration: underline;">Nybble&nbsp; Lines from 1st visible&nbsp;(Sprite Y coord)</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre>&nbsp;$0&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 144                 $a1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;$1&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 152                 $a9<br>&nbsp;$2&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;160                 $b1<br>&nbsp;$3&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;168                 $b9<br>&nbsp;$4&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;176                 $c1<br>&nbsp;$5&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;184&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $c9<br>&nbsp;$6&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;192&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $d1<br>&nbsp;$7&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;200&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $d9<br>&nbsp;$8&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;208&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $e1<br>&nbsp;$9&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;216&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $e9<br>&nbsp;$a&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;224&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $f1<br>&nbsp;$b&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;232&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $f9<br>&nbsp;$c&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;240&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $101<br>&nbsp;$d&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;248&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  $109<br>&nbsp;$e&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;256&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; $111<br>&nbsp;$f&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;264 **&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;  $119</pre>
<pre>** This is below the bottom of a PAL display and should not normally be used.</pre>
<pre>Note: Total lines in display = (Y_Stop nybble * 8) + 160 - (Y_Start's nybble * 8)</pre>
<pre><br><span style="text-decoration: underline;">VGA/NTSC/PAL Mode notes:</span></pre>
<pre>Because the different TV/VGA modes have various numbers of scanlines making up the<br>display, a window vertically centred in one display mode may not be central in other<br>modes. If this is important, a constant (depending on the display mode) can added to<br>the start/stop settings plus all sprite y coordinates and scanline-based operations.<br>The 60Hz mode flag in the Video Status Register can assist if the correction is to<br>be done automatically, else a display adjust routine can be provided in user programs.</pre>
<pre><br></pre>
<pre style="text-decoration: underline;">Example code: Display Window setting:</pre>
<pre>To set the vertical start and stop positions of the display window, first write<br><a href="#204">vreg_rasthi</a> with bit 2 clear, then write an appropriate value from the tables<br>above to <a href="#202">vreg_window</a>. To set the horizontal positions, write <a href="#204">vreg_rasthi</a> with<br>bit 2 set, then write an appropriate value for the horizontal setting to <a href="#202">vreg_window</a>.<br><br>EG:<br>&nbsp;&nbsp; &nbsp;ld a,$00<br>&nbsp;&nbsp; &nbsp;ld (vreg_rasthi),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; selects vertical window setting<br>&nbsp;&nbsp; &nbsp;ld a,$5a<br>&nbsp;&nbsp; &nbsp;ld (vreg_window),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; sets vertical window size/position (200 lines)<br>&nbsp;&nbsp; &nbsp;ld a,$04<br>&nbsp;&nbsp; &nbsp;ld (vreg_rasthi),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; selects horizontal window setting<br>&nbsp;&nbsp; &nbsp;ld a,$8c<br>&nbsp;&nbsp; &nbsp;ld (vreg_window),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; sets horizontal window size/position (320 pixels</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><a name="Blitter:"></a>Blitter:</h3>
<pre>OSCA&#8217;s blitter can transfer data around video memory much faster than the CPU (it copies one<br>byte every 2 system clocks, compared with the CPU's LDIR instruction @ 1 byte per 21 clocks).<br>It can work in ascending or descending address order and also has modulo registers so that<br>rectangular areas within larger overall arrays can be shifted in one go. It can, however,<br>only operate within video memory. There is the option to skip the writing of source bytes<br>that equal zero, this is mainly useful in Chunky pixel mode where it can be used to mask<br>out "transparent" pixels (eg: drawing "bobs").<br><br>The blitter takes priority over access to video RAM from the CPU (but obviously the video<br>datafetch still impedes its performance) and the CPU is forced to wait for the blitter to<br>finish its operation if it tries to access video memory whilst a blit is under way.<br>Otherwise, a blit can be started and the CPU can continue with another task.<br><br>The blitter's registers are located at <a href="#210">$200-21a</a>, see the register list for more information.<br><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Line Draw:</h3>
<pre>The hardware line draw unit can be used in chunky pixel mode. In a similar fashion to the<br>blitter, this system&nbsp;takes priority over access to video memory and leaves the CPU free<br>to do other things (it cannot run concurrently with the blitter, however).<br><br>Using this system involves setting up a table of constants (common to all lines) and<br>setting start address, length, colour and Bresenham values for each line. There are two<br>sets of line draw registers, allowing registers to be loaded for a new line whilst<br>another line is being drawn. The line draw system's registers are located at: <a href="#2201">$220-$23f</a>,<br>see the register list for more details.<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Line Sync'd Co-Pro ("<a name="LineCop"></a>LineCop"):</h3>
<pre>This simple co-processor allows changes to be made to the display at specific scan lines<br>without having to use manual CPU interrupts (it operates using DMA cycle-stealing in a<br>similar manner to the sound system). The LineCop system follows a program, there are 3<br>main instructions and each instruction is two bytes long. The upper bits of the MSB<br>determines what kind of instruction it is:</pre>
<pre><br><span style="text-decoration: underline;">Bit: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 1&nbsp; x&nbsp; x&nbsp; x&nbsp; x&nbsp; x&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; = Wait for line L</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 0&nbsp; x&nbsp; x&nbsp; x&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; = Select Register R</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; a&nbsp; b&nbsp; c&nbsp; x&nbsp; x&nbsp; x&nbsp; x&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; = Write D to Register</pre>
<pre><br>x = Dont care<br>L = Line to wait for<br>R = Register to update ($0-$7FF)<br>D = Data byte to write to selected register <br>a = If set: After Write, increment selected register<br>b = If set: After write, increment wait line (and wait)<br>c = If set: After write, reload LineCop Program Counter from Start Location Registers<br><br>Wait and Register Select instructions take 2 clock cycles, Register Writes take 3 cycles.</pre>
<pre>The LineCop program can be 64KB max (32768 instructions), and must be located at $70000-$7FFFF<br>in system memory (IE: The highest two upper 32KB banks). The start address of the program is<br>held in <a href="#20d">vreg_linecop_lo</a> ($20D) and <a href="#20e">vreg_linecop_hi</a> ($20E). Bits [15:1] are used for the address,<br>whereas bit [0] (IE: the least significant bit of <a href="#20d">vreg_linecop_lo</a>) is the LineCop enable bit.<br>The LineCop's Program Counter is reloaded from the address held in <a href="#20d">vreg_linecop_lo</a> and<br><a href="#20e">vreg_linecop_hi</a> at the end of every frame and also when forced by a LineCop write instruction<br>which has bit 12 set. As the LineCop can write to its own location pointers and restart itself,<br>automatic list cycling / page flipping can be achieved. Linecop programs should end with a wait<br>for a line that is never reached, IE: $1FF (Use the instruction code hexcode $C1FF)</pre>
<pre>When the raster reaches a scanline that matches that set by a LineCop wait instruction, the<br>LineCop steals time from the CPU until it reaches the next Wait instruction. If the end of<br>the scanline is reached first, the Linecop becomes inactive until the next frame.</pre>
<pre>Whilst writes to the palette etc have immediate effect, some video register changes will<br>not take effect until the start of the next scanline, or sometimes the line following<br>that. This is due to the way the internal scanline buffers are generated. It is advisable<br>to use the double-buffered registers whilst making changes to the sprites or bitmap locations<br>as the write will occur some time during the linebuffer generation period. &nbsp;</pre>
<pre>As the LineCop can access all the video registers including blitter etc, beware of malformed<br>LineCop programs causing undesired effects. The linecop only ever writes to the hardware<br>registers - never system RAM - EG: bit 7 of the port &#8220;<a href="#Port_0B">sys_alt_write_page</a>&#8221; is irrelevent to<br>the LineCop.</pre>
<pre style="text-decoration: underline;"><br>An example LineCop program:</pre>
<pre>Change the background colour to white at scanline $50, and black at scan line $51</pre>
<pre>Location | Instruction<br>----------------------</pre>
<pre>$70000:&nbsp;&nbsp; &nbsp;$c050&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Wait for line $50<br>$70002: &nbsp; &nbsp;$8000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Select video register $000 (background colour)<br>$70004:&nbsp;&nbsp; &nbsp;$40ff&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $ff to colour LSB, increment video register<br>$70006:&nbsp;&nbsp; &nbsp;$20ff&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $ff to colour MSB, increment wait line (and wait)<br>$70008:&nbsp;&nbsp; &nbsp;$8000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Select video register $000 (background colour)<br>$7000A:&nbsp;&nbsp; &nbsp;$4000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $00 to colour LSB, increment video register<br>$7000C:&nbsp;&nbsp; &nbsp;$0000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $00 to colour MSB<br>$7000E:&nbsp;&nbsp; &nbsp;$C1FF&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Wait for line $1FF (Never reached - end of LineCop program)</pre>
<pre>Note that LineCop instruction WORDS are shown for clarity above - the BYTE ordering is<br>Z80 standard little endian, therefore - as bytes - the code above would be listed:</pre>
<pre>$70000: $50,$c0,$00,$80,$ff,$40,$ff,$20,$00,$80,$00,$40,$00,$00,$ff,$c1</pre>
<pre>The above LineCop program is started with the Z80 code:</pre>
<pre> LD HL,$0001 ; LineCop program Address = $70000 (bit 0 = enable) <br> LD (vreg_linecop_lo),HL ; Set address and start</pre>
<pre>The LineCop can be stopped with the Z80 code:</pre>
<pre> XOR A ; Zero the accumulator<br> LD (vreg_linecop_lo),A&nbsp;&nbsp; &nbsp; ; When bit 0 of this register is zero, the linecop is stopped.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><a name="Colour_palette"></a>Colour
palette:</h3>
<pre>The V6Z80P's colour resolution is 12 bit, with 4 bits for red, green and blue (a choice<br>of 4096 colours). The indexed pixel colour system used by OSCA allows up to 256 colours<br>on screen at once (without using mid-screen register reloading). There are two sets of<br>palette registers, each holding 256 entries (words). The palette currently being accessed<br>by the video hardware to build the video frame and that which receives writes from the<br>CPU / LineCop can be independently set (see "<a href="#20f">vreg_palette_ctrl</a>")</pre>
<pre>Both palettes are located at memory locations $000 - $1FF, with the following format:</pre>
<pre> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Colour 0&nbsp;&nbsp;&nbsp; Colour 1&nbsp;&nbsp;&nbsp; Colour 2&nbsp;&nbsp;&nbsp;&nbsp; etc..</span><br><br>Location:&nbsp; $00,$01,&nbsp;&nbsp;&nbsp; $02,$03,&nbsp;&nbsp;&nbsp;&nbsp; $04,$05,&nbsp;&nbsp;&nbsp; etc..<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GB&nbsp; 0R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GB&nbsp; 0R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GB&nbsp; 0R&nbsp;&nbsp;&nbsp;&nbsp; etc..</pre>
<pre><br>Where R, G &amp; B are the 4 bit intensity values of Red, Green and Blue. (The 4 MSBs [15:12]<br>of each entry are not used and should be written with zeroes).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Resolution:</h3>
<pre>The normal horizontal pixel resolution in TV mode is 8MHz and 16MHz in VGA mode - this<br>means there can be approximately a maximum of 368 pixels visible on any one scan line.<br>As there is spare bandwidth in TV mode, there is the option to increase the pixel rate<br>to 16MHz, at the expense of colour depth (reduced to 16 colours max) &#8211; see bit 3 of<br>&#8220;<a href="#20c">vreg_ext_vidctrl</a>&#8221; - this is referred to as Hi-Res Mode. In this mode, the colour index<br>of each normal pixel is split into two 4-bit indices (7:4 = Leftside hi-res pixel,<br>3:0&nbsp; = Rightside hi-res pixel).&nbsp; This process is applied at final output stage of the<br>pixel colour look-up and is merely a &#8220;filter&#8221; instead of a "real" hi-res mode. Because<br>the sprite priority system is unaware of this filter, it still processes priorities<br>based on 8 bit pixel values - therefore sprite interleaving should not be used in<br>hi-res mode.</pre>
<pre>The vertical resolution varies depending on the TV/monitor (PAL has approx 256 visible<br>lines, less for NTSC and VGA). The TV modes allow interlacing (see bit 2 of <a href="#20c">vreg_ext_vidctrl</a>)<br>this adjusts the frame timing causing the TV to offset the lines of every other frame by<br>half the thickness of a scanline. (Bit 7 of <a href="#Port:_07_-_Read">sys_vreg_read</a> shows which field is currently<br>being displayed.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><a name="Video_Hardware_Timing"></a>Video
Hardware Timing:</h3>
<pre>As can be seen from the diagram below, each video line is internally buffered until the<br>next scan line when it actually displayed. The sprites and background video layers are<br>generated simultaneously to separate buffers and combined when the line is eventually<br>clocked out to the display.<br><br><br><img style="width: 436px; height: 200px;" alt="Linebuffer timing" src="images/linebuffer_timing.png"><br>&nbsp;</pre>
<pre>Writing to most video registers will have an immediate visible effect (EG: writes to<br>the colour palette, unless double buffered) but some will not visibly change anything<br>until the following scan line as changes are automatically synchronized to the start<br>of a new scan line, these include:</pre>
<pre>* &#8220;Live Palette Select&#8221; (in <a href="#20f">vreg_palette_ctrl</a>)</pre>
<pre>*&nbsp;&#8220;Live Bitplane Location Register Set Select&#8221; (also &#8220;Playfield A map buffer select&#8221;<br> when in Tilemap mode) (bit 5 in <a href="#201">vreg_vidctrl</a>)</pre>
<pre>*&nbsp;&#8220;Tilemap Mode Select&#8221; (bit 0 in <a href="#201">vreg_vidctrl</a>)</pre>
<pre>*&nbsp;&#8220;Chunky or Planar Bitmap Mode Select&#8221; (also &#8220;Dual Playfield On/Off Select&#8221; when<br> in Tile Map mode) (bit 7 in <a href="#201">vreg_vidctrl</a>)</pre>
<pre>*&nbsp;&#8220;Display Window Right Side Position&#8221; (in <a href="#202">vreg_window</a>)</pre>
<pre><br>A note concerning updating bitmap location pointers: Each line begins generation<br>before the LineCop DMA starts, therefore even if the bitmap location registers are<br>changed with the linecop at the start of a line (IE: immediately following a LineCop<br>WAIT instruction) there will be some pixels at the start of the displayed line that<br>were fetched before the pointers were changed. This can be avoided using double buffering<br>via the 2nd bitmap location register set, alternatively the unwanted pixels can be<br>masked with a wide border etc.</pre>
<pre><br><span style="text-decoration: underline;">Scan Line Timing Detail:</span></pre>
<pre>Each scanline lasts for 1024 16MHz clock cycles in PAL TV mode (1016 cycles in NTSC or VGA<br>modes). At the start of each line the CPU is taken offline by a BUSREQ signal for audio DMA.<br>(There is short, variable delay of a few cycles following a Bus Request whilst waiting for an<br>acknowledgment from the CPU). Once the audio system is online, it lasts around 20 clock cycles.<br>Following on, the LineCop has control of the main system bus for as long as the necessary to<br>complete the LineCop operations required on that line. Afterwards, the CPU continues normally<br>(as long as it not forced to wait by it accessing video or sprite memory during active display<br>lines).</pre>
<pre><br>Scanline Timing:<br><img style="width: 449px; height: 147px;" alt="Scanline timing diagram" src="images/scanline_timing.png"><br><br>Bitmap and sprite video data is fetched simultaneously and concurrently with the CPU<br>running normally as the three systems have their own memory buses. The time each<br>system requires to build its internal buffer is variable and depends on the amount of<br>data on a particular scan line.&nbsp; As mentioned, the CPU only has to wait if it tries to<br>access bitmap or sprite memory whilst data is being fetched by the relevant system.<br><br>The blitter and linedraw systems are also forced to wait during the bitmap fetch part<br>of a scan line. These systems have priority over the CPU in accessing video memory when<br>its free (not being read by the video system) and force the CPU to wait if the CPU<br>is trying access bitmap video memory at the same time. Active blits are paused at the<br>&#8220;last 16 cycles&#8221; point, ensuring the CPU is not waiting at the start of a scanline<br>(which could cause complications with the DMA functions). A paused blit continues<br>after the bitmap layer data fetch period.</pre>
<pre><br><span style="text-decoration: underline;">Video Frequencies etc:</span></pre>
<pre><br>Video output:<br><br> PAL non-interlaced : 50.0801 Hz, 312 lines per frame.</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;PAL interlaced : 50 Hz, 625 lines (312 / 313 lines)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Horizontal frequency : 15625 Hz</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Pixel clock : 8Mhz (Lo res) or 16MHz (Hi-res mode)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> NTSC non-interlaced&nbsp; : 60.106 Hz, 262 lines per frame.</pre>
<pre>	NTSC interlaced : 59.99 Hz, 525 lines (262 / 263 lines)</pre>
<pre>	Horizontal frequency : 15748 Hz<br>	<br>	Pixel clock : 8Mhz (Lo res) or 16MHz (Hi-res mode)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>	<br>	VGA 60Hz : 60.106 Hz, 262 double-lines per frame<br><br>	Horizontal Frequency : 31496 Hz (line doubled)<br><br>	Pixel Clock : 16 Mhz (Low res only)</pre>
<pre>	VGA 50Hz* : 50.4 Hz, 312 double-lines per frame<br><br>	Horizontal Frequency : 31496 Hz (line doubled)<br><br>	Pixel Clock : 16 Mhz (Low res only)</pre>
<pre><br>* This is a non-standard mode and may not work on all VGA monitors.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3 style="text-decoration: underline;">Video Registers -
Details:</h3>
<pre>Notes:</pre>
<pre>* The Video Registers are located between $0200-$07ff in Z80 address space, unless paged<br> out using the port: sys_alt_write_page</pre>
<pre>* All video registers are WRITE ONLY.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="200"></a>$200</span> = <span style="font-weight: bold;">"vreg_xhws</span>" - Horizontal Hardware Scroll&nbsp; (No effect in Chunky mode)</pre>
<pre>&nbsp;7:4 Playfield B Scroll position (0 - 15 pixels offset to the right) tile mode only.<br>&nbsp;3:0 Playfield A / Bitmap Mode Scroll position (0 - 15 pixels offset to the right.)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><span style="font-family: mon;"></span></span>
<pre><span style="font-weight: bold;"><br><a name="201"></a>$201</span> = "<span style="font-weight: bold;">vreg_vidctrl</span>" - Playfield Control</pre>
<pre>Certain bits of this register take on different meanings depending on the video mode:</pre>
<pre style="text-decoration: underline;">In Bitmap Mode (IE: When bit 0 is clear)</pre>
<pre>&nbsp; 7 &#8211; Enable &#8220;Chunky Pixel&#8221; Format (each video data byte fetched is a colour index)<br>&nbsp; 6 &#8211; Enable &#8220;Flood Mode&#8221; - for use with in Chunky Pixel mode<br>&nbsp; 5 - Use Bitplane Location Register set A (0) or B (1) for video data<br>&nbsp; 4 &#8211; Not Used<br>&nbsp; 3 &#8211; Horizontal Expand: 0 = Off, 1 = On (For chunky mode only)<br>&nbsp; 2 - Video Unhibit: 0 = Normal, 1 = Colour index $00 replaces all non-sprite video<br>&nbsp; 1 - Wide Left Border: 0 = Normal, 1 = Mask first 16 pixels for x-scrolling. <br>&nbsp; 0 &#8211; Display mode: 0 = Bitmap Mode, 1 = Tilemap mode</pre>
<pre style="text-decoration: underline;">In Legacy Tile Map Mode (IE: When bit 0 is set and bit 0 of <a href="#20c">vreg_ext_vidctrl</a> is clear)</pre>
<pre>&nbsp; 7 - Dual Playfield Enable<br>&nbsp; 6 - Playfield B Map Buffer Select<br>&nbsp; 5 - Playfield A Map Buffer Select<br>&nbsp; 4 - Playfield B Tile Set Select <br>&nbsp; 3 - Playfield A Tile Set Select<br>&nbsp; 2 - Video inhibit: 0 = Normal, 1 = Colour index 0 replaces all non-sprite video.<br>&nbsp; 1 - Wide Left Border: 0 = Normal, 1 = Mask first 16 pixels for x-scrolling <br>&nbsp; 0 &#8211; Display mode: 0 = Bitmap Mode, 1 = Tilemap mode</pre>
<pre style="text-decoration: underline;">In Extended Tile Map Mode (IE: When bit 0 is set, and bit 0 of <a href="OSCA_Hardware_Manual.html#20c">vreg_ext_vidctrl</a> is set)</pre>
<pre>&nbsp; 7 - Dual Playfield Enable<br>&nbsp; 6 - Playfield B Map Buffer Select<br>&nbsp; 5 - Playfield A Map Buffer Select<br>&nbsp; 4 &#8211; Definition swap (0= Normal, 1= tiles at $00000-$3FFFF switched with $40000-$7FFFF) &nbsp;<br>&nbsp; 3 &#8211; Tile size: 0 = Use 16x16 tiles, 1 = Use 8x8 tiles<br>&nbsp; 2 - Video inhibit: 0 = Normal, 1 = Colour index 0 replaces all non-sprite video.<br>&nbsp; 1 - Wide Left Border: 0 = Normal, 1 = Mask first 16 pixels for x-scrolling. <br>&nbsp; 0 &#8211; Display mode: 0 = Bitmap Mode, 1 = Tile map mode</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="202"></a>$202</span> = "<span style="font-weight: bold;">vreg_window</span>" - Display Window Size&nbsp; - Sets size of display window.</pre>
<pre style="text-decoration: underline;">When Reg_switch is zero (bit 2 of vreg_rasthi is 0)</pre>
<pre>&nbsp;7:4 -&nbsp; Window Top (start) position (see table above for values)<br>&nbsp;3:0 -&nbsp; Window Bottom (stop) position (see table above for values)</pre>
<pre style="text-decoration: underline;">When Reg_switch is one (bit 2 of vreg_rasthi is 1)</pre>
<pre>&nbsp;7:4 - Window Left position (see table above for values)<br>&nbsp;3:0 - Window Right position (see table above for values)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><span style="font-family: monospace;"><br>
</span>
<pre><span style="font-weight: bold;"><a name="203"></a>$203</span> = "<span style="font-weight: bold;">vreg_yhws_bplcount</span>" - Vertical Hardware Scroll Settings / Bitplane count</pre>
<pre><br>In Tilemap mode this register sets two separate hardware scroll values, one for each playfield.<br>To set the scroll value for playfield 0, write to this register with bit 7 clear. To set the scroll<br>value for playfield 1, write to this register with bit 7 set.</pre>
<pre>&nbsp;&nbsp; 7 - Select Playfield 0 / Playfield 1 Y-scroll register <br>&nbsp;6:4 - Not used<br>&nbsp;3:0 - Vertical Scroll offset value (0 to 15 pixels)</pre>
<pre><br>In Planar Bitmap Mode this register has a totally different use - setting the number of bitplanes in the display:</pre>
<pre>&nbsp;&nbsp;&nbsp; 7 - Write with this bit as ZERO<br>&nbsp; 6:3 - not used<br>&nbsp; 2:0 - Number of bitplanes (0= one bitplane to 7= eight bitplanes.)</pre>
<pre><br>In Chunky Bitmap mode this register sets the width of the pixels:</pre>
<pre>&nbsp;&nbsp;&nbsp; 7 - Write with this bit as ZERO<br>&nbsp; 6:3 - Not used<br>&nbsp; 2:0 - Width of pixels (0-7 = 1 to 8 pixels)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;"><a name="204"></a>$204 =&nbsp; "vreg_rasthi"</span> - Raster IRQ MSB, enable, clear &amp; Window XY switch </pre>
<pre>&nbsp;&nbsp; 7 - Clear Raster IRQ flag *<br>&nbsp;6:3 - Not Used</pre>
<pre>&nbsp;&nbsp; 2 - Window Register X/Y switch<br>&nbsp;&nbsp; 1 - Enable Raster IRQ<br>&nbsp;&nbsp; 0 - Raster IRQ Scanline Position MSB</pre>
<pre>* When this register is written with bit 7 set, the video IRQ flag is cleared and the<br> rest of the register's contents are unchanged</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;"><a name="205"></a>$205 = "vreg_rastlo"</span> -&nbsp; Raster IRQ line position </pre>
<pre>&nbsp;7:0 - Low 8 bits of Raster IRQ scanline position</pre>
<pre>&nbsp;The counter used in the line comparison starts 16 lines above the first visible <br>&nbsp;scanline (same as the sprites).&nbsp; Note: PAL, NTSC and VGA have different numbers of<br>&nbsp;scanlines and no interrupt will occur if this register and the MSB in <a href="#204">vreg_rasthi</a><br> are set to a line the display mode never reaches.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="206"></a>$206 = "vreg_vidpage"</span> - Video Page Access Control <br> <br>This register selects which 8KB page of Video RAM appears in the Video RAM<br>Access Window in Z80 address space (default location Z80 $2000-$3FFF). <br>It also determines which 4KB of sprite RAM is to accept writes through<br>the Sprite RAM access window (at Z80 $1000-$1fff).</pre>
<pre>&nbsp;When the register is written with bit 7 clear: Function is &#8220;set video page&#8221;.</pre>
<pre>&nbsp;&nbsp; 7 - Write as 0<br>&nbsp;&nbsp; 6 &#8211; Not used</pre>
<pre>&nbsp;5:0 - Video Page Selection (64 banks - 8KB each).</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (When Direct VRAM Write mode is active, bits 5:3 select the 64KB bank.)</pre>
<pre>&nbsp;<br>&nbsp;When the register is written with bit 7 set: Function is &#8220;Set sprite page&#8221;..</pre>
<pre>&nbsp;7&nbsp;&nbsp; - Write as 1<br>&nbsp;6:5 - Not used<br>&nbsp;4:0 &#8211; Sprite page selection (32 banks - 4KB each) when sprite RAM is paged in.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Note: Sprite RAM is write only)<br><br>Remember, the video and sprite access windows must be enabled with the port<br>sys_mem_select for data to be transferred from the relevant RAMs.<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;"><a name="207"></a>$207 = "vreg_sprctrl"</span> - Sprite Control </pre>
<pre>&nbsp;&nbsp;&nbsp; 7 - Not used, write with zero<br>&nbsp;&nbsp;&nbsp; 6 - &#8220;Fix colours low&#8221; - when set, only colours $00-$7f are used for sprites.<br>&nbsp;&nbsp;&nbsp; 5 - "Matte Mode Enable"&nbsp; *<br>&nbsp;&nbsp;&nbsp; 4 - "Modify Colour MSBs"&nbsp; *<br>&nbsp;&nbsp;&nbsp; 3 &#8211; Enable double buffer sprite register mode.<br>&nbsp;&nbsp;&nbsp; 2 &#8211; Register bank select (use with double buffer register mode) **<br>&nbsp;&nbsp;&nbsp; 1 - Priority Interleave: 0 = All sprites are in foreground. 1 = interleave mode<br>&nbsp;&nbsp;&nbsp; 0 - Global Sprite Enable. All sprites are disabled when this bit is 0</pre>
<pre><br>* These modes force the upper bits of individual sprite height control registers to be<br>reassigned, see the sprite description text above for details.</pre>
<pre>** Sprite Register Bank select bit:</pre>
<pre>&nbsp;0 - Sprite hardware reads sprite registers $400 - $4fd<br>&nbsp;1 - Sprite hardware reads sprite registers $500 - $5fd<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><span style="font-weight: bold;"><a name="208__209"></a>$208 / $209 = "mult_write"</span> - 16 bit multiplier: </pre>
<pre>The signed word written here is multiplied by the word in the multiply table indexed by the<br>following register. 16 bits (29:14) from the resulting 32-bit word are read from "mult_read"<br>(the set of bits was chosen to provide fast scaling.) </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><span style="font-weight: bold;"><a name="20A"></a>$20A = "mult_index"</span> - Maths table index (byte): </pre>
<pre>Selects which word from the look up table is used for the multiplication.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<span style="font-family: monospace;"><br>
</span>
<pre><br><span style="font-weight: bold;"><a name="20B"></a>$20B = "linedraw_colour"</span> - Line draw colour: </pre>
<pre><br>Colour table index for line draw hardware. (There is only a single colour register, so<br>to maintain a constant line colour, this value should not be changed whilst a line is<br>being drawn.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre></pre>
<pre><br><span style="font-weight: bold;"><a name="20c"></a>$20c = "vreg_ext_vidctrl"</span> - Extended Video Mode Control Bits</pre>
<pre>&nbsp;&nbsp; &nbsp;7:4 &#8211; n/u<br>&nbsp;&nbsp; &nbsp;&nbsp; 3 &#8211; Enable Hi-Res 16 colour TV mode (no effect in VGA mode)<br>&nbsp;&nbsp; &nbsp;&nbsp; 2 - Enable interlaced TV mode (no effect on VGA output)<br>&nbsp;&nbsp; &nbsp;&nbsp; 1 - Flip Dual Playfield priorities (1 = PF B appears behind PF A)<br>&nbsp;&nbsp; &nbsp;&nbsp; 0 - Use extended tile indexes (1 = on, 0 = "legacy" 8 bit tile indexes)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre></pre>
<pre><br><span style="font-weight: bold;"><a name="20d"></a>$20d = "vreg_linecop_lo"</span>- LineCop LSB and Enable </pre>
<pre>&nbsp;&nbsp; &nbsp;7:1 - Linecop program location bits: 7:1<br>&nbsp;&nbsp; &nbsp;&nbsp; 0 - LineCop on/off (1 = enable)</pre>

<pre><br><br><br><span style="font-weight: bold;"><a name="20e"></a>$20e = "vreg_linecop_hi"</span>- LineCop MSB </pre>
<pre><br>&nbsp;&nbsp; &nbsp;7:0 - Linecop program location bits 15:8</pre>
<pre>(Linecop programs must be located at $70000-$7FFFE in system RAM)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><span style="font-weight: bold;"><a name="20f"></a>$20f = "vreg_palette_ctrl"</span>- Palette Control </pre>
<pre>This register allows independent access to two palette control bits: The "live"<br>palette (ie: that currently being used by the video hardware to fetch the colours)<br>and the palette which receives CPU / LineCop writes. So that each setting can be<br>changed independently (without reads) the register uses a bit (1) to select which<br>register is to be accessed and a bit (0) for the data to be written:</pre>
<pre>&nbsp; 7:2 - Not used (write with zeroes)<br>&nbsp;&nbsp;&nbsp; 1 - Choose to update "Live Palette Reg" (0) or "Target Palette Reg" (1)<br>&nbsp;&nbsp;&nbsp; 0 - Select palette 0 or 1</pre>
<pre>Note: Changes to the live palette selection take effect at the start of the next<br>scanline, whereas changes to the target palette register take effect immediately.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="text-decoration: underline;"><br>Blitter set-up registers: $210 - $21a:</span><br></pre>
<pre><span style="font-weight: bold;"><a name="210"></a>$210 = "blit_src_loc" </span>- Source Address in VRAM Low 16 bits (little endian)<br><span style="font-weight: bold;"><a name="212"></a>$212 = "blit_dst_loc"</span> - Destination Address in VRAM Low 16 bits (little endian)<br><span style="font-weight: bold;"><a name="214"></a>$214 = "blit_src_mod"</span> - Source modulo [bits 7:0] **<br><span style="font-weight: bold;"><a name="215"></a>$215 = "blit_dst_mod"</span> - Destination modulo [bits 7:0] **<br><span style="font-weight: bold;"><a name="216"></a>$216 = "blit_height"</span>&nbsp; - Number of lines in blit - 1<br><span style="font-weight: bold;"><a name="217"></a>$217 = "blit_width"&nbsp;</span>&nbsp; - Width of blit in bytes - 1 [Write starts the blit]<br><span style="font-weight: bold;"><a name="218"></a>$218 = "blit_misc"</span>&nbsp;&nbsp;&nbsp; - Misc bits, see assignments below:</pre>
<pre><br>Bit&nbsp; 7 - Transparency mode: If 1 then zero value bytes read from source are not written.<br>&nbsp;&nbsp;&nbsp;&nbsp; 6 - Blit Direction: Ascending = 1 / Descending = 0 <br>&nbsp;&nbsp;&nbsp;&nbsp; 5 - Legacy destination Address MSb [bit 16] - see note below<br>&nbsp;&nbsp;&nbsp;&nbsp; 4 - Legacy source Address MSb [bit 16] - see note below<br>&nbsp;&nbsp;&nbsp;&nbsp; 3 - Destination Modulo bit 9 (Sign)<br>&nbsp;&nbsp;&nbsp;&nbsp; 2 - Destination Modulo bit 8<br>&nbsp;&nbsp;&nbsp;&nbsp; 1 - Source Modulo bit 9 (Sign)<br>&nbsp;&nbsp;&nbsp;&nbsp; 0 - Source Modulo bit 8</pre>
<pre>(blitter registers continued..)</pre>
<pre><br><span style="font-weight: bold;"><a name="219"></a>$219 = "blit_src_msb"</span> - 2:0 highest three bits [18:16] of source address #<br><span style="font-weight: bold;"><a name="21a"></a>$21a = "blit_dst_msb"</span> - 2:0 highest three bits [18:16] of destination address #</pre>
<pre><br># Bit 16 is internally OR'd with the equivalent bit in "blit_misc", this is</pre>
<pre>&nbsp; for backwards compatibility. If you are only accessing video addresses &lt; 128KB<br>&nbsp; you can just use the "blit_misc" and ignore these two registers. Conversely if<br>&nbsp; you are generally using the entire VRAM range its best to use these registers<br>&nbsp; and write the MSB bits in "blit_misc" with zeroes.</pre>
<pre>Writing to &#8220;blit_width&#8221; actually starts the blit operation. Remember, the height<br>and width values should be the blit dimensions less one.</pre>
<pre><br><span style="text-decoration: underline;">Blitter Notes:</span></pre>
<pre>Following a blit, all the registers except "Width" (which has to be re-written<br>anyway) retain the values originally written to them. Most of the blitter registers<br>can be changed once a blit is underway without problems, however the Modulos,<br>Width and Misc registers should not be updated until a blit is finished. </pre>
<pre>Be wary when leaving the blitter running and returning to other code &#8211; this is<br>of course perfectly fine as long as the other code does not go on to access the<br>blitter's registers before it has finished a blit. The blitter status flag (bit 4 in<br><a href="#Port:_07_-_Read">sys_vreg_read</a>) should be examined at relevant points to prevent clashing blitter ops.</pre>
<pre>** The modulo is the number of bytes added to the end of the source and destination<br>counters at the end of each line. The polarity of these values is reversed by the<br>blit direction. So if in descending mode, a negative modulo will result in a<br>positive offset.</pre>
<pre></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="text-decoration: underline;">Line Draw:</span><br><br>$220-$23f = Line draw set-up registers (all are 16 bit words)</pre>
<pre>The line draw system utilizes two main groups of registers: Control registers that<br>need to be set up for each line, and an overall look-up table that only needs to be<br>set up once on initialization.</pre>
<pre>The following four control words need to be set up for each line:</pre>
<pre><span style="font-weight: bold;"><a name="2201"></a>$220/1 = linedraw_reg0</span> - Bresenham decision=0 constant: 2 x (dy - dx) *<br><span style="font-weight: bold;"><a name="2223"></a>$222/3 = linedraw_reg1</span> - Bresenham decision=1 constant: 2 x (dy)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br><span style="font-weight: bold;"><a name="2245"></a>$224/5 = linedraw_reg2</span> - Video RAM start address of line (bits 15:0)<br><span style="font-weight: bold;"><a name="2267"></a>$226/7 = linedraw_reg3</span> - Composite word:<br> <br>Linedraw_reg3 breakdown:</pre>
<pre>Bit 15&nbsp;&nbsp;&nbsp; : (Legacy) MSB of line's VRAM start address [Bit 16] - See bits 11:9<br>&nbsp;&nbsp;&nbsp; 14:12 : Octant code (bit12: dx is negative, bit13: dy is negative, bit14: dy =&gt; dx *<br>&nbsp;&nbsp;&nbsp; 11:9&nbsp; : Line VRAM start address: Bits 18:16 (NB: bit9 is internally OR'd with bit 15)<br>&nbsp;&nbsp;&nbsp; 8:0&nbsp;&nbsp; : Line length</pre>
<pre><br>*&nbsp; 1. Registers should be written with positive values, the sign of the value is held<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the octant code.</pre>
<pre>&nbsp;&nbsp; 2. If bit 14 of the composite word is set (because dy =&gt; dx) then the Bresenham<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decision 0 register should be loaded with 2 x (dx - dy) and decision register<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; should be loaded with 2 x (dx)</pre>
<pre>&nbsp;Writing to (the LSB of) this register actually starts the line drawing operation, so<br> the line draw busy flag should be checked beforehand.<br> <br><br>The next 4 register addresses (8 bytes) have the same function as registers $220-$227,<br>however they address separate internal locations. Having two sets of line-draw registers<br>allows one set to be loaded whilst a previous line draw operation is still running.<br>(The line_draw busy flag in vreg_read only needs to be checked before writing to the<br>LSB of linedraw_reg3/7 (which starts the linedraw) or the linedraw_colour register,<br>if changing colour.</pre>
<pre><span style="font-weight: bold;"><a name="2289"></a>$228/9 = linedraw_reg4</span> - Same function as $220/1 for register set 2<br><span style="font-weight: bold;"><a name="22ab"></a>$22a/b = linedraw_reg5</span> - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "" $222/3 for register set 2<br><span style="font-weight: bold;"><a name="22cd"></a>$22c/d = linedraw_reg6</span> - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "" $224/5 for register set 2<br><span style="font-weight: bold;"><a name="22ef"></a>$22e/f = linedraw_reg7</span> - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "" $226/7 for register set 2</pre>
<pre>The following 8 words form a look-up table used to offset the plot address of each<br>pixel, hence these registers need only be set once as part of an initialization routine,<br>IE: not per line.</pre>
<pre><a name="2301"></a>$<span style="font-weight: bold;">230/1 = linedraw_lut0</span> - Pixel offset constant 0 .. (65536-Window width)+1 <br><span style="font-weight: bold;"><a name="2323"></a>$232/3 = linedraw_lut1</span> - Pixel offset constant 1 .. (65536-Window width)-1<br><span style="font-weight: bold;"><a name="2345"></a>$234/5 = linedraw_lut2</span> - Pixel offset constant 2 .. Window width + 1<br><span style="font-weight: bold;"><a name="2367"></a>$236/7 = linedraw_lut3</span> - Pixel offset constant 3 .. Window width - 1<br><span style="font-weight: bold;"><a name="2389"></a>$238/9 = linedraw_lut4</span> - Pixel offset constant 4 .. 1<br><span style="font-weight: bold;"><a name="23ab"></a>$23a/b = linedraw_lut5</span> - Pixel offset constant 5 .. 65535<br><span style="font-weight: bold;"><a name="23cd"></a>$23c/d = linedraw_lut6</span> - Pixel offset constant 6 .. (65536 - Window width)<br><span style="font-weight: bold;"><a name="23ef"></a>$23e/f = linedraw_lut7</span> - Pixel offset constant 7 .. Window width </pre>
<pre>(See also: Line colour register $20B - "linedraw_colour")</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre style="text-decoration: underline;">Bitplane location registers: $240 - $27f: </pre>
<pre><span style="font-weight: bold;"><a name="240"></a>$240 = bitplane0a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="244"></a>$244 = bitplane1a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="248"></a>$248 = bitplane2a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="24c"></a>$24c = bitplane3a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="250"></a>$250 = bitplane4a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="254"></a>$254 = bitplane5a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="258"></a>$258 = bitplane6a_loc</span> (BPl register set A)<br><span style="font-weight: bold;"><a name="25c"></a>$25c = bitplane7a_loc</span> (BPl register set A)</pre>
<pre><br><a name="260-27f"></a>$260-$27f = As above for Bitplane location register set B. Bit 5 of "vreg_vidctrl"<br>controls which set is used by the hardware to build the display.</pre>
<pre>Each bitplane location "register" is 4 bytes long, the data required for each is:</pre>
<pre>Offset:&nbsp; Data:<br>------------------------------------------------<br>+ 0&nbsp;&nbsp; =&nbsp; Location of Bitplane in video RAM [7:0]<br>+ 1&nbsp;&nbsp; =&nbsp; Location of Bitplane in video RAM [15:8]<br>+ 2&nbsp;&nbsp; =&nbsp; Location of Bitplane in video RAM [18:16]<br>+ 3&nbsp;&nbsp; =&nbsp; <a name="Reset_internal_offset"></a>Reset internal offset counter /<a name="Set_Modulo"></a> Set Modulo - see notes below</pre>
<pre><br>Notes:</pre>
<pre>The value written to the bitplane location registers only needs to be set once,<br>an internal offset counter is added to the address as the frame is built up. There is<br>only one offset counter which acts on all the bitplanes - it can be reset to zero by<br>writing to the 4th byte of the even-numbered bitplane pointers (eg: bitplane0a_loc+3)<br>this actually takes effect at the start of the next scanline. </pre>
<pre>In chunky pixel mode, there is only one data-fetch start address, that is: bitplane0a/b</pre>
<pre><br><span style="text-decoration: underline;">Modulo:</span><br><br>The modulo register holds the number of words to skip at the right of each<br>scanline (positive only). This allows a window from within a larger image to be<br>displayed (EG: can be used for scrolling and skipping lines in interlaced displays).<br>There is one modulo register, it is located at the 4th byte of the odd-numbered<br>bitplane registers (EG: bitplane1a+3) - as mentioned, the granularity is 2 bytes<br>so for example a written value of 1 skips 2 bytes each line. The value in this<br>register is internally latched at the start of each scanline and because of the<br>way it is implemented there is an upper limit on the value it can hold (depends<br>on the display mode) - values up to 192 (IE: skip 384 bytes) are OK. There is<br>also a special case: If $FF is written to the modulo register the bitmap offset<br>counter is reset at the start of each scanline, IE: With no other changes, the<br>same line is used over and over.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="text-decoration: underline;">Sprite priority mask registers <a name="280_-_28F"></a>$280 - $28F: <span style="font-weight: bold;">"priority_registers"</span></span></pre>
<pre>$280: Bit 0: bgnd colours 00-0F mask level 0, Bit 1: bgnd colours 00-0F mask level 1<br>$281: Bit 0: bgnd colours 10-1F mask level 0, Bit 1: bgnd colours 10-1F mask level 1<br>$282: Bit 0: bgnd colours 20-2F mask level 0, Bit 1: bgnd colours 20-2F mask level 1<br>$283: Bit 0: bgnd colours 30-3F mask level 0, Bit 1: bgnd colours 30-3F mask level 1<br>$284: Bit 0: bgnd colours 40-4F mask level 0, Bit 1: bgnd colours 40-4F mask level 1<br>$285: Bit 0: bgnd colours 50-5F mask level 0, Bit 1: bgnd colours 50-5F mask level 1<br>$286: Bit 0: bgnd colours 60-6F mask level 0, Bit 1: bgnd colours 60-6F mask level 1<br>$287: Bit 0: bgnd colours 70-7F mask level 0, Bit 1: bgnd colours 70-7F mask level 1<br>$288: Bit 0: bgnd colours 80-8F mask level 0, Bit 1: bgnd colours 80-8F mask level 1<br>$289: Bit 0: bgnd colours 90-9F mask level 0, Bit 1: bgnd colours 90-9F mask level 1<br>$28A: Bit 0: bgnd colours A0-AF mask level 0, Bit 1: bgnd colours A0-AF mask level 1<br>$28B: Bit 0: bgnd colours B0-BF mask level 0, Bit 1: bgnd colours B0-BF mask level 1<br>$28C: Bit 0: bgnd colours C0-CF mask level 0, Bit 1: bgnd colours C0-CF mask level 1<br>$28D: Bit 0: bgnd colours D0-DF mask level 0, Bit 1: bgnd colours D0-DF mask level 1<br>$28E: Bit 0: bgnd colours E0-EF mask level 0, Bit 1: bgnd colours E0-EF mask level 1<br>$28F: Bit 0: bgnd colours F0-FF mask level 0, Bit 1: bgnd colours F0-FF mask level 1<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><span style="text-decoration: underline;">Maths Assist Table:</span><br><br>$600-$7FF = "<a name="mult_table"></a><span style="font-weight: bold;">mult_table</span>" WRITE ONLY </pre>
<pre>This table holds 256 signed 16 bit words. The entry selected by "mult_index" is<br>multiplied by the signed word in "mult_write" and 16 bits [29:14] of the 32 bit<br>result appears in "mult_read"</pre>
<pre><br><a name="700"></a>$700 = "<span style="font-weight: bold;">vreg_read</span>" - READ ONLY Status Register (Also available in port: <a href="#Port:_07_-_Read">sys_vreg_read</a>)</pre>
<pre>&nbsp;&nbsp; 7 - Interlace field 0 = short field, 1 = long field <br>&nbsp;&nbsp; 6 - LSB of scanline count<br>&nbsp;&nbsp; 5 - 60Hz mode (1 = NTSC config / VGA mode jumper installed and 50Hz not forced.)<br>&nbsp;&nbsp; 4 - Blitter / linedraw status (1 = busy). Check before changing relevant registers <br>&nbsp;&nbsp; 3 - Raster IRQ status (for manual polling)<br>&nbsp;&nbsp; 2 - Y Window (1 = display area, 0 = border)<br>&nbsp;&nbsp; 1 - X Window&nbsp; (1 = display area, 0 = border) *<br>&nbsp;&nbsp; 0 - Last line (VRT). Set during the last line of each frame.</pre>
<pre>* Remember, in VGA mode each scanline's data is output twice at double the normal frequency.<br>This flag reflects the x-window of the normal PAL/NTSC ~15KHz scanline.<br><br><br><a name="704-705"></a>$704-705 = "<span style="font-weight: bold;">mult_read</span>" READ ONLY - Maths unit result (little endian): </pre>
<pre>Bits 29:14 from the longword result of the maths unit operation appear here.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3><span style="text-decoration: underline;"><a name="OSCAs_ROM"></a>OSCA's
ROM</span> </h3>
<pre>OSCA locates a boot ROM at $0000-$01FF - this is contained within the FPGA config<br>file.&nbsp; At reset, the ROM clears the following ports and video registers:<br><br><a href="#Port:_00">sys_mem_select</a><br><a href="#Port_0B">sys_alt_write_page</a><br><a href="#Port_20">sys_low_page</a><br><a href="#Port_01_-_Write">sys_irq_enable</a><br><a href="#Port:_08_-_Write">sys_audio_enable</a><br><a href="#Port:_03_-_Write">sys_ps2_joy_control</a><br><a href="#Port_21_-_Write">sys_vram_location</a><br><a href="#Port:_07_-_Write">sys_timer</a><br><a href="#207">vreg_sprctrl</a> <br><a href="#Colour_palette">palette</a> (IE: background colour = $000)<br><br>All interrupts are disabled (IRQs via the Z80 DI instruction and NMIs via <br>bit 0 of sys_hw_settings). The IRQ vector (at $0038) has the instruction<br>"JP $0A00", and the NMI vector (at $0066) has the instruction "JP $0A03".<br>OSCA is designed to use Interrupt Mode 1. <br><br>The ROM then attempts to load the main boot code from the onboard EEPROM.<br>Two locations are checked:<br><br>EEPROM Block 0: $F000 [Primary bootcode location]<br>EEPROM Block 1: $F000 [Backup bootcode location]<br><br>To test for bootcode, a "databurst" command is sent to a PIC microcontroller<br>which responds by sending 3520 bytes from the EEPROM. The ROM reads this data<br>into system RAM $0200 onwards, checks the CRC checksum (held in the last two<br>bytes) and executes it (with a JP $200) if the checksum is good.<br><br> (If the CRC doesn't match, the screen flashes magenta and the databurst is requested<br> again from the backup. If this also fails, the screen goes grey indicating that a<br> bootcode file should be downloaded via the serial link at 115KBPS. This grey screen<br> condition can also be forced by holding up, right and fire on a joystick in port 2 <br> at power up. If at any point the screen flashes yellow, there was a time-out during<br> the EEPROM databurst.)<br><br> <br><span style="text-decoration: underline;">Placing alternate data at $0000-$01FF:</span><br><br>It is possible to have read/write access the system RAM "underneath" the OSCA<br>ROM/Palette at $000-$1ff (see the port "<a href="#Port_0B">sys_alt_write_page</a>"). In all there are<br>three options for this memory range:<br><br>A) Read ROM / Write palette (default)<br>B) Read system RAM / write palette (set by bit 4 of <a href="#Port_0B">sys_alt_write_page</a>)<br>c) Read System RAM / write system RAM (set by bit 6 of <a href="#Port_0B">sys_alt_write_page</a>)<br><br>The IRQ vectors must be set appropriately in system RAM when non-ROM reads are<br>enabled (and interrupts are required).<br><span style="font-weight: bold;"><br><br></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"></span></pre>
<h1>INDEX:</h1>
<h3 style="text-decoration: underline;"><a name="Port_List:"></a>Port List:</h3>
<pre>(All ports are 8 bit unless stated)<span style="text-decoration: underline;"><br><br>Port: Dir: Name:</span><br> <br><a href="#Port:_00">$00</a> R/W <a href="#Port:_00">sys_mem_select</a><br><a href="#Port:_01_-_Read">$01</a> R <a href="#Port:_01_-_Read">sys_irq_ps2_flags</a><br><a href="#Port_01_-_Write">$01</a> W <a href="#Port_01_-_Write">sys_irq_enable</a><br><a href="#Port:_02_-_Read">$02</a> R <a href="#Port:_02_-_Read">sys_keyboard_data</a><br><a href="#Port:_02_-_Write">$02</a> W <a href="#Port:_02_-_Write">sys_clear_irq_flags</a><br><a href="#Port:_03_-_Read">$03</a> R <a href="#Port:_03_-_Read">sys_mouse_data</a><br><a href="#Port:_03_-_Write">$03</a> W <a href="#Port:_03_-_Write">sys_ps2_joy_control</a><br><a href="#Port_04">$04</a> R/W <a href="#Port_04">sys_serial_port</a><br><a href="#Port_05_-_Read">$05</a> R <a href="#Port_05_-_Read">sys_joy_com_flags</a><br><a href="#Port_05_-_Write">$05</a> W <a href="#Port_05_-_Write">sys_sdcard_ctrl1</a> <br><a href="#Port_06">$06</a> R/W <a href="#Port_06">sys_sdcard_ctrl2</a> <br><a href="#Port:_07_-_Read">$07</a> R <a href="#Port:_07_-_Read">sys_vreg_read</a><br><a href="#Port:_07_-_Write">$07</a> W <a href="#Port:_07_-_Write">sys_timer </a><br><a href="#Port:_08_-_Read">$08</a> R <a href="#Port:_08_-_Read">sys_audio_flags</a><br><a href="#Port:_08_-_Write">$08</a> W <a href="#Port:_08_-_Write">sys_audio_enable</a><br><a href="#Port_09_-_Read">$09</a> R <a href="#Port_09_-_Read">sys_hw_flags</a> <br><a href="#Port_09_-_Write">$09</a> W <a href="#Port_09_-_Write">sys_hw_settings </a><br><a href="#Port_0A">$0a</a> R/W <a href="#Port_0A">sys_spi_port</a> <br><a href="#Port_0B">$0b</a> R/W <a href="#Port_0B">sys_alt_write_page</a><br><a href="#Port_0C_-_Write">$0c</a> W <a href="#Port_0C_-_Write">sys_baud_rate</a> <br><a href="#Port_0D_-_Read">$0d</a> R <a href="#Port_0D_-_Read">sys_eeprom_byte</a> <br><a href="#Port_0D_-_Write">$0d</a> W <a href="#Port_0D_-_Write">sys_pic_comms </a><br><a href="#Port_0E">$0e</a> R/W <a href="#Port_0E">sys_io_pins</a> <br><a href="#Port_0F_-_Read">$0f</a> R/W <a href="#Port_0F_-_Read">sys_io_dir </a><br><br><a href="#Port_10">$10</a> W <a href="#Port_10">audchan0_loc</a> (16 bit)<br><a href="#Port_11">$11</a> W <a href="#Port_11">audchan0_len</a> (16 bit) <br><a href="#Port_12">$12</a> W <a href="#Port_12">audchan0_per</a> (16 bit)<br><a href="#Port_13">$13</a> W <a href="#Port_13">audchan0_vol</a><br><a href="#14-17">$14</a> W <a href="#14-17">audchan1_loc</a> (16 bit)<br><a href="#14-17">$15</a> W <a href="#14-17">audchan1_len</a> (16 bit)<br><a href="#14-17">$16</a> W <a href="#14-17">audchan1_per</a> (16 bit)<br><a href="#14-17">$17</a> W <a href="#14-17">audchan1_vol</a><br><a href="#18-1b">$18</a> W <a href="#14-17">audchan2_loc</a> (16 bit)<br><a href="#18-1b">$19</a> W <a href="#14-17">audchan2_len</a> (16 bit)<br><a href="#18-1b">$1a</a> W <a href="#14-17">audchan2_per</a> (16 bit)<br><a href="#18-1b">$1b</a> W <a href="#14-17">audchan2_vol</a><br><a href="#1c-1f">$1c</a> W <a href="#14-17">audchan3_loc</a> (16 bit)<br><a href="#1c-1f">$1d</a> W <a href="#14-17">audchan3_len</a> (16 bit)<br><a href="#1c-1f">$1e</a> W <a href="#14-17">audchan3_per</a> (16 bit)<br><a href="#1c-1f">$1f</a> W <a href="#14-17">audchan3_vol</a><br><br><a href="#Port_20">$20</a> R/W <a href="#Port_20">sys_low_page</a> <br><a href="#Port_21_%3F_Read">$21</a> R/W <a href="#Port_21_%3F_Read">sys_vram_location</a><br><a href="#Port_22">$22</a> W <a href="#Port_22">sys_audio_panning </a><br><br><a href="#Port_24">$24</a> W <a href="#Port_24">audchan0_loc_hi</a><br><a href="#Port_25">$25</a> W <a href="#Port_25">audchan1_loc_hi</a><br><a href="#Port_26">$26</a> W <a href="#Port_26">audchan2_loc_hi</a><br><a href="#Port_27">$27</a> W <a href="#Port_27">audchan3_loc_hi</a><br><br><br></pre>
<h3 style="text-decoration: underline;"><a name="Video_Register_List:"></a>Video Register
List:</h3>
<pre>($000-$6FF are write only registers)<br><br><br><span style="text-decoration: underline;">Addr:   Name:      Size (bits):</span><br><br><a href="#Colour_palette">$0000 palette</a>         256 * 16 <br><br><a href="#200">$0200 vreg_xhws</a>          8<br><a href="#201">$0201 vreg_vidctrl</a>       8<br><a href="#202">$0202 vreg_window </a>       8<br><a href="#203">$0203 vreg_yhws_bplcount</a> 8<br><a href="#204">$0204 vreg_rasthi</a>        8<br><a href="#205">$0205 vreg_rastlo</a>        8<br><a href="#206">$0206 vreg_vidpage </a>      8<br><a href="#207">$0207 vreg_sprctrl </a>      8<br><a href="#208__209">$0208 mult_write</a>         8<br><a href="#20A">$020a mult_index </a>        8 <br><a href="#20B">$020b linedraw_colour</a>    8<br><a href="#20c">$020c vreg_ext_vidctrl</a>   8<br><a href="#20d">$020d vreg_linecop_lo </a>   8<br><a href="#20e">$020e vreg_linecop_hi </a>   8<br><a href="#20f">$020f vreg_palette_ctrl</a>  8<br><br><a href="#210">$0210 blit_src_loc</a>       16<br><a href="#212">$0212 blit_dst_loc</a>       16<br><a href="#214">$0214 blit_src_mod</a>       8<br><a href="#215">$0215 blit_dst_mod</a>       8<br><a href="#216">$0216 blit_height</a>        8<br><a href="#217">$0217 blit_width</a>         8<br><a href="#218">$0218 blit_misc</a>          8 <br><a href="#219">$0219 blit_src_msb</a>       8<br><a href="#21a">$021a blit_dst_msb</a>       8<br><br><a href="#2201">$0220 linedraw_reg0</a>     16<br><a href="#2245">$0222 linedraw_reg1 </a>    16<br><a href="#2245">$0224 linedraw_reg2</a>     16<br><a href="#2267">$0226 linedraw_reg3</a>     16<br><a href="#2289">$0228 linedraw_reg4</a>     16<br><a href="#22ab">$022a linedraw_reg5 </a>    16<br><a href="#22cd">$022c linedraw_reg6 </a>    16<br><a href="#22ef">$022e linedraw_reg7</a>     16<br><br><a href="#2301">$0230 linedraw_lut0</a>     16<br><a href="#2323">$0232 linedraw_lut1 </a>    16<br><a href="#2345">$0234 linedraw_lut2</a>     16<br><a href="#2367">$0236 linedraw_lut3</a>     16<br><a href="#2389">$0238 linedraw_lut4</a>     16<br><a href="#23ab">$023a linedraw_lut5 </a>    16<br><a href="#23cd">$023c linedraw_lut6 </a>    16<br><a href="#23ef">$023e linedraw_lut7 </a>    16<br><br><a href="#240">$0240 bitplane0a_loc</a>    24<br><a href="#Reset_internal_offset">$0243 bitplane_reset</a>    8<br><a href="#244">$0244 bitplane1a_loc </a>   24<br><a href="#Set_Modulo">$0247 bitplane_modulo</a>   8<br><a href="#248">$0248 bitplane2a_loc</a>    24<br><a href="#24c">$024c bitplane3a_loc </a>   24<br><a href="#250">$0250 bitplane4a_loc</a>    24<br><a href="#254">$0254 bitplane5a_loc </a>   24<br><a href="#258">$0258 bitplane6a_loc </a>   24<br><a href="#25c">$025c bitplane7a_loc</a>    24<br><br><a href="#260-27f">$0260 bitplane0b_loc</a>    24<br><a href="#260-27f">$0264 bitplane1b_loc </a>   24<br><a href="#260-27f">$0268 bitplane2b_loc </a>   24<br><a href="#260-27f">$026c bitplane3b_loc </a>   24<br><a href="#260-27f">$0270 bitplane4b_loc</a>    24<br><a href="#260-27f">$0274 bitplane5b_loc </a>   24<br><a href="#260-27f">$0278 bitplane6b_loc</a>    24<br><a href="#260-27f">$027C bitplane7b_loc</a>    24<br><br><a href="#280_-_28F">$0280 priority_registers</a>  16 * 8<br><br><a href="#Sprite_Control_Registers">$0400 sprite_registers</a>   128 * 32<br><br><a href="#Hardware_Maths_Assist_%3F_multiply__scale">$0600 mult_table</a>         256 * 16<br><br><a href="#700">$0700 8 vreg_read </a>      8 (read only)<br><a href="#704-705">$0704 8 mult_read </a>     16 (read only)<br><br><span style="text-decoration: underline;"></span><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><br>[END]</pre>
</body></html>