<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>OSCA_Hardware_Manual</title></head>
<body>
<h1 style="text-decoration: underline;">OSCA - An FPGA
Config For The V6Z80P</h1>
<pre style="font-style: italic;">By Phil Ruston 2008-2012 - Last updated 05-09-2012 (OSCA v672)</pre>
<pre><br>OSCA (Old School Computer Architecture) provides a home-computer era hardware platform for<br>the V6Z80P. As well as basic memory and peripheral control, its features include bitmap and<br>character mapped displays, sprites, a raster line synchronized co-pro ("LineCop"), blitter,<br>hardware line draw and four channels of 8 bit digital sound.<br></pre>
<pre style="text-decoration: underline;"><br>Hardware Control:</pre>
<pre>In OSCA, memory and peripheral controls are accessed via the Z80's In/Out Ports. Video<br>settings such as the palette, display controls, sprite registers etc are accessed via<br>locations in Z80 address space (these can be paged in and out as desired). Sections of<br>Z80 address space are also assigned to video RAM etc.<br></pre>
<pre style="text-decoration: underline;"><br>Z80 Address Space Overview:</pre>
<pre>As the V6Z80P has 512KB of system RAM (and the Z80 can only see 64KB at a time), OSCA<br>allows the user to select the sections of System RAM that appear in Z80 address space.<br>The page size is 32KB and both the lower and upper halves of the Z80 address space can<br>be assigned different pages of system RAM. In addition, the upper memory area can direct<br>CPU writes to an alternative page, making data copying quicker and easier.</pre>
<pre>Depending on the memory control settings, certain sections of Z80 address space<br>will - instead of system RAM - access components such as video/sprite memory, the video<br>palette etc. <br><br><span style="text-decoration: underline;">Diagram of Z80 Address space options under OSCA (not to scale):</span></pre>
<pre><img style="width: 798px; height: 997px;" alt="Memory Map Diagram" src="images/memory_map.png"><br><br><span style="text-decoration: underline;"><br>Address Space 'Partitions':</span><br><br>$0000-$07FF: First 2KB section of the Lower RAM Page or ROM, Palette, Video Registers,<br>             Sprite Control Registers, Maths Table (see detail below)</pre>
<pre>$0800-$0FFF: The next 2KB Section of the lower RAM page (Note: OSCA's default ROM code<br>             stipulates that IRQ Mode 1 vector jumps to $A00, and NMI vector jumps to $A03)<br><br>$1000-$1FFF: The next 4KB Section of the lower RAM page or a write-only 4KB page of<br>             sprite definition RAM (note: Reads between $1000-$1fff always fetch data<br>             from System RAM).</pre>
<pre>$2000-$7FFF: The remaining 24KB Section of the lower RAM page</pre>
<pre>$8000-$FFFF: 32KB Upper System RAM page</pre>
<pre><br><span style="font-weight: bold;">Video RAM:</span> A user-selected 8KB section of Z80 address space can be used for CPU access to<br>video RAM (also, a special write-only mode allows the entire 64KB of Z80 address space to<br>access video RAM if desired).</pre>

<pre><span style="font-weight: bold;"></span><span style="font-weight: bold;">LineCop RAM:</span> This is just a subsection of system RAM (the 64KB at $70000-$7FFFF) and is<br>accessed by paging the two 32KB sections of it into Z80 address space. This area of system<br>RAM is treated the same as any other by the CPU. IE: it is not exclusive to the LineCop system.</pre>
<pre><br><span style="text-decoration: underline;">Paged RAM areas in Detail:</span></pre>
<pre><span style="font-weight: bold;">System Memory:</span> The 32KB chunk of system RAM that appears to the Z80 at $0000-$7FFF is set<br>with the port "sys_low_page". The 32KB of system RAM that appears to the Z80 at $8000-$FFFF<br>is set with the port "sys_mem_select"</pre>
<pre><br>Writing to Z80 address space between $0000 - $07FF:</pre>
<pre>&nbsp;$0000 - $01FF: Write only Video Colour Palette or 512 bytes of system RAM*<br>&nbsp;$0200 - $03FF: Write only Video Control Registers or 512 bytes of system RAM* <br>&nbsp;$0400 - $05FF: Write only Sprite Control Registers or 512 bytes of system RAM*<br>&nbsp;$0600 - $07FF: Write only Maths Table or 512 bytes of system RAM*</pre>
<pre><br>Reading from Z80 address space between $0000 - $07FF:</pre>
<pre>&nbsp;$000 - $1FF: 512 byte boot ROM (contained in the FPGA) or 512 bytes of system RAM*<br>&nbsp;$200 - $6FF: 1280 Bytes of System RAM<br>&nbsp;$700 - $7FF: Video Status Register and Maths unit result or 256 bytes of system RAM*</pre>
<pre>* Bits in the port &#8220;sys_alt_write_page&#8221; control whether the ROM and hardware registers<br>&nbsp; or system RAM appears in locations $0000-$07ff. The default scheme (IE: when the<br>&nbsp; port sys_alt_write_page is clear) is:<br><br>&nbsp;&nbsp; $000-$1ff: Write palette but read from ROM<br>&nbsp;&nbsp; $200-$6ff: Write video registers but read from System RAM<br>&nbsp;&nbsp; $700-$7ff: Write video registers but read only the video status register and maths result.</pre>
<pre><br><span style="font-weight: bold;">Video Memory:</span> Video memory is normally accessed by the CPU through an 8KB window in Z80<br>address space. The window can be located at $2000 (default),$4000,$6000,$8000,$A000,$C000<br>or $E000. The location of this window is set with the port "sys_vram_location" and the<br>8KB section of Video RAM that the window 'contains' is set with the video register<br>"vreg_vidpage"</pre>
<pre>Direct Video Write Mode allows a 64KB page of video RAM to occupy the entire Z80 address<br>space. This mode overrides all other paging options and forces memory <span style="font-weight: bold;">WRITES</span> from the CPU<br>to video RAM at the page selected with bits [5:3] of &#8220;vreg_vidpage&#8221;). The CPU still reads<br>data from ordinary system RAM (so that program code is always accessible). Because devoting<br>the entire 64KB of Z80 address space to video RAM severely limits the CPU (calls, stack<br>ops, IRQs, system variables etc are not possible) there is the option of excluding the first<br>4KB of Z80 address space from Direct Video Write Mode (see bit 6 of "sys_mem_select") - this<br>allows access to the video registers and 2KB of system RAM at the cost of losing access to<br>the first 4KB of each 64KB video page.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><span style="text-decoration: underline;">IO
Ports:</span></h3>
<pre>$00-$2F: System Control / Peripheral / Audio Ports:</pre>
<pre>These port locations are mainly both readable and writeable. However, the read (IN) functions<br>can differ from the write (OUT) functions &#8211; see the individual port descriptions for details.<br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br>Port: $00 - Read / Write: <span style="font-weight: bold;">"sys_mem_select</span>"</pre>
<pre>Bit 0:3 - Upper 32KB memory page select (see table below)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 - Use alternate page for upper memory writes **<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 - Set Direct Video Write Mode (All Z80 address space memory writes go to VRAM).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 - Page in Video RAM at selected location (In DVW Mode: 1 = exclude $0000-$0FFF).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 - Page Sprite RAM in at $1000-$1FFF for writes (Ignored in DVW Mode)</pre>
<pre>&nbsp;</pre>
<pre>System RAM Upper Page Selection Table:</pre>
<pre>Bits:&nbsp;&nbsp; &nbsp;3 2 1 0&nbsp;&nbsp;&nbsp; Bank&nbsp;&nbsp;&nbsp;&nbsp; Area of System RAM paged into Z80 $8000-$FFFF<br>--------------------------------------------------------------------------</pre>
<pre>&nbsp;&nbsp; &nbsp;0 0 0 0&nbsp; =&nbsp; 1&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $08000 - $0FFFF #<br>&nbsp;&nbsp; &nbsp;0 0 0 1&nbsp; =&nbsp; 1&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $08000 - $0FFFF #<br>&nbsp;&nbsp; &nbsp;0 0 1 0&nbsp; =&nbsp; 2&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $10000 - $17FFF<br>&nbsp;&nbsp; &nbsp;0 0 1 1&nbsp; =&nbsp; 3&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $18000 - $1FFFF<br>&nbsp;&nbsp; &nbsp;0 1 0 0&nbsp; =&nbsp; 4&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $20000 - $27FFF <br>&nbsp;&nbsp; &nbsp;0 1 0 1&nbsp; =&nbsp; 5&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $28000 - $2FFFF <br>&nbsp;&nbsp; &nbsp;0 1 1 0&nbsp; =&nbsp; 6&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $30000 - $37FFF <br>&nbsp;&nbsp; &nbsp;0 1 1 1&nbsp; =&nbsp; 7&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $38000 - $3FFFF <br>&nbsp;&nbsp; &nbsp;1 0 0 0&nbsp; =&nbsp; 8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $40000 - $47FFF <br>&nbsp;&nbsp; &nbsp;1 0 0 1&nbsp; =&nbsp; 9&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $48000 - $4FFFF <br>&nbsp;&nbsp; &nbsp;1 0 1 0&nbsp; =&nbsp; A&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $50000 - $57FFF<br>&nbsp;&nbsp; &nbsp;1 0 1 1&nbsp; =&nbsp; B&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $58000 - $5FFFF<br>&nbsp;&nbsp; &nbsp;1 1 0 0&nbsp; =&nbsp; C&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $60000 - $67FFF <br>&nbsp;&nbsp; &nbsp;1 1 0 1&nbsp; =&nbsp; D&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $68000 - $6FFFF<br>&nbsp;&nbsp; &nbsp;1 1 1 0&nbsp; =&nbsp; E&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $70000 - $77FFF / LineCop program area ($0000 - $7fff)*<br>&nbsp;&nbsp; &nbsp;1 1 1 1&nbsp; =&nbsp; F&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IE: $78000 - $7FFFF / LineCop program area ($8000 - $ffff)*</pre>
<pre><br>Notes: </pre>
<pre># Notice 0000 and 0001 normally both select bank 1, this normally prevents system RAM<br>&nbsp; locations $00000-$07FFF being paged into the upper memory area. However, it<br>&nbsp; is possible to override this prohibition by setting the &#8220;Any Page Mode&#8221; bit<br>&nbsp; (bit 5 of port &#8220;sys_alt_write_page&#8221;) - selection 0000 will then select bank 0.</pre>
<pre>* The memory areas where sample data for the sound system and Linecop programs<br>&nbsp; need to be placed are normal system memory locations as far as the CPU is concerned.</pre>
<pre>  When bit 4 (Alternate Write Page) is set, the UPPER 32KB page selection DURING<br>  CPU WRITES is taken from Port $0B (sys_alt_write_page).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br>Port: $01 - Read: "<span style="font-weight: bold;">sys_irq_ps2_flags</span>" - Interrupt status flags and PS2 port line status: </pre>
<pre>Bit 0 - Keyboard IRQ flag (1 = interrupt occurred)<br>&nbsp;&nbsp;&nbsp; 1 - Mouse IRQ flag ("")<br>&nbsp;&nbsp;&nbsp; 2 - Timer IRQ flag ("")<br>&nbsp;&nbsp;&nbsp; 3 - Video IRQ flag ("")<br>&nbsp;&nbsp;&nbsp; 4 - Keyboard Clock line status (input)<br>&nbsp;&nbsp;&nbsp; 5 - Keyboard Data line status (input)<br>&nbsp;&nbsp;&nbsp; 6 - Mouse Clock status (input)<br>&nbsp;&nbsp;&nbsp; 7 - Mouse Data status (input)<br><br></pre>
<pre>Port $01 - Write: "<span style="font-weight: bold;">sys_irq_enable</span>"</pre>
<pre>Interrupt masks: Allow devices to interrupt CPU. (Note: The video IRQ enable bit is<br>in the video register vreg_rasthi)</pre>
<pre>Bit 0 - Keyboard IRQ enable (1 = allow interrupt)</pre>
<pre>&nbsp;&nbsp;&nbsp; 1 - Mouse IRQ enable ("")<br>&nbsp;&nbsp;&nbsp; 2 - Timer IRQ enable ("")<br>&nbsp;&nbsp;&nbsp; 3 - Audio IRQ enable ("")<br>&nbsp;&nbsp;&nbsp; 4 - n/u<br>&nbsp;&nbsp;&nbsp; 5 - n/u<br>&nbsp;&nbsp;&nbsp; 6 - n/u<br>&nbsp;&nbsp;&nbsp; 7 - Master IRQ enable (must be set to allow ANY interrupt to occur)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br>Port: $02 - Read:&nbsp; "<span style="font-weight: bold;">sys_keyboard_data</span>"<br><br>&nbsp;&nbsp;&nbsp; 0:7 - Data byte received from keyboard<br><br><br>Port: $02 - Write: "<span style="font-weight: bold;">Sys_Clear_IRQ_flags</span>"</pre>
<pre>(Bits written with ones clear the relevant IRQ flag)</pre>
<pre>Bit 0 - Clear Keyboard IRQ<br>&nbsp;&nbsp;&nbsp; 1 - Clear Mouse IRQ<br>&nbsp;&nbsp;&nbsp; 2 - Clear Timer IRQ<br>&nbsp;&nbsp;&nbsp; 3 - n/u<br>&nbsp;&nbsp;&nbsp; 4 - Clear Audio Channel 0 Loop IRQ Flag<br>&nbsp;&nbsp;&nbsp; 5 - Clear Audio Channel 1 Loop IRQ Flag<br>&nbsp;&nbsp;&nbsp; 6 - Clear Audio Channel 2 Loop IRQ Flag<br>&nbsp;&nbsp;&nbsp; 7 - Clear Audio Channel 3 Loop IRQ Flag</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><span style="font-family: monospace;"><br>
</span>
<pre>Port: $03 - Read: "<span style="font-weight: bold;">sys_mouse_data</span>"</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:7 - Data byte received from mouse</pre>
<pre><br>Port: $03 - Write: "<span style="font-weight: bold;">Sys_PS2_Joy_control</span>"</pre>
<pre>Bit: 0 - Joystick port 0/1 select - determines which port is active.<br>	1 - n/u<br>	2 - n/u<br>	3 - n/u<br>	4 - Keyboard Clock Control output - (Set to 1 to PULL DOWN the signal)<br>	5 - Keyboard Data Control output - ("")<br>	6 - Mouse Clock Control output - ("")<br>	7 - Mouse Data Control output - ("")</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br>Port $04 - Read/write: "<span style="font-weight: bold;">sys_serial_port</span>"</pre>
<pre>Incoming or outgoing data byte for RS232 com port</pre>
<pre>Note: Reading clears the "serial byte received" flag (bit 6 in Port $05)</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre>Port $05 - Read:&nbsp; "<span style="font-weight: bold;">sys_joy_com_flags</span>" - Joystick inputs and RS232 status</pre>
<pre>Bit:    0 - Up<br>	1 - Down<br>	2 - Left<br>	3 - Right<br>	4 - Fire 1<br>	5 - Fire 2<br>	6 - RS232 Byte received<br>	7 - RS232 Output Buffer Busy</pre>

<pre><br>Port $05 - Write: "<span style="font-weight: bold;">sys_sdcard_ctrl1</span>"<br><br>Bit:&nbsp;&nbsp; &nbsp;0:5 - n/u <br>	  6 - Enable FPGA to SD card data output<br>          7 - SD card port's SPI speed: 0 = 250KHz, 1 = 8MHz</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre>Port $06 - Read/Write: "<span style="font-weight: bold;">sys_sdcard_ctrl2</span>"</pre>
<pre>Bit:    0:1 - n/u (ignore / mask these bits when reading. No write function.)<br>	  2 &#8211; Read/Write SD card /CS line (active low)<br>	  3 &#8211; Read/Write SD card /Power control (active low)<br>	4:7 - n/u&nbsp; (ignore / mask off these bits when reading. No write function.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre>Port: $07 - Read: &#8220;<span style="font-weight: bold;">sys_vreg_read</span>&#8221; - Video status register (same as address $700)</pre>
<pre>Bit:    7 - Interlace field 0 = short field, 1 = long field <br>	6 - LSB of scanline count<br>	5 - 60Hz mode (1 = NTSC config / VGA mode jumper installed and 50Hz not forced.)<br>	4 - Blitter / linedraw status (1 = busy) check before changing relevant registers <br>	3 - Raster IRQ status (for manual polling)<br>	2 - Y Window (1 = display area, 0 = border)<br>	1 - X Window&nbsp; (1 = display area, 0 = border) *<br>	0 - Last line (VRT). Reads as one during the last line of each frame.</pre>
<pre><br>* Remember, in VGA mode each scanline's data is output twice at double the normal frequency.<br>This flag reflects the x-window of the normal PAL/NTSC ~15KHz scanline.</pre>
<pre><br>Port: $07 - Write: "sys_timer" - The timer internally counts *upwards* from this value<br>            at 62.5KHz (ie: every 256 clock ticks) when it overflows, it sets the timer<br>            IRQ flag, then reloads the count from the value that was written here.</pre>
<pre><br>Note: Writing to this port immediately sets the timer to the written value and clears<br>the internal prescaler count. </pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br>Port: $08 - Read: <span style="font-weight: bold;">Sys_Audio_Flags</span></pre>
<pre>Bit:&nbsp;&nbsp; &nbsp;0 - Channel 0 is playing<br>	1 - Channel 1 is playing<br>	2 - Channel 2 is playing<br>	3 - Channel 3 is playing<br>	4 - Channel 0 has looped (IE: internal length countdown has reached 0)<br>	5 - Channel 1 has looped (use bits 7:4 of port 2 to clear these flags)<br>	6 - Channel 2 has looped ("")<br>	7 - Channel 3 has looped ("")</pre>
<pre><br>Port: $08 - Write: "<span style="font-weight: bold;">Sys_Audio_Enable</span>"</pre>
<pre>Bit&nbsp;&nbsp;&nbsp; 0 - Channel 0 - 1 = Play audio, 0 = Stop audio<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 - Channel 1 - ("")<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 2 - Channel 2 - ("")<br>       3 - Channel 3 - ("")<br>     4:7 - n/u</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<br>
<pre>Port $09 - Read: "<span style="font-weight: bold;">sys_hw_flags</span>"</pre>
<pre>Bit:      7 - Hardware version serial data (16 bit value)<br>	  6 - SD card serializer status (1 = busy)<br>	  5 - Video Mode jumper status (0 = TV mode, 1 = VGA mode)<br>	  4 - Config EEPROM serializer status (1 = data byte ready for read)<br>	  3 - Configuration PIC's RB7 port status<br>	2:0 - n/u: Ignore / mask off these undefined bits </pre>
<pre><br>To read the hardware version word, set the address bus bits 11:8 to $0-$F when reading<br>this port (ie: use the "OUT (C),A" instruction, presetting register B with 0 to 15).<br>The bit addressed by B will appear in bit 7 of this port.</pre>
<pre><br>Port $09 - Write: "<span style="font-weight: bold;">sys_hw_settings</span>"</pre>
<pre>Bit:      0 - NMI switch inhibit. Default = 0, NMI switch enabled<br>          1 - Reset switch inhibit. Default = 0, Reset switch enabled <br>          2 &#8211; No effect (was originally PAL/NTSC mode select)<br>          3 &#8211; Force VGA to 50Hz mode (no effect in TV mode)<br>        4:7 - Not used</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre>Port $0A - Read / Write: "<span style="font-weight: bold;">sys_spi_port</span>"</pre>
<pre>The SPI port is used by the V6Z80P to send bytes serially (MSB first, SPI mode 0) to<br>its SD Card interface. Also, serial data received from the card's Dout line appears<br>here for reading. See also: SPI speed setting in Port $05 and busy flag in port $09</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre>Port $0B - Read/Write: "<span style="font-weight: bold;">sys_alt_write_page</span>" **</pre>
<pre>Bit: 0 - Write Page select Bit 0 - Relevant when bit 4 of Port 0 is set <br><br>     1 - Write Page select Bit 1 - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""<br><br>     2 - Write Page select Bit 2 - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""<br><br>     3 - Write Page select Bit 3 - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ""<br><br>     4 - "Write Palette/Read System RAM" - When set, CPU writes between $0-$1FF<br>          are directed to the palette registers, whilst CPU reads in this memory<br>          range return bytes from system RAM (instead of the ROM). This mode<br>          overrides bit 6 status<br><br>     5 &#8211; &#8220;Any page mode&#8221;. When set this allows the first 32KB of system RAM to be<br>         paged into locations $8000-$ffff of Z80 address space when bits 0:3 of<br>         sys_mem_select are zero. (Originally this was prohibited.)<br><br>     6 &#8211; "Read/Write First 512 bytes of System RAM" - When set, the system RAM<br>         &#8220;underneath&#8221; the ROM/palette at $000-$1ff is accessible as normal System RAM<br>         locations for read and write. Note: If bit 4 is set, this setting is ignored.<br><br>     7 &#8211;&nbsp;&#8220;Access RAM under video registers&#8221; - When set, the system RAM &#8220;underneath&#8221;<br>         the video registers at $200 - $7ff is accessible. As well as redirecting<br>         CPU writes to system RAM this control causes reads in the range $700-$7ff<br>         to return bytes from system RAM (READs from $200-$6ff return bytes from<br>         system RAM whether this bit is set or not). This means that the video<br>         status register and maths unit result word is not available (however,<br>         the video status register can always be read from port 7 - &#8220;sys_vreg_read&#8221;)</pre>
<pre>** To ensure the ROM is paged in upon reset and the system can start, this port register<br> is reset to $00 when the reset button is pressed.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br>Port $0C - Read: No function</pre>
<pre><br>Port $0C - Write: "<span style="font-weight: bold;">sys_baud_rate</span>"</pre>
<pre>Bit:&nbsp;&nbsp; &nbsp;0 - Set serial port RS232 comms speed: 0 = 57600 BAUD, 1 = 115200 BAUD</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;"><br>
<pre>Port&nbsp; $0D - Read: "<span style="font-weight: bold;">sys_eeprom_byte</span>"</pre>
<pre><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This port contains data bytes from the SPI FPGA configuration EEPROM, which<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can be read under CPU control. It should be read only when the "serializer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status flag" (bit 4 of port "sys_hw_flags") is 1. Reading this port clears<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the internal bit count and status flag. </pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Handshaking: When a databurst has been initiated (see PIC comms section) the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PIC issues a new byte every time the PIC CLOCK (bit 1 of sys_pic_comms) is raised.</pre>
<pre><br>Port&nbsp; $0D - Write: "<span style="font-weight: bold;">sys_pic_comms</span>"</pre>
<pre><br>Bit:   0 - Write to Configuration PIC port RB1 (data to PIC)<br>       1 - Write to Configuration PIC port RA5 (clock to PIC)<br>     2:7 - Not used, write with zeroes</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre>Port $0E - Read/Write: "<span style="font-weight: bold;">sys_io_pins</span>" (see data direction in port $0F)</pre>
<pre><br>Bit:&nbsp;     0 - Read/Write data bit for IO pin A<br>          1 - Read/Write data bit for IO pin B (pulled up)<br>          2 - Read/Write data bit for IO pin C (on PCBs that support it)<br>	3:5 - n/u <br>          6 - Reads: RESET switch status (pulled up)* - Write: N/A<br>          7 - Reads: NMI switch status (pulled up)* - Write: N/A</pre>
<pre>* Only relevant when Reset / NMI functions are disabled by port 9 bits 0:1</pre>
<pre><br>Port $0F - Read: No function</pre>
<pre>Port $0F - Write: "<span style="font-weight: bold;">sys_io_dir</span>" </pre>
<pre>Bit:&nbsp;&nbsp;&nbsp;   0 - Data direction for IO pin A (0 = output, 1 = input)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 - Data direction for IO pin B ( &#8220;&#8221; )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2 - Data direction for IO pin C (on PCBs that support it)<br>        3:7 - n/u</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br>Port $20 &#8211; Read / Write: &#8220;<span style="font-weight: bold;">sys_low_page</span>&#8221;</pre>
<pre>&nbsp;Bit&nbsp;&nbsp;&nbsp; 0:3 &#8211; Lower 32KB page select*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4:7 &#8211; Not Used &#8211; mask / ignore these undefined bits.</pre>
<pre>* IE: Selects which 32KB page from the 512KB system RAM appears at Z80 $0000-$7fff<br>&nbsp; (see table below)</pre>
<pre><br>System RAM Lower Page Selection Table</pre>
<pre>Bear in mind the ROM/Palette, video registers and sprite page will still occupy Z80 address<br>space locations: $0000-$01ff, $0200-$07ff and $1000-$1fff respectively regardless of which<br>32KB page is selected UNLESS these locations are specifically banked out of the address<br>space with their respective control bits.</pre>
<pre><br>Bits: 3 2 1 0&nbsp;&nbsp;&nbsp;Page&nbsp; System RAM paged into Z80 $0000-$7FFF<br>--------------------------------------------------------------</pre>
<pre>      0 0 0 0&nbsp;&nbsp; &nbsp;0&nbsp;&nbsp; $00000 - $07FFF <br>      0 0 0 1&nbsp;&nbsp; &nbsp;1&nbsp;&nbsp; $08000 - $0FFFF <br>      0 0 1 0&nbsp;&nbsp; &nbsp;2&nbsp;&nbsp; $10000 - $17FFF<br>      0 0 1 1&nbsp;&nbsp; &nbsp;3&nbsp;&nbsp; $18000 - $1FFFF<br>      0 1 0 0&nbsp;&nbsp; &nbsp;4&nbsp;&nbsp; $20000 - $27FFF<br>      0 1 0 1&nbsp;&nbsp; &nbsp;5&nbsp;&nbsp; $28000 - $2FFFF<br>      0 1 1 0&nbsp;&nbsp; &nbsp;6&nbsp;&nbsp; $30000 - $37FFF<br>      0 1 1 1 &nbsp;&nbsp; 7&nbsp;&nbsp; $38000 - $3FFFF<br>      1 0 0 0&nbsp;&nbsp; &nbsp;8&nbsp;&nbsp; $40000 - $47FFF <br>      1 0 0 1&nbsp;&nbsp; &nbsp;9&nbsp;&nbsp; $48000 - $4FFFF<br>      1 0 1 0&nbsp;&nbsp; &nbsp;A&nbsp;&nbsp; $50000 - $57FFF<br>      1 0 1 1&nbsp;&nbsp; &nbsp;B&nbsp;&nbsp; $58000 - $5FFFF<br>      1 1 0 0&nbsp;&nbsp; &nbsp;C&nbsp;&nbsp; $60000 - $67FFF <br>      1 1 0 1&nbsp;&nbsp; &nbsp;D&nbsp;&nbsp; $68000 - $6FFFF<br>      1 1 1 0&nbsp;&nbsp; &nbsp;E&nbsp;&nbsp; $70000 - $77FFF / LineCop program area ($0000 - $7fff)<br>      1 1 1 1 &nbsp;&nbsp; F&nbsp;&nbsp; $78000 - $7FFFF / LineCop program area ($8000 - $ffff)</pre>
<pre><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br>Port $21 &#8211; Read - No function</pre>
<pre><br>Port $21 - Write: &#8220;<span style="font-weight: bold;">sys_vram_location</span>&#8221;</pre>
<pre>Bit:    0:2 - Location of the video memory access window in Z80 address space (see table)<br>	3:7 &#8211; Not Used &#8211; write with zeroes</pre>
<pre><br>Bits: 2 1 0&nbsp; -&nbsp; VRAM Location:<br>-------------------------------</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 0&nbsp; -&nbsp; $2000 *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 1&nbsp; -&nbsp; $2000 *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1 0&nbsp; -&nbsp; $4000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1 1&nbsp; -&nbsp; $6000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 0&nbsp; -&nbsp; $8000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 1&nbsp; -&nbsp; $a000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 0&nbsp; -&nbsp; $c000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1&nbsp; -&nbsp; $e000</pre>
<pre><br>Note: The video window is paged in and out of Z80 address space with bit 6 of "sys_mem_select"</pre>
<pre>* 000 and 001 both set the VRAM window location at Z80 address $2000 (It is not possible to set<br>the VRAM window to Z80 $0000)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br>Ports $22 - $27: Used by sound system, see following section.<br><br></pre><hr style="width: 100%; height: 2px;">
<h3><br>
<span style="font-family: monospace;"></span>Sound
System&nbsp;Detail:</h3>



<pre>Note: The audio channel location registers were expanded to 18 bit in OSCA 672. Previously,<br>only 128KB of System RAM ($20000-$3FFFF) was accessible to the audio system.<br><br><span style="text-decoration: underline;"><br>Port assignments:</span><br><br>Ports $10-$1F and $22-$27 are assigned to the audio channels: <span style="text-decoration: underline;"></span><br><br><span style="font-weight: bold;">Port $10 -&nbsp;"audchan0_loc"</span> Location (low) of sound wave in System RAM Bits [16:1] (16 bit register)<br><span style="font-weight: bold;">Port $11&nbsp;- "audchan0_len"</span> Length of sound wave (in words) (16 bit register)<br><span style="font-weight: bold;">Port $12 - "audchan0_per"</span> Period of sound wave (number of 16MHz clock ticks between samples) (16 bit register)<br><span style="font-weight: bold;">Port $13&nbsp;- "audchan0_vol"</span> Volume of sound wave ($00-$40) (Linear scale: $40 = maximum volume) (8 bit register)</pre>


<pre>($14-$17: Same for channel 1 - <span style="font-weight: bold;">"audchan1_loc", "audchan1_len", "audchan1_per", "audchan1_vol"</span>)<br>($18-$1b: Same for channel 2 - <span style="font-weight: bold;">"audchan2_loc", "audchan2_len", "audchan2_per", "audchan2_vol"</span>)<br>($1c-$1f: Same for channel 3 - <span style="font-weight: bold;">"audchan3_loc", "audchan3_len", "audchan3_per", "audchan3_vol"</span>)<br><br><br><span style="font-weight: bold;">Port $22 - 'aud_panning'</span> (8 bit register)<br><br>Bit 0:3 - Select which channels go to the right side <br> &nbsp;&nbsp;&nbsp;4:7 - Select which channels go to the left side&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;(Each bit position = one channel, IE: bit0=channel0, bit1=channel1 etc)<br><br><br><span style="font-weight: bold;">Port $23 - Not implemented</span><br><br><br style="font-weight: bold;"><span style="font-weight: bold;">Port $24</span> - '<span style="font-weight: bold;">audchan0_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 0<br><span style="font-weight: bold;">Port $25</span> - '<span style="font-weight: bold;">audchan1_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 1<br><span style="font-weight: bold;">Port $26</span> - '<span style="font-weight: bold;">audchan2_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 2<br><span style="font-weight: bold;">Port $27</span> - '<span style="font-weight: bold;">audchan3_loc_hi</span>' Location (high) of sound wave in System RAM [Bits 18:17] for Channel 3<br><br>(All the location (high) ports are 8 bit registers)<br><br><span style="text-decoration: underline;">Notes:</span><br><br>The sound location registers are 18 bits long in total and refer to WORD addresses, not<br>byte addresses in System RAM (samples need to placed at word boundaries). Therefore, you<br>write (the actual RAM address / 2) into the location registers. <br><br>Samples must be an even number of bytes in length - you write the length in WORDS into<br>the Length registers (IE: Actual byte length/2). Maximum sample length is therefore 128KB.<br><br>The location (low), length and period values are 16 bit registers and should be updated<br>by using the Z80 "OUT (C),r" command where C is the port number, r holds the low 8 bits<br>of data and B holds the high 8 bits of data. The location (high) ports are 8 bit registers<br>(actually only 2 bits are used) and can be updated with the normal "OUT (n),A" instruction<br>if desired. The same is true of the volume ports (though there 7 bits are used).<br><br>The volume is a single byte linear scale value (range: $00 = silence to $40 = full volume).<br><br>The sound sample data needs to be in signed 8-bit format and located in System RAM<br>(it is read by the hardware using DMA). The audio hardware ignores any memory paging<br>settings and always reads directly from the system RAM when fetching data.<br> The sound system operates in a similar fashion to that of the Amiga Hardware, ie: You<br>set the location, length, period and volume of a channel, then start the channel<br>playing with the relevant "sys_audio_enable" port bit. Once the channel is playing,<br>its Location and Length registers can be updated - the channel will only fetch the<br>new values once its original length value has counted down to zero (or you stop<br>the channel for a while and restart it). If the registers are not changed, the<br>channel simply loops around playing the same sample data until it is stopped.</pre>
<pre>Because of the way the sound hardware pre-fetches sample data, some care needs<br>to be taken when setting up the registers.&nbsp; The recommended audio register setup<br>procedure is as follows:</pre>
<pre>1. Wait for post-audio DMA time (EG: wait for bit 6 of "sys_vreg_read" to change)<br>2. Stop the relevant audio channel(s) and write location, length, period and volume.<br>3. Wait for next post-audio DMA time (IE: At least one scanline delay)<br>4. Start the relevant audio channel(s)</pre>
<pre>(Once a sample is playing, the period and frequency registers can generally be updated on<br>the fly without special regard to the DMA timing)</pre>
<pre>It's possible to use an interrupt to seamlessly switch between two or more sample<br>buffers in order to play long samples without worrying about the exact timing. To<br>do this you would start a channel playing, reload it with the second buffer ready<br>for the first loop as normal, and then set up the audio interrupt so that it occurs<br>upon the first loop (IE: just as the second buffer starts to play). In the IRQ<br>service routine, you would set the channel location and length to point back to<br>the first buffer, and on subsequent IRQs switch between the two buffers.</pre>
<pre>Note: The four audio loop flags are OR'd into a single interrupt source. It is up<br>to the IRQ service routine to read bits 4:7 of the "sys_audio_flags" port, see<br>which bits are set (and clear them on exit from the IRQ).<br><br><br>Other sound related ports (see port breakdown detail above):</pre>
<pre>Port $01 (<span style="font-weight: bold;">sys_irq_enable</span>)- to enable/disable the audio IRQ<br>Port $02 (<span style="font-weight: bold;">sys_clear_irq_flags</span>)- to clear audio IRQ loop flags<br>Port $08 (<span style="font-weight: bold;">sys_audio_enable</span> / <span style="font-weight: bold;">sys_audio_flags</span>) - to enable channels / read loop flags.</pre>
<pre><br><span style="text-decoration: underline;">CALCULATING THE AUDIO PERIOD VALUE:</span></pre>
<pre>The period value is not the same as the Amiga uses, it has 4 times the resolution however<br>so a close match value can be obtained if desired.</pre>
<pre>Period = 16,000,000 / desired sample output rate</pre>
<pre>The minimum period value is around 512 (corresponds to a sample rate of ~31KHz) - this is<br>because the hardware pre-fetches 2 samples during DMA per scanline (and there is a couple<br>of cycles overhead etc)</pre>
<pre>For pure tones, the output frequency depends on the number of samples in your waveform<br>that constitute one cycle, so if the sample has EG: 16 bytes in one cycle, the period<br>value required to play it at a desired frequency is calculated thus:</pre>
<pre>Period = 16,000,000 / (samples per cycle * frequency) </pre>
<pre><br><span style="text-decoration: underline;">Panning:</span></pre>
<pre>The default set-up is for channels 0 and 2 to go to the left side, whilst channels 1 and 3<br>go to the right side,&nbsp; but by writing to port $22 "<span style="font-weight: bold;">sys_audio_panning</span>" all 4 channels can be<br>individually directed to the left, right or both sides.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h2>Hardware Maths Assist &#8211; multiply / scale unit</h2>
<pre>The maths assist unit consists of 3 elements: a) A 256 word table which can hold values (such as<br>sine constants), b) A 16bit value that is multiplied by the values in the table and c) An index<br>byte to select which word in the table to multiply by. The multiplication is a sign extended<br>16 bit x 16 bit operation, but only 16 bits from the resulting 32 bit longword are available to<br>be read, these bits are taken from bit 29 to bit 14. (Therefore care should be taken with the<br>values used in the multiplication operation to a) get correct results for unscaled multiplies<br>and b) prevent overflows.)</pre>
<pre><img style="width: 491px; height: 357px;" alt="Maths Assist Diagram" src="images/maths_assist.png"><br><br>The maths unit can be used for fast scaling of values using just the first entry of the table.<br>For example you could write some value to be scaled into the mult_table(0), set the mult_index<br>at 0 and write the scaling factor from 0 to 16384 into &#8220;mult_write&#8221;. The output from &#8220;mult_read&#8221;<br>will be mult_table(0) * mult_write/16384</pre>
<pre>To use the maths unit as a simple 256 x 16bit look-up table, write your 16 bit words in the<br>mult_table, 16384 into mult_write and simply select the value by setting mult_index and reading<br>from mult_read.</pre>
<pre>To do an unscaled "multiply by a constant" (using only a single entry in the table) you need<br>to adjust the multiplier and multiplicand to counter the scaling of the output. EG: To multiply<br>$0087 by $0025 you could write $8700 into mult_write - (IE: a simple LSB/MSB byte swap) and<br>$0940 into mult_table(0) (IE: $25 * $40). As the second word needs more processing, this would<br>be your pre-set constant (you could fill the rest of the table with other constants if desired).</pre>
<pre>The maths unit makes sin/cos calculations straightforward: Write the table with 256 sine values<br>(maximum positive amplitude = 16384), set the multiplier word to coordinate x and the index byte<br>to the angle a, the resulting word will be SIN (a) * x</pre>
<pre>Registers / locations used by the maths unit:</pre>
<pre>$208-$209 &nbsp;: "mult_write" 16 bit multiplier (word - write only)<br>$20A &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;: "mult_index" Maths table index (byte - write only)<br>$600-$7FF&nbsp; : "mult_table" Data table&nbsp; (word - write only)<br>$704-$705&nbsp; : "mult_read"&nbsp; Maths unit result (word - little endian - read only)</pre>
<pre>More details are provided in the register list.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3><span style="text-decoration: underline;">The
Video System:</span> </h3>
<pre>There is 512KB of &#8220;background video&#8221; RAM available (separate to sprite, audio and system memory).<br>It is normally accessible to the CPU in 8KB pages (at Z80 address $2000, $4000, $6000, $8000,<br>$A000, $C000 or $E000 depending on the port setting "sys_vram_location") with the page selected<br>by the register "vreg_vidpage". However, a special write-only mode also allows the entire Z80<br>address space to be mapped onto 64KB of video RAM.</pre>
<pre><br>There are two main video modes, bitmap and tilemap - both allow up to 256 colours. The display<br>is normally non-interlaced, PAL ~50Hz or VGA/NTSC ~60Hz (there is an option to force VGA to<br>non-standard 50Hz). CPU access TO VIDEO MEMORY whilst the display window is being generated is<br>blocked by the video system. The different video modes affect how long the CPU is kept<br>waiting - Dual Playfield tilemap mode is the most demanding. <br><br></pre>
<pre style="font-weight: bold; text-decoration: underline;">BITMAP "CHUNKY" MODE:</pre>
<pre><br>&nbsp;In standard chunky bitmap mode pixel data is fetched in a simple 1 byte = 1 pixel<br>&nbsp;fashion (it is called "chunky" as all the bits for each pixel come from the same<br>&nbsp;'chunk' - IE: location - in memory).</pre>
<pre>&nbsp;The byte fetched from VRAM represents an index in the video palette, therefore a $00 &nbsp;<br>&nbsp;shows a &#8220;palette entry 0&#8221; coloured pixel, $01 shows a &#8220;palette entry 1&#8221; coloured pixel<br>&nbsp;and so on. Data is fetched linearly from VRAM left to right, top to bottom of the screen<br>&nbsp;(a modulo register can be used to skip bytes at the end of each line - this is<br>&nbsp;useful for interlaced displays / skipping over an area used for fresh scroll data etc). <br>&nbsp;The data-fetch start address can be manipulated to achieve scrolling effects.</pre>
<pre><span style="text-decoration: underline;"><br>Line draw system:</span><br>&nbsp;<br> Fast line draws (125ns per 256 colour pixel) are possible in chunky mode. The<br>&nbsp;hardware requires Bresenham constants, octant number, video start address and<br>&nbsp;length of line to be set up in the line draw registers, then the hardware carries<br>&nbsp;out the algorithm. The registers are doubled up, allowing line set-up data for a<br>&nbsp;new line to be loaded up whilst the previous line is being drawn.</pre>
<pre><br><span style="text-decoration: underline;">Flood mode:</span> (Simplified in OSCA 672)<br><br>&nbsp;Chunky mode also offers "pixel flooding" (see bit 6 of vreg_vidctrl) which<br>&nbsp;repeats the last pixel colour to achieve flood fill effects. In this mode,<br>&nbsp;the hardware XOR's each new pixel with the value of the last. The stored<br> colour is reset to zero at the start of each scan line.</pre>
<pre><br><span style="text-decoration: underline;">Pixel Expand</span>:<br><br> Finally, in chunky mode pixels can be horizontally expanded from 1 to 8 times<br> (see bit 3 of "<span style="font-weight: bold;">vreg_vidctrl</span>" and bits 0:2 "<span style="font-weight: bold;">vreg_yhws_bplcount</span>")</pre>
<pre><br><span style="text-decoration: underline; font-weight: bold;">BITMAP "PLANAR" MODE:</span><br><br>&nbsp;In planar mode the display can have up to 8 bitplanes which are internally combined<br>&nbsp;to form a palette index for each pixel. As the number of&nbsp; bitplanes can be set,<br>&nbsp;the maximum number of colours on screen (without reloading the palette registers)<br>&nbsp;can be 2,4,8,16,32,64,128 or 256. This can offer efficiencies in terms of video<br>&nbsp;memory use and update speed. The main disadvantage is that fine pixel level access<br>&nbsp;is more difficult.</pre>
<pre>&nbsp;Each bitplane has its own 19 bit start location register (in fact there are two<br>&nbsp;sets of 8 bitplane pointers - the video hardware uses the set indicated in the video<br>&nbsp;control register "vreg_vidctrl"). These pointers need only be written once,<br>&nbsp;as an internal counter adds the offset to the video memory required as the frame<br>&nbsp;is built up (this offset register can be reset at any time). The bitplane pointers<br>&nbsp;can be manipulated to achieve scrolling effects etc. Fine horizontal pixel scrolling<br>&nbsp;is provided via a hardware scroll register (vreg_xhws). A modulo register can be used to<br>&nbsp;skip bytes at the end of each line.</pre>
<pre>&nbsp;The diagram below shows how bitplane data is combined to form a pixel's palette index:</pre>
<pre><img style="width: 471px; height: 234px;" alt="Bitplane system diagram" src="images/bitplane.png"><br><br></pre>
<pre style="text-decoration: underline; font-weight: bold;">TILE-MAP MODES:</pre>
<pre><br>&nbsp;In tile-map mode the display is built up in a less direct manner: The hardware reads<br> a look-up table to display a predefined block for each tile position. The blocks can<br> be 8x8 or 16x16 pixels in size (defined in a simple, linear &#8220;1 byte = 1 pixel<br> colour index&#8221; left to right, top to bottom fashion). Dual playfield capability is<br> provided so that one map can be overlaid on top of the other (pixels of value 0<br> are taken as transparent). The playfield priority is selectable. Each playfield<br> can be offset by 0-15 pixels in the vertical or horizontal direction allowing<br> smooth scrolling. There are two map buffers per playfield which allows double<br> buffering if desired. The registers vreg_vidctrl, vreg_ext_vidctrl, vreg_xhws<br> and vreg_yhws_bplcount contain the control bits for the tilemap modes.</pre>
<pre><br></pre>
<pre style="text-decoration: underline;">LEGACY AND EXTENDED TILE MODES:</pre>
<pre>&nbsp;The original OSCA tilemap mode limits tiles to 16x16 pixels, indexed with single<br> bytes allowing a maximum of 256 different tiles on screen. Two sets of tile<br> definitions are available with 248 and 256 tile images respectively (Tile set A<br> has fewer definition blocks available as the video memory for blocks 0-7 (VRAM $0-$7ff)<br> is assigned for use as the four available tile maps.) This simplistic system is<br> referred to as &#8220;Legacy Tilemap mode&#8221;.&nbsp; Extended Tile Mode provides more flexibility<br> and may be a better choice for new programs.</pre>
<pre><br>In Legacy Tile Mode: VRAM is organized as follows:</pre>
<pre><br>&nbsp;&nbsp;&nbsp; $00000 - $001FF:&nbsp; Playfield A - tilemap 0<br> &nbsp;&nbsp; $00200 - $003FF:&nbsp; Playfield A - tilemap 1<br>&nbsp;&nbsp;&nbsp; $00400 - $005FF:&nbsp; Playfield B - tilemap 0<br>&nbsp;&nbsp;&nbsp; $00600 - $007FF:&nbsp; Playfield B - tilemap 1</pre>
<pre>&nbsp;&nbsp;&nbsp; $00800 - $0FFFF: Tile definition set A (Tile defs 0-7 are unavailable)<br>&nbsp;&nbsp;&nbsp; $10000 - $1FFFF: Tile definition set B (Tile defs 0-255 available)</pre>
<pre>&nbsp;&nbsp;&nbsp; The horizontal size of the tile map buffer is always 32 bytes, no matter what<br>&nbsp;&nbsp;&nbsp; the size of the display window.</pre>
<pre><br><span style="text-decoration: underline;">EXTENDED TILE MODE:</span><br><br>&nbsp;In Extended Tilemap Mode (IE: when bit 0 of vreg_ext_vidctrl is set), tiles are<br>&nbsp;indexed by 2 bytes and can be 16x16 or 8x8 pixels. There is a single set* of 2048<br>&nbsp;16x16 tiles or 8192 8x8 tiles (the &#8220;tile set select&#8221; bits used in legacy mode have<br>&nbsp;new meanings in Extended Tilemap Mode.) The tile maps are located between at $70000-<br>&nbsp;$73fff in video memory, well clear of the tile definitions which are located at<br>&nbsp;VRAM $0 (The memory space used by the tile maps will produce garbage tiles if<br>&nbsp;indexed). Bits 6:7 of the upper byte of the tile indices control x_mirror (Bit 6)<br>&nbsp;and y_flip (Bit 7) of each tile definition.</pre>
<pre>*&nbsp;Although the tile definitions are normally indexed in a straightforward linear manner,<br> there is an option to switch between the definitions held at VRAM $0-$3FFFF and $40000-$7ffff.</pre>
<pre>In Extended Tile Mode with 16x16 tiles: VRAM is organised as follows:</pre>
<pre>&nbsp;&nbsp; $00000-$6FFFF: Tile definitions (256 bytes each)<br>&nbsp;&nbsp; $70000-$701FF: Playfield A Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $70200-$703FF: Playfield A Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $70400-$705FF: Playfield A Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $70600-$707FF: Playfield A Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $70800-$709FF: Playfield B Buffer 0 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $70A00-$70BFF: Playfield B Buffer 1 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $70C00-$70DFF: Playfield B Buffer 0 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $70E00-$70FFF: Playfield B Buffer 1 tilemap MSBs (incl. flip control)</pre>
<pre>In 16x16 tilemap mode, the width of each horizontal map line is 32 bytes no matter what the<br>size of display window. Each tilemap has room for 16 rows of tiles (ie: a 256 scanline display),<br>however when using vertical hardware scroll, the maximum y window should be 240 lines to mask<br>off the last tile-line (where the internal tilemap line pointer wraps back to 0)</pre>
<pre>In Extended Tile Mode with 8x8 tiles: VRAM is organised as follows:</pre>
<pre>&nbsp;&nbsp; $00000-$6FFFF: Tile definitions (64 bytes each)<br>&nbsp;&nbsp; $70000-$707FF: Playfield A Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $70800-$70FFF: Playfield A Buffer 0 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $71000-$717FF: Playfield A Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $71800-$71FFF: Playfield A Buffer 1 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $72000-$727FF: Playfield B Buffer 0 tilemap LSBs<br>&nbsp;&nbsp; $72800-$72FFF: Playfield B Buffer 0 tilemap MSBs (incl. flip control)<br>&nbsp;&nbsp; $73000-$737FF: Playfield B Buffer 1 tilemap LSBs<br>&nbsp;&nbsp; $73800-$73FFF: Playfield B Buffer 1 tilemap MSBs (incl. flip control)<br><br>(Note that the LSB/MSB arrangement is slightly different to that of the 16x16 mode.)</pre>
<pre>In 8x8 tilemap mode, the width of each horizontal map line is 64 bytes no matter what the<br>size of display window. The hardware scroll registers still provide a 0-15 pixel offset.</pre>
<pre>Each tilemap has room for 32 rows of tiles (ie: a 256 scanline display), however<br>when using vertical hardware scroll, the maximum y window should be 248 lines to<br>mask off the last tile-line (where the internal tilemap line pointer wraps back to 0)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3>Sprites:</h3>
<pre>There is 128KB of dedicated RAM for sprite definitions (enough space for 512 16x16 256<br>colour sprite blocks). This (write only) memory is accessed in 4KB pages through a<br>window in Z80 address space located at $1000-$1FFF. The 4KB page from within the total<br>128KB sprite RAM is selected by the register vreg_vidpage (write the page number 0-31,<br>with bit 7 set). The 4KB window is opened and closed with Bit 7 of the port "sys_memselect".<br>(Note: When the CPU reads from $1000-$1FFF, data is ALWAYS returned from system RAM<br>regardless of the setting in sys_memselect.)</pre>
<pre>Sprite definition memory accepts writes at full speed when the sprites are disabled.<br>When sprites are enabled, writes from the CPU are forced to wait until the sprite<br>hardware releases the RAM buses. The length of the wait during contention depends<br>how busy the sprite hardware is on any given scanline. The sprite control registers<br>do not cause the CPU to wait.</pre>
<pre>Each sprite definition block is 256 bytes long, with pixel data in a linear format<br>"1 byte = 1 pixel" fashion, left to right, top to bottom of the sprite definition.<br>Colour index zero is considered transparent by the sprite video hardware. Sprites<br>are always 16 pixels wide but can be up to 240 pixels tall (the height of an<br>individual sprite (in 16 line blocks) is set by its control register). The additional<br>definition data for sprites taller than 16 lines comes from the blocks of sprite data<br>following the specified sprite definition. Sprite images can be individually mirrored<br>horizontally by setting a bit in their control registers - see detail below.</pre>
<pre>There is enough time on any one scanline to show 55 sprites, but there are 127 sprite<br>control registers. Therefore, this can be thought of as hardware multiplexing: Because<br>it is uncommon for 55 sprites to appear on the same line, sprite images from all the<br>registers will normally be displayed if spread throughout the entire display window.</pre>
<pre>A double buffering mode allows half the sprite registers to be updated whilst the<br>sprite hardware builds the display from the other half (the buffers are typically<br>switched by the user's program each frame). This removes possible on-screen glitches<br>and/or the need to dump data to the sprite registers off-screen. Bits in vreg_sprctrl<br>are used operate this mode.</pre>
<pre><br><span style="text-decoration: underline;">Sprite to Background Priority:</span></pre>
<pre>In the most basic mode, non-zero sprite pixels appear in front of all background<br>display data. However there are controls to allow sprites to be masked by sections<br>of the background colour palette. For the purposes of priority, the background palette<br>is divided into 16 x 16 colour groups, sprites can then appear in front or behind<br>one or more of these groups. There are two sets of background mask selections,<br>sprites use the mask set based on bit7 of their pixel colours. To dynamically<br>switch a sprite from one set of masks to the other (EG: to move it from foreground<br>to background) bits from a sprite&#8217;s control register can be used to modify its<br>pixels&#8217; MSBs (without this it would be necessary to have copies of the same sprites<br>drawn using different colour indexes and switch the definitions.) </pre>
<pre>The main priority control &#8220;interleave mode&#8221; is bit 1 of vreg_sprctrl, when this bit<br>is zero, sprite pixels appear in front of all background data. When this bit is<br>set to one, sprites use their pixel colour index MSBs to select one of the two<br>background mask sets.</pre>
<pre><br>To assist with individual sprite priorities, an option called "modify_colour_MSBs"<br>is available, this is enabled by bit 4 in vreg_sprctrl. When set, the MSB of each<br>individual sprite's height control is sacrificed and transferred the MSB of all<br>the sprite&#8217;s pixel colours. Of course, the sprite would normally change colour<br>if the palette indices 1-127 and 129-255 are different, therefore another control<br>bit is available that forces sprites only to be shown using colours 1-127 (IE:<br>their pixel colour MSBs are reset to zero, but only after the priority has been<br>determined). This option is called &#8220;fix_colours_low&#8221; and is enabled with bit 6<br>of vreg_sprctrl. (As these options sacrifice the MSB of the sprites&#8217; height settings,<br>it limits how tall a sprite can be.)</pre>
<pre>One last sprite feature is "matte mode" - this forces all non-zero pixels in a sprite<br>to a single colour, an effect which is sometimes used in games to indicate a character<br>has taken a hit. The feature is enabled with bit 5 in vreg_sprctrl, afterwards bit 2<br>of each sprite&#8217;s height control register is used to switch individual sprites to single colour.</pre>
<pre>Internally, this feature sets bits 0:6 of the sprite pixels (but not bit 7, as that<br>could affect its priority). Therefore all the sprite&#8217;s pixels will be shown as colour<br>&nbsp;127 or colour 255 depending on the sprite&#8217;s original bit 7 (if in doubt simply make<br>palette colours 127 and 255 the same). As another bit of the sprite height control<br>register is sacrificed, sprites are limited to 16/32/48/64 pixels tall (also 128,144,<br>160,176 if "modify_colour_MSBs" is not required.)</pre>
<pre>In general, bear in mind the sprite layer is generated separately to the background,<br>and because priorities work solely on colour indexes care must be taken (especially<br>in dual playfield tile mode) when designing the colour palette and the order in which<br>sprites are assigned to registers.</pre>
<pre><br><span style="text-decoration: underline;">Background mask registers:</span></pre>
<pre>The mask registers are located at $280-$28F. Only two bits of each location are used:<br>Bit 0 is the mask for &#8220;level 0&#8221; (where a sprite&#8217;s colour index MSB is 0) and Bit 1 is<br>the mask for &#8220;level 1&#8221; (where a sprite&#8217;s colour index MSB is 1). The register at $280<br>holds the masks for background colours 0-15, the register at $281 holds the masks for<br>background colours 16-31, the register at $282 holds the masks for background colours<br>32-47 and so on.</pre>
<pre>Where each register mask bit is zero, the range of colours it will represents will<br>appear behind sprites. Where a mask bit is one, the range of colours it represents<br>will appear in front of sprites.</pre>
<pre>An example:</pre>
<pre>$280: (background 00-0f) = 00b&nbsp;&nbsp; &nbsp;$288: (background 80-8f) = 01b<br>$281: (background 10-1f) = 00b&nbsp;&nbsp; &nbsp;$289: (background 90-9f) = 01b<br>$282: (background 20-2f) = 00b&nbsp;&nbsp; &nbsp;$28A: (background a0-af) = 01b<br>$283: (background 30-3f) = 00b&nbsp;&nbsp; &nbsp;$28B: (background b0-bf) = 01b<br>$284: (background 40-4f) = 00b&nbsp;&nbsp; &nbsp;$28C: (background c0-cf) = 01b<br>$285: (background 50-5f) = 00b&nbsp;&nbsp; &nbsp;$28D: (background d0-df) = 01b<br>$286: (background 60-6f) = 00b&nbsp;&nbsp; &nbsp;$28E: (background e0-ef) = 01b<br>$287: (background 70-7f) = 00b&nbsp;&nbsp; &nbsp;$28F: (background f0-ff) = 01b</pre>
<pre>In the above example (when interleave mode is enabled) sprites with pixel indexes<br>in the range 00-7f will be occluded by background colours 80-ff. This is the default<br>OSCA setting.</pre>
<pre style="text-decoration: underline;"><br>Sprite Control Registers (4 bytes per sprites)</pre>
<pre><br>Memory addresses of registers:</pre>
<pre>&nbsp;$400-$5fb (127 registers - single set of sprite control registers)</pre>
<pre>&nbsp; or</pre>
<pre>&nbsp;$400-$4fb (Register bank 0) (63 registers - double buffered register mode)<br>&nbsp;$500-$5fb (Register bank 1) (63 registers - double buffered register mode)</pre>
<pre><br>Each sprite register is 4 sequential bytes:</pre>
<pre><br>$00 : X coordinate (low 8 bits)</pre>
<pre>$01 : Bits 7:4 = Height of sprite (in blocks of 16 lines) * </pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 = X Mirror enable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 = Definition MSB<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 = Y coordinate MSB <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 = X coordinate MSB</pre>
<pre><br>$02 : Y coord (low 8 bits)</pre>
<pre>$03 - Sprite definition number (low 8 bits)</pre>
<pre>(* If the four height bits are zero, the sprite is 240 pixels tall.)</pre>
<pre>X and Y coordinates and the definition values are 9 bit in size, the MSBs are stored in<br>the second byte of the register. The coordinate positions are fixed and are not relative<br>to the display window position, IE: the X/Y coordinates are the same absolute positions<br>as those used by the window location / size set up. (X sprite positions are actually<br>one pixel less than x_window_start position).</pre>
<pre>*&nbsp;If "modify_colour_MSBs" mode is enabled (bit 4 in vreg_sprctrl = 1) the four bits<br> normally assigned to height work as follows:</pre>
<pre>bit 7 - Use priority mask set 0 or 1<br>&nbsp;&nbsp;&nbsp; 6 - Height (bit 2)<br>&nbsp;&nbsp;&nbsp; 5 - Height (bit 1)<br>&nbsp;&nbsp;&nbsp; 4 - Height (bit 0)</pre>
<pre>Therefore in this mode sprites can be 16,32,48,64,80,96,112 (or 240 when the three<br>height bits are all zero) lines tall.</pre>
<pre>* If "matte_mode" is enabled (bit 5 in vreg_sprctrl = 1) the four bits normally<br> assigned to height work as follows: </pre>
<pre>bit 7 - Height (bit 3)<br>&nbsp;&nbsp;&nbsp; 6 - Force non-zero colours to 127 or 255<br>&nbsp;&nbsp;&nbsp; 5 - Height (bit 1)<br>&nbsp;&nbsp;&nbsp; 4 - Height (bit 0)</pre>
<pre>Therefore in this mode sprites can be 16,32,48,64, and 128,144,160,176 lines tall<br>(64 lines are used when bit 0 and 1 are zero)</pre>
<pre>*&nbsp;If both "matte_mode" and "modify_colour_MSBs" modes are selected, the four bits<br> normally used for height are interpreted as follows:</pre>
<pre>bit 7 - Use priority mask set 0 or 1<br>&nbsp;&nbsp;&nbsp; 6 - Force non-zero colours to either 127 or 255<br>&nbsp;&nbsp;&nbsp; 5 - Height (bit 1)<br>&nbsp;&nbsp;&nbsp; 4 - Height (bit 0)<br><br>In this mode sprites can be 16,32,48,64 lines tall (64 lines are used when bit 0 and<br>1 are zero).<br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3>Display Window:</h3>
<pre>The positions of the edges of the display window are programmable (which of course<br>also sets the size of the display). There are 4 bits of precision for each of the left,<br>right, top and bottom edges. The horizontal resolution is 16 pixels and the vertical<br>resolution is 8 lines. Values obtained from the tables below should be written to the<br>register vreg_window (note that both vertical and horizontal settings share this same<br>register - the horizontal/vertical function is switched by bit 2 of vreg_rasthi - see<br>the example at the end of this section).</pre>
<pre><br>Positioning a display window within the maximum possible display area:</pre>
<pre><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X stop</pre>
<pre>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! <br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V<br>!---!------------------------------------.<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8220;BORDER&#8221;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! &lt;- Y start<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTIVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISPLAY WINDOW&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! &lt;- Y Stop<br>!&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br>!&nbsp;&nbsp; !&lt;-- MAX VISIBLE AREA OF TV SCREEN--&gt;!<br>!---'------------------------------------'<br>!&nbsp;&nbsp; !<br>^&nbsp;&nbsp; ^</pre>
<pre>Sync etc</pre>
<pre><br>Horizontal Positions:</pre>
<pre>There are theoretically 512 horizontal pixel positions along a scan line. The x_start<br>values are n * 16 pixels in from the left hand side. The x_stop values are n * 16 pixels<br>from theoretical pixel 256 (note: this is not the exact centre of the TV screen, due to<br>sync periods etc). Of the byte written to the vreg_window register, the left side setting<br>nybble goes in bits [7:4] and the right side setting nybble goes in bits [3:0]</pre>
<pre><br></pre>
<pre style="text-decoration: underline;">Display Window Register "vreg_window" Values:</pre>
<pre><br><span style="text-decoration: underline;">Nybble&nbsp;&nbsp;&nbsp;X_start&nbsp; X_stop</span><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>   $0 &nbsp;&nbsp;&nbsp; 00 *&nbsp;&nbsp;&nbsp;  256&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $1     16 *&nbsp;&nbsp;&nbsp;  272&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br>   $2 &nbsp; &nbsp; 32 *&nbsp;&nbsp;&nbsp;  288&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>   $3 &nbsp; &nbsp; 48 *&nbsp;&nbsp;&nbsp;  304&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $4 &nbsp; &nbsp; 64 *&nbsp;&nbsp;&nbsp;  320&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $5 &nbsp; &nbsp; 80 *&nbsp;&nbsp;&nbsp;  336&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $6 &nbsp;&nbsp; &nbsp;96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  352&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $7 &nbsp;&nbsp; &nbsp;112&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 368&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $8 &nbsp;&nbsp; &nbsp;128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 384&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $9 &nbsp;&nbsp; &nbsp;144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 400&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $a &nbsp;&nbsp; &nbsp;160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 416&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $b &nbsp;&nbsp; &nbsp;176&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 432&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $c &nbsp;&nbsp; &nbsp;192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 448<br>&nbsp;&nbsp; $d &nbsp;&nbsp; &nbsp;208&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 464&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $e &nbsp;&nbsp; &nbsp;224&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 480<br>&nbsp;&nbsp; $f &nbsp;&nbsp; &nbsp;240&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 496&nbsp;&nbsp; &nbsp;</pre>
<pre>*&nbsp; = Outside of the normally visible TV frame - there's no point using these values.</pre>
<pre>Note: Width of display in pixels = ((x_stop nybble + 16) - x_start nybble) * 16</pre>
<pre><br>Vertical Positions:</pre>
<pre><br>The Y_start value refers to the position of the top line of your active display window.<br>(This is counting from 16 lines above the first visible scanline of the screen - these<br>&nbsp;"redundant" 16 lines allow sprites to be masked off at the top of the display). The<br>Y_stop value refers to the position of the last line of your display window, also<br>counting from 16 lines above the first visible scanline of the screen. </pre>
<pre><br><span style="text-decoration: underline;">Values for Y_Start (vreg_window register bits 7:4): </span></pre>

<pre><br><span style="text-decoration: underline;">Nybble&nbsp;&nbsp; Lines from 1st visible&nbsp;&nbsp; (Sprite Y coord)&nbsp;</span>&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; $0&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;-16 * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $1&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;-8&nbsp; * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$09&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $2&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$11&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $3&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$19&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $4&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;16&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$21 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $5&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;24&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$29&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $6&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;32&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$31&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $7&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;40&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$39&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $8&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;48&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$41&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $9&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;56&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$49&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $a&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;64&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$51&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $b&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;72&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$59&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $c&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;80&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$61&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $d&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;88&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$69&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $e&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;96&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$71&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; $f&nbsp; =&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;104 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$79&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</pre>
<pre><br>*&nbsp; This is above the top of the visible screen, these values should not normally be used.<br>&nbsp; (IE: A value of $2 written to the Y_start register gives the highest available start<br>&nbsp; line on PAL/NTSC/VGA displays.)</pre>
<pre><br></pre>
<pre><span style="text-decoration: underline;">Values for Y_Stop Window (vreg_window register bits 3:0):</span> </pre>
<pre><br><span style="text-decoration: underline;">Nybble&nbsp;&nbsp;&nbsp; Lines from 1st visible&nbsp;&nbsp; (Sprite Y coord)</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>

<pre>&nbsp;$0&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 144                     $a1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;$1&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 152                     $a9<br>&nbsp;$2&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;160                     $b1<br>&nbsp;$3&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;168                     $b9<br>&nbsp;$4&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;176                     $c1<br>&nbsp;$5&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;184&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $c9<br>&nbsp;$6&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;192&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $d1<br>&nbsp;$7&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;200&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $d9<br>&nbsp;$8&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;208&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $e1<br>&nbsp;$9&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;216&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $e9<br>&nbsp;$a&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;224&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $f1<br>&nbsp;$b&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;232&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $f9<br>&nbsp;$c&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;240&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $101<br>&nbsp;$d&nbsp; = &nbsp;&nbsp;&nbsp; &nbsp;248&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;    $109<br>&nbsp;$e&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;256&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;     $111<br>&nbsp;$f&nbsp; =&nbsp; &nbsp;&nbsp; &nbsp;264 **&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;  $119</pre>
<pre>** This is below the bottom of a PAL display and should not normally be used.</pre>
<pre>Note: Total lines in display = (Y_Stop nybble * 8) + 160 - (Y_Start's nybble * 8)</pre>
<pre><br>VGA/NTSC/PAL Mode notes:</pre>
<pre>Because the different TV/VGA modes have various numbers of scanlines making up the<br>display, a window vertically centred in one display mode may not be central in other<br>modes. If this is important, a constant (depending on the display mode) can added to<br>the start/stop settings plus all sprite y coordinates and scanline-based operations.<br>The 60Hz mode flag in the Video Status Register can assist if the correction is to<br>be done automatically, else a display adjust routine can be provided in user programs.</pre>
<pre><br></pre>
<pre style="text-decoration: underline;">Example code: Display Window setting:</pre>
<pre>To set the vertical start and stop positions of the display window, first write<br>vreg_rasthi with bit 2 clear, then write an appropriate value from the tables<br>above to vreg_window. To set the horizontal positions, write vreg_rasthi with<br>bit 2 set, then write an appropriate value for the horizontal setting to vreg_window.<br><br>EG:<br>&nbsp;&nbsp; &nbsp;ld a,$00<br>&nbsp;&nbsp; &nbsp;ld (vreg_rasthi),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; selects vertical window setting<br>&nbsp;&nbsp; &nbsp;ld a,$5a<br>&nbsp;&nbsp; &nbsp;ld (vreg_window),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; sets vertical window size/position (200 lines)<br>&nbsp;&nbsp; &nbsp;ld a,$04<br>&nbsp;&nbsp; &nbsp;ld (vreg_rasthi),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; selects horizontal window setting<br>&nbsp;&nbsp; &nbsp;ld a,$8c<br>&nbsp;&nbsp; &nbsp;ld (vreg_window),a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; sets horizontal window size/position (320 pixels</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Blitter:</h3>
<pre>OSCA&#8217;s blitter can transfer data around video memory much faster than the CPU (it copies one<br>byte every 2 system clocks, compared with the CPU's LDIR instruction @ 1 byte per 21 clocks).<br>It can work in ascending or descending address order and also has modulo registers so that<br>rectangular areas within larger overall arrays can be shifted in one go. It can, however,<br>only operate within video memory. There is the option to skip the writing of source bytes<br>that equal zero, this is mainly useful in Chunky pixel mode where it can be used to mask<br>out "transparent" pixels (eg: drawing "bobs").</pre>
<pre><br>The blitter takes priority over access to video RAM from the CPU (but obviously the video<br>datafetch still impedes its performance) and the CPU is forced to wait for the blitter to<br>finish its operation if it tries to access video memory whilst a blit is under way.<br>Otherwise, a blit can be started and the CPU can continue with another task (note:<br>MOST blitter registers CAN be changed once a blit is underway without problems, however<br>the Modulos, Width and Misc registers should not be changed until a blit is finished).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Line Sync'd Co-Pro ("LineCop"):</h3>
<pre>This simple co-processor allows changes to be made to the display at specific scan lines<br>without having to use manual CPU interrupts (it operates using DMA cycle-stealing in a<br>similar manner to the sound system). The LineCop system follows a program, there are 3<br>main instructions and each instruction is two bytes long. The upper bits of the MSB<br>determines what kind of instruction it is:</pre>

<pre><br><span style="text-decoration: underline;">Bit: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 1&nbsp; x&nbsp; x&nbsp; x&nbsp; x&nbsp; x&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; L&nbsp; = Wait for line L</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 0&nbsp; x&nbsp; x&nbsp; x&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; R&nbsp; = Select Register R</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; a&nbsp; b&nbsp; c&nbsp; x&nbsp; x&nbsp; x&nbsp; x&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; D&nbsp; = Write D to Register</pre>
<pre><br>x = Dont care<br>L = Line to wait for<br>R = Register to update ($0-$7FF)<br>D = Data byte to write to selected register <br>a = If set: After Write, increment selected register<br>b = If set: After write, increment wait line (and wait)<br>c = If set: After write, reload LineCop Program Counter from Start Location Registers<br><br>Wait and Register Select instructions take 2 clock cycles, Register Writes take 3 cycles.</pre>
<pre>The LineCop program can be 64KB max (32768 instructions), and must be located at $70000-$7FFFF<br>in system memory (IE: The highest two upper 32KB banks). The start address of the program is<br>held in vreg_linecop_lo ($20D) and vreg_linecop_hi ($20E). Bits [15:1] are used for the address,<br>whereas bit [0] (IE: the least significant bit of vreg_linecop_lo) is the LineCop enable bit.<br>The LineCop's Program Counter is reloaded from the address held in vreg_linecop_lo and<br>vreg_linecop_hi at the end of every frame and also when forced by a LineCop write instruction<br>which has bit 12 set. As the LineCop can write to its own location pointers and restart itself,<br>automatic list cycling / page flipping can be achieved. Linecop programs should end with a wait<br>for a line that is never reached, IE: $1FF (Use the instruction code hexcode $C1FF)</pre>
<pre>When the raster reaches a scanline that matches that set by a LineCop wait instruction, the<br>LineCop steals time from the CPU until it reaches the next Wait instruction. If the end of<br>the scanline is reached first, the Linecop becomes inactive until the next frame.</pre>
<pre>Whilst writes to the palette etc have immediate effect, some video register changes will<br>not take effect until the start of the next scanline, or sometimes the line following<br>that. This is due to the way the internal scanline buffers are generated. It is advisable<br>to use the double-buffered registers whilst making changes to the sprites or bitmap locations<br>as the write will occur some time during the linebuffer generation period. &nbsp;</pre>
<pre>As the LineCop can access all the video registers including blitter etc, beware of malformed<br>LineCop programs causing undesired effects. The linecop only ever writes to the hardware<br>registers - never system RAM - IE: bit 7 of the port &#8220;sys_alt_write_page&#8221; is irrelevent to<br>the LineCop.</pre>
<pre style="text-decoration: underline;"><br>An example LineCop program:</pre>
<pre>Change the background colour to white at scanline $50, and black at scan line $51</pre>
<pre>Location | Instruction<br>----------------------</pre>
<pre>$70000:&nbsp;&nbsp; &nbsp;$c050&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Wait for line $50<br>$70002: &nbsp; &nbsp;$8000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Select video register $000 (background colour)<br>$70004:&nbsp;&nbsp; &nbsp;$40ff&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $ff to colour LSB, increment video register<br>$70006:&nbsp;&nbsp; &nbsp;$20ff&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $ff to colour MSB, increment wait line (and wait)<br>$70008:&nbsp;&nbsp; &nbsp;$8000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Select video register $000 (background colour)<br>$7000A:&nbsp;&nbsp; &nbsp;$4000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $00 to colour LSB, increment video register<br>$7000C:&nbsp;&nbsp; &nbsp;$0000&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Write $00 to colour MSB<br>$7000E:&nbsp;&nbsp; &nbsp;$C1FF&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;; Wait for line $1FF (Never reached - end of LineCop program)</pre>
<pre>Note that LineCop instruction WORDS are shown for clarity above - the BYTE ordering is<br>Z80 standard little endian, therefore - as bytes - the code above would be listed:</pre>
<pre>$70000: $50,$c0,$00,$80,$ff,$40,$ff,$20,$00,$80,$00,$40,$00,$00,$ff,$c1</pre>
<pre>The above LineCop program is started with the Z80 code:</pre>
<pre> LD HL,$0001                ; LineCop program Address = $70000 (bit 0 = enable) <br> LD (vreg_linecop_lo),HL    ; Set address and start</pre>
<pre>The LineCop can be stopped with the Z80 code:</pre>
<pre> XOR A                      ; Zero the accumulator<br> LD (vreg_linecop_lo),A&nbsp;&nbsp; &nbsp; ; When bit 0 of this register is zero, the linecop is stopped.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Colour palette:</h3>
<pre>The V6Z80P's colour resolution is 12 bit, with 4 bits for red, green and blue (a choice<br>of 4096 colours). The indexed pixel colour system used by OSCA allows up to 256 colours<br>on screen at once (without using tricks). There are two sets of palette registers, each<br>holding 256 entries (words). The palette currently being accessed by the video hardware<br>to build the video frame and that which receives writes from the CPU / LineCop can be<br>independently set (see "vreg_palette_ctrl")</pre>
<pre>Both palettes are located at memory locations $000 - $1FF, with the following format:</pre>
<pre> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Colour 0&nbsp;&nbsp;&nbsp; Colour 1&nbsp;&nbsp;&nbsp; Colour 2&nbsp;&nbsp;&nbsp;&nbsp; etc..</span><br><br>Location:&nbsp; $00,$01,&nbsp;&nbsp;&nbsp; $02,$03,&nbsp;&nbsp;&nbsp;&nbsp; $04,$05,&nbsp;&nbsp;&nbsp; etc..<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GB&nbsp; 0R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GB&nbsp; 0R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GB&nbsp; 0R&nbsp;&nbsp;&nbsp;&nbsp; etc..</pre>
<pre><br>Where R, G &amp; B are the 4 bit intensity values of Red, Green and Blue. (The 4 MSBs [15:12]<br>of each entry are not used and should be written with zeroes).</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Resolution:</h3>
<pre>The normal horizontal pixel resolution in TV mode is 8MHz and 16MHz in VGA mode - this<br>means there can be approximately a maximum of 368 pixels visible on any one scan line.<br>As there is spare bandwidth in TV mode, there is the option to increase the pixel rate<br>to 16MHz, at the expense of colour depth (reduced to 16 colours max) &#8211; see bit 3 of<br>&#8220;vreg_ext_vidctrl&#8221; - this is referred to as Hi-Res Mode. In this mode, the colour index<br>of each normal pixel is split into two 4-bit indices (7:4 = Leftside hi-res pixel,<br>3:0&nbsp; = Rightside hi-res pixel).&nbsp; This process is applied at final output stage of the<br>pixel colour look-up and is merely a &#8220;filter&#8221; instead of a "real" hi-res mode. Because<br>the sprite priority system is unaware of this filter, it still processes priorities<br>based on 8 bit pixel values - therefore sprite interleaving should not be used in<br>hi-res mode.</pre>
<pre>The vertical resolution varies depending on the TV/monitor (PAL has approx 256 visible<br>lines, less for NTSC and VGA). The TV modes allow interlacing (see bit 2 of vreg_ext_vidctrl)<br>this adjusts the frame timing causing the TV to offset the lines of every other frame by<br>half the thickness of a scanline. (Bit 7 of vreg_read shows which field is currently<br>being displayed.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3>Video Hardware Timing:</h3>
<pre>As can be seen from the diagram below, each video line is internally buffered until the<br>next scan line when it actually displayed. The sprites and background video layers are<br>generated simultaneously to separate buffers and combined when the line is eventually<br>clocked out to the display.<br><br><br><img style="width: 436px; height: 200px;" alt="Linebuffer timing" src="images/linebuffer_timing.png"><br>&nbsp;</pre>
<pre>Writing to most video registers will have an immediate visible effect (EG: writes to<br>the colour palette, unless double buffered) but some will not visibly change anything<br>until the following scan line as changes are automatically synchronized to the start<br>of a new scan line, these include:</pre>
<pre>* &#8220;Live Palette Select&#8221; (in vreg_palette_ctrl)</pre>
<pre>*&nbsp;&#8220;Live Bitplane Location Register Set Select&#8221; (also &#8220;Playfield A map buffer select&#8221;<br> when in Tilemap mode) (bit 5 in vreg_vidctrl)</pre>
<pre>*&nbsp;&#8220;Tilemap Mode Select&#8221; (bit 0 in vreg_vidctrl)</pre>
<pre>*&nbsp;&#8220;Chunky or Planar Bitmap Mode Select&#8221; (also &#8220;Dual Playfield On/Off Select&#8221; when<br> in Tile Map mode) (bit 7 in vreg_vidctrl)</pre>
<pre>*&nbsp;&#8220;Display Window Right Side Position&#8221; (in vreg_window)</pre>
<pre><br>A note concerning updating bitmap location pointers: Each line is begins generation<br>before the LineCop DMA starts, therefore even if the bitmap location registers are<br>changed with the linecop at the start of a line (IE: immediately following a LineCop<br>WAIT instruction) there will be some pixels at the start of the displayed line that<br>were fetched before the pointers were changed. This can be avoided using double buffering<br>via the 2nd bitmap location register set, alternatively the unwanted pixels can be<br>masked with a wide border etc.</pre>
<pre><br><span style="text-decoration: underline;">Scan Line Timing Detail:</span></pre>
<pre>Each scanline lasts for 1024 16MHz clock cycles in PAL TV mode (1016 cycles in NTSC or VGA<br>modes). At the start of each line the CPU is taken offline by a BUSREQ signal for audio DMA.<br>(There is short, variable delay of a few cycles following a Bus Request whilst waiting for an<br>acknowledgment from the CPU). Once the audio system is online, it lasts around 20 clock cycles.<br>Following on, the LineCop has control of the main system bus for as long as the necessary to<br>complete the LineCop operations required on that line. Afterwards, the CPU continues normally<br>(as long as it not forced to wait by it accessing video or sprite memory during active display<br>lines).</pre>
<pre><br>Scanline Timing:<br><img style="width: 449px; height: 147px;" alt="Scanline timing diagram" src="images/scanline_timing.png"><br><br>Bitmap and sprite video data is fetched simultaneously and concurrently with the CPU<br>running normally as the three systems have their own memory buses. The time each<br>system requires to build its internal buffer is variable and depends on the amount of<br>data on a particular scan line.&nbsp; As mentioned, the CPU only has to wait if it tries to<br>access bitmap or sprite memory whilst data is being fetched by the relevant system.</pre>
<pre><br>The blitter and linedraw systems are also forced to wait during the bitmap fetch part<br>of a scan line. These systems have priority over the CPU in accessing video memory when<br>its free (not being read by the video system) and force the CPU to wait if the CPU<br>is trying access bitmap video memory at the same time. Active blits are paused at the<br>&#8220;last 16 cycles&#8221; point, ensuring the CPU is not waiting at the start of a scanline<br>(which could cause complications with the DMA functions). A paused blit continues<br>after the bitmap layer data fetch period.</pre>
<pre><br><span style="text-decoration: underline;">Video Frequencies etc:</span></pre>
<pre><br>Video output:<br><br> PAL non-interlaced : 50.0801 Hz, 312 lines per frame.</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;PAL interlaced : 50 Hz, 625 lines (312 / 313 lines)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Horizontal frequency : 15625 Hz</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Pixel clock : 8Mhz (Lo res) or 16MHz (Hi-res mode)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> NTSC non-interlaced&nbsp; : 60.106 Hz, 262 lines per frame.</pre>
<pre>	NTSC interlaced : 59.99 Hz, 525 lines (262 / 263 lines)</pre>
<pre>	Horizontal frequency : 15748 Hz<br>	<br>	Pixel clock : 8Mhz (Lo res) or 16MHz (Hi-res mode)</pre>
<pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>	<br>	VGA 60Hz : 60.106 Hz, 262 double-lines per frame<br><br>	Horizontal Frequency : 31496 Hz (line doubled)<br><br>	Pixel Clock : 16 Mhz (Low res only)</pre>
<pre>	VGA 50Hz* : 50.4 Hz, 312 double-lines per frame<br><br>	Horizontal Frequency : 31496 Hz (line doubled)<br><br>	Pixel Clock : 16 Mhz (Low res only)</pre>
<pre><br>* This is a non-standard mode and may not work on all VGA monitors.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<h3 style="text-decoration: underline;">Video Register
List:</h3>
<pre>Notes:</pre>
<pre>* The Video Registers are located between $0200-$07ff in Z80 address space, unless paged<br> out using the port: sys_alt_write_page</pre>
<pre>* All video registers are WRITE ONLY.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;">$200</span> = <span style="font-weight: bold;">"vreg_xhws</span>" - Horizontal Hardware Scroll&nbsp; (No effect in Chunky mode)</pre>
<pre>&nbsp;7:4 Playfield B Scroll position (0 - 15 pixels offset to the right) tile mode only.<br>&nbsp;3:0 Playfield A / Bitmap Mode Scroll position (0 - 15 pixels offset to the right.)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><span style="font-family: mon;"></span></span>
<pre><span style="font-weight: bold;"><br>$201</span> = "<span style="font-weight: bold;">vreg_vidctrl</span>" - Playfield Control</pre>
<pre>Certain bits of this register take on different meanings depending on the video mode:</pre>
<pre style="text-decoration: underline;">In Bitmap Mode (IE: When bit 0 is clear)</pre>
<pre>&nbsp; 7 &#8211; Enable &#8220;Chunky Pixel&#8221; Format (each video data byte fetched is a colour index)<br>&nbsp; 6 &#8211; Enable &#8220;Flood Mode&#8221; - for use with in Chunky Pixel mode<br>&nbsp; 5 - Use bitplane location registers A (0) or B (1) to point to the video data.<br>&nbsp; 4 &#8211; Not Used. <br>&nbsp; 3 &#8211; Enable Horizontal Expand Mode (For chunky mode only)<br>&nbsp; 2 - Video inhibit: 0 = Normal, 1 = Colour index 0 replaces all non-sprite video.<br>&nbsp; 1 - Wide Left Border: 0 = Normal, 1 = Mask first 16 pixels for x-scrolling. <br>&nbsp; 0 &#8211; Display mode: 0 = Bitmap Mode, 1 = Tilemap mode</pre>
<pre style="text-decoration: underline;">In Legacy Tile Map Mode (IE: When bit 0 is set and bit 0 of VREG_EXT_VIDCRTL is clear)</pre>
<pre>&nbsp; 7 - Dual Playfield Enable<br>&nbsp; 6 - Playfield B Map Buffer Select<br>&nbsp; 5 - Playfield A Map Buffer Select<br>&nbsp; 4 - Playfield B Tile Set Select <br>&nbsp; 3 - Playfield A Tile Set Select<br>&nbsp; 2 - Video inhibit: 0 = Normal, 1 = Colour index 0 replaces all non-sprite video.<br>&nbsp; 1 - Wide Left Border: 0 = Normal, 1 = Mask first 16 pixels for x-scrolling <br>&nbsp; 0 &#8211; Display mode: 0 = Bitmap Mode, 1 = Tilemap mode</pre>
<pre style="text-decoration: underline;">In Extended Tile Map Mode (IE: When bit 0 is set, and bit 0 of VREG_EXT_VIDCRTL is set)</pre>
<pre>&nbsp; 7 - Dual Playfield Enable<br>&nbsp; 6 - Playfield B Map Buffer Select<br>&nbsp; 5 - Playfield A Map Buffer Select<br>&nbsp; 4 &#8211; Definition swap (0= Normal, 1= tiles at $00000-$3FFFF switched with $40000-$7FFFF) &nbsp;<br>&nbsp; 3 &#8211; Tile size: 0 = Use 16x16 tiles, 1 = Use 8x8 tiles<br>&nbsp; 2 - Video inhibit: 0 = Normal, 1 = Colour index 0 replaces all non-sprite video.<br>&nbsp; 1 - Wide Left Border: 0 = Normal, 1 = Mask first 16 pixels for x-scrolling. <br>&nbsp; 0 &#8211; Display mode: 0 = Bitmap Mode, 1 = Tile map mode</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><span style="font-weight: bold;">$202</span> = "<span style="font-weight: bold;">vreg_window</span>" - Display Window Size&nbsp; - Sets size of display window.</pre>
<pre style="text-decoration: underline;">When Reg_switch is zero (bit 2 of vreg_rasthi is 0)</pre>
<pre>&nbsp;7:4 -&nbsp; Window Top (start) position (see table above for values)<br>&nbsp;3:0 -&nbsp; Window Bottom (stop) position (see table above for values)</pre>
<pre style="text-decoration: underline;">When Reg_switch is one (bit 2 of vreg_rasthi is 1)</pre>
<pre>&nbsp;7:4 - Window Left position (see table above for values)<br>&nbsp;3:0 - Window Right position (see table above for values)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;"><span style="font-family: monospace;"><br>
</span>
<pre><span style="font-weight: bold;">$203</span> = "<span style="font-weight: bold;">vreg_yhws_bplcount</span>" - Vertical Hardware Scroll Settings / Bitplane count</pre>
<pre><br>In Tilemap mode this register sets two separate hardware scroll values, one for each playfield.<br>To set the scroll value for playfield 0, write to this register with bit 7 clear. To set the scroll<br>value for playfield 1, write to this register with bit 7 set.</pre>
<pre>&nbsp;&nbsp; 7 - Select Playfield 0 / Playfield 1 Y-scroll register <br>&nbsp;6:4 - Not used<br>&nbsp;3:0 - Vertical Scroll offset value (0 to 15 pixels)</pre>
<pre><br>In Planar Bitmap Mode this register has a totally different use - setting the number of bitplanes in the display:</pre>
<pre>&nbsp;&nbsp;&nbsp; 7 - Write with this bit as ZERO<br>&nbsp; 6:3 - not used<br>&nbsp; 2:0 - Number of bitplanes (0= one bitplane to 7= eight bitplanes.)</pre>
<pre><br>In Chunky Bitmap mode this register sets the width of the pixels:</pre>
<pre>&nbsp;&nbsp;&nbsp; 7 - Write with this bit as ZERO<br>&nbsp; 6:3 - Not used<br>&nbsp; 2:0 - Width of pixels (0-7 = 1 to 8 pixels)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;">$204 =&nbsp; "vreg_rasthi"</span> - Raster IRQ MSB, enable, clear &amp; Window XY switch </pre>
<pre>&nbsp;&nbsp; 7 - Clear Raster IRQ flag *<br>&nbsp;6:3 - Not Used</pre>
<pre>&nbsp;&nbsp; 2 - Window Register X/Y switch<br>&nbsp;&nbsp; 1 - Enable Raster IRQ<br>&nbsp;&nbsp; 0 - Raster IRQ Scanline Position MSB</pre>
<pre>* When this register is written with bit 7 set, the video IRQ flag is cleared and the<br>rest of the register's contents are unchanged</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;">$205 = "vreg_rastlo"</span> -&nbsp; Raster IRQ line position </pre>
<pre>&nbsp;7:0 - Low 8 bits of Raster IRQ scanline position</pre>
<pre>&nbsp;The counter used in the line comparison starts 16 lines above the first visible <br>&nbsp;scanline (same as the sprites).&nbsp; Note: PAL, NTSC and VGA have different numbers of<br>&nbsp;scanlines and no interrupt will occur if this reqister and rasthi MSB are set<br>&nbsp;to a line the display mode never reaches.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;">$206 = "vreg_vidpage"</span> - Video Page Access Control </pre>
<pre><br>This register selects the 8KB page from the total 512K VRAM appearing at $2000-$3FFF<br>in Z80 address space and the 4KB sprite page accepting writes at $1000-$1fff.</pre>
<pre>&nbsp;When register written with bit 7 clear: Function is &#8220;set video page&#8221;.</pre>
<pre>&nbsp;&nbsp; 7 - Write as 0<br>&nbsp;&nbsp; 6 &#8211; Not used</pre>
<pre>&nbsp;5:0 - Video Page Selection (64 banks - 8KB each) when video memory is paged in.</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (When Direct VRAM Write mode is active, bits 5:3 select the 64KB bank.)</pre>
<pre>&nbsp;<br>&nbsp;When written with bit 7 set: Function is &#8220;Set sprite page&#8221;..</pre>
<pre>&nbsp;7&nbsp;&nbsp; - Write as 1<br>&nbsp;6:5 - Not used<br>&nbsp;4:0 &#8211; Sprite page selection (32 banks - 4KB each) when sprite RAM is paged in.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Note: Sprite RAM is write only)<br><br><br><span style="font-weight: bold;">$207 = "vreg_sprctrl"</span> - Sprite Control </pre>
<pre>&nbsp;&nbsp;&nbsp; 7 - Not used, write with zero<br>&nbsp;&nbsp;&nbsp; 6 - &#8220;Fix colours low&#8221; - when set, only colours $00-$7f are used for sprites.<br>&nbsp;&nbsp;&nbsp; 5 - "Matte Mode Enable"&nbsp; *<br>&nbsp;&nbsp;&nbsp; 4 - "Modify Colour MSBs"&nbsp; *<br>&nbsp;&nbsp;&nbsp; 3 &#8211; Enable double buffer sprite register mode.<br>&nbsp;&nbsp;&nbsp; 2 &#8211; Register bank select (use with double buffer register mode) **<br>&nbsp;&nbsp;&nbsp; 1 - Priority Interleave: 0 = All sprites are in foreground. 1 = interleave mode<br>&nbsp;&nbsp;&nbsp; 0 - Global Sprite Enable. All sprites are disabled when this bit is 0</pre>
<pre><br>* These modes force the upper bits of individual sprite height control registers to be<br>reassigned, see the sprite description text above for details.</pre>
<pre>** Sprite Register Bank select bit:</pre>
<pre>&nbsp;0 - Sprite hardware reads sprite registers $400 - $4fd<br>&nbsp;1 - Sprite hardware reads sprite registers $500 - $5fd<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;">$208 / $209 = "mult_write"</span> - 16 bit multiplier: </pre>
<pre>The signed word written here is multiplied by the word in the multiply table indexed by the<br>following register. 16 bits (29:14) from the resulting 32-bit word are read from "mult_read"<br>(the set of bits was chosen to provide fast scaling.) </pre>
<pre><br><span style="font-weight: bold;">$20A = "mult_index"</span> - Maths table index (byte): </pre>
<pre>Selects which word from the look up table is used for the multiplication.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="font-weight: bold;">$20B = "linedraw_colour"</span> - Line draw colour: </pre>
<pre><br>Colour table index for line draw hardware. (There is only a single colour register, so<br>to maintain a constant line colour, this value should not be changed whilst a line is<br>being drawn.)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre></pre>
<pre><br><span style="font-weight: bold;">$20c = "vreg_ext_vidctrl"</span> - Extended Video Mode Control Bits</pre>
<pre>&nbsp;&nbsp; &nbsp;7:4 &#8211; n/u<br>&nbsp;&nbsp; &nbsp;&nbsp; 3 &#8211; Enable Hi-Res 16 colour TV mode (no effect in VGA mode)<br>&nbsp;&nbsp; &nbsp;&nbsp; 2 - Enable interlaced TV mode (no effect on VGA output)<br>&nbsp;&nbsp; &nbsp;&nbsp; 1 - Flip Dual Playfield priorities (1 = PF B appears behind PF A)<br>&nbsp;&nbsp; &nbsp;&nbsp; 0 - Use extended tile indexes (1 = on, 0 = "legacy" 8 bit tile indexes)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre></pre>
<pre><br><span style="font-weight: bold;">$20d = "vreg_linecop_lo"</span>- LineCop LSB and Enable </pre>
<pre>&nbsp;&nbsp; &nbsp;7:1 - Linecop program location bits: 7:1<br>&nbsp;&nbsp; &nbsp;&nbsp; 0 - LineCop on/off (1 = enable)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><br><span style="font-weight: bold;">$20e = "vreg_linecop_hi"</span>- LineCop MSB </pre>
<pre><br>&nbsp;&nbsp; &nbsp;7:0 - Linecop program location bits 15:8</pre>
<pre>(Linecop programs must be located at $70000-$7FFFE in system RAM)</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><span style="font-weight: bold;">$20f = "vreg_palette_ctrl"</span>- Palette Control </pre>
<pre>This register allows independent access to two palette control bits: The "live"<br>palette (ie: that currently being used by the video hardware to fetch the colours)<br>and the palette which receives CPU / LineCop writes. So that each setting can be<br>changed independently (without reads) the register uses a bit (1) to select which<br>register is to be accessed and a bit (0) for the data to be written:</pre>
<pre>&nbsp; 7:2 - Not used (write with zeroes)<br>&nbsp;&nbsp;&nbsp; 1 - Choose to update "Live Palette Reg" (0) or "Target Palette Reg" (1)<br>&nbsp;&nbsp;&nbsp; 0 - Select palette 0 or 1</pre>
<pre>Note: Changes to the live palette selection take effect at the start of the next<br>scanline, whereas changes to the target palette register take effect immediately.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><span style="text-decoration: underline;">Blitter set-up registers: $210 - $21a:</span><br></pre>
<pre><span style="font-weight: bold;">$210 = "blit_src_loc" </span>- Source Address in VRAM Low 16 bits (little endian)<br><span style="font-weight: bold;">$212 = "blit_dst_loc"</span> - Destination Address in VRAM Low 16 bits (little endian)<br><span style="font-weight: bold;">$214 = "blit_src_mod"</span> - Source modulo [bits 7:0] **<br><span style="font-weight: bold;">$215 = "blit_dst_mod"</span> - Destination modulo [bits 7:0] **<br><span style="font-weight: bold;">$216 = "blit_height"</span>&nbsp; - Number of lines in blit - 1<br><span style="font-weight: bold;">$217 = "blit_width"&nbsp;</span>&nbsp; - Width of blit in bytes - 1 [Write starts the blit]<br><span style="font-weight: bold;">$218 = "blit_misc"</span>&nbsp;&nbsp;&nbsp; - Misc bits, see assignments below:</pre>
<pre><br>Bit&nbsp; 7 - Transparency mode: If 1 then zero value bytes read from source are not written.<br>&nbsp;&nbsp;&nbsp;&nbsp; 6 - Blit Direction: Ascending = 1 / Descending = 0 <br>&nbsp;&nbsp;&nbsp;&nbsp; 5 - Legacy destination Address MSb [bit 16] - see note below<br>&nbsp;&nbsp;&nbsp;&nbsp; 4 - Legacy source Address MSb [bit 16] - see note below<br>&nbsp;&nbsp;&nbsp;&nbsp; 3 - Destination Modulo bit 9 (Sign)<br>&nbsp;&nbsp;&nbsp;&nbsp; 2 - Destination Modulo bit 8<br>&nbsp;&nbsp;&nbsp;&nbsp; 1 - Source Modulo bit 9 (Sign)<br>&nbsp;&nbsp;&nbsp;&nbsp; 0 - Source Modulo bit 8</pre>
<pre>(blitter registers continued..)</pre>
<pre><br><span style="font-weight: bold;">$219 = "blit_src_msb"</span> - 2:0 highest three bits [18:16] of source address #<br><span style="font-weight: bold;">$21a = "blit_dst_msb"</span> - 2:0 highest three bits [18:16] of destination address #</pre>
<pre><br># Bit 16 is internally OR'd with the equivalent bit in "blit_misc", this is</pre>
<pre>&nbsp; for backwards compatibility. If you are only accessing video addresses &lt; 128KB<br>&nbsp; you can just use the "blit_misc" and ignore these two registers. Conversely if<br>&nbsp; you are generally using the entire VRAM range its best to use these registers<br>&nbsp; and write the MSB bits in "blit_misc" with zeroes.</pre>
<pre>Writing to &#8220;blit_width&#8221; actually starts the blit operation. Remember, the height<br>and width values should be the blit dimensions less one.</pre>
<pre><br><span style="text-decoration: underline;">Blitter Notes:</span></pre>
<pre>Following a blit, all the registers except "Width" (which has to be re-written<br>anyway) retain the values originally written to them.</pre>
<pre>Be wary when leaving the blitter running and returning to other code &#8211; this is<br>of course perfectly fine as long as the other code does not go on to access the<br>blitter's registers before it has finished a blit. The blitter status bit in<br>vreg_read should be examined by the code at relevant points to prevent clashing<br>blitter ops.</pre>
<pre>** The modulo is the number of bytes added to the end of the source and destination<br>counters at the end of each line. The polarity of these values is reversed by the<br>blit direction. So if in descending mode, a negative modulo will result in a<br>positive offset.</pre>
<pre>The modulo registers should not be changed whilst a blit is under way.</pre>
<pre><br><span style="text-decoration: underline;">Line Draw:</span><br><br>$220-$23f = Line draw set-up registers (all are 16 bit words)</pre>
<pre>The line draw system utilizes two main groups of registers: Control registers that<br>need to be set up for each line, and an overall look-up table that only needs to be<br>set up once on initialization.</pre>
<pre>The following four control words need to be set up for each line:</pre>
<pre><span style="font-weight: bold;">$220/1 = Linedraw_reg0</span> - Bresenham decision=0 constant: 2 x (dy - dx) *<br><span style="font-weight: bold;">$222/3 = Linedraw_reg1</span> - Bresenham decision=1 constant: 2 x (dy)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br><span style="font-weight: bold;">$224/5 = Linedraw_reg2</span> - Video RAM start address of line (bits 15:0)<br><span style="font-weight: bold;">$226/7 = Linedraw_reg3</span> - Composite word - see below. Also, writing to(the LSB of)<br>                         this register actually starts the line drawing operation, so<br>                         the line draw busy flag should be checked beforehand.</pre>
<pre><br>Linedraw_reg3 breakdown:</pre>
<pre>Bit 15&nbsp;&nbsp;&nbsp; : (Legacy) MSB of line's VRAM start address [Bit 16] - See bits 11:9<br>&nbsp;&nbsp;&nbsp; 14:12 : Octant code (bit12: dx is negative, bit13: dy is negative, bit14: dy =&gt; dx *<br>&nbsp;&nbsp;&nbsp; 11:9&nbsp; : Line VRAM start address: Bits 18:16 (NB: bit9 is internally OR'd with bit 15)<br>&nbsp;&nbsp;&nbsp; 8:0&nbsp;&nbsp; : Line length</pre>
<pre><br>*&nbsp; 1. Registers should be written with positive values, the sign of the value is held<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the octant code.</pre>
<pre>&nbsp;&nbsp; 2. If bit 14 of the composite word is set (because dy =&gt; dx) then the Bresenham<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decision 0 register should be loaded with 2 x (dx - dy) and decision register<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; should be loaded with 2 x (dx)</pre>
<pre>The next 4 register addresses (8 bytes) have the same function as registers $220-$227,<br>however they address separate internal locations. Having two sets of line-draw registers<br>allows one set to be loaded whilst a previous line draw operation is still running.<br>(The line_draw busy flag in vreg_read only needs to be checked before writing to the<br>LSB of linedraw_reg3/7 (which starts the linedraw) or the linedraw_colour register,<br>if changing colour.</pre>
<pre><span style="font-weight: bold;">$228/9 = linedraw_reg4</span> - Same function as $220/1 for register set 2<br><span style="font-weight: bold;">$22a/b = linedraw_reg5</span> - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "" $222/3 for register set 2<br><span style="font-weight: bold;">$22c/d = linedraw_reg6</span> - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "" $224/5 for register set 2<br><span style="font-weight: bold;">$22e/f = linedraw_reg7</span> - ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "" $226/7 for register set 2</pre>
<pre>The following 8 words form a look-up table used to offset the plot address of each<br>pixel, hence these registers need only be set once as part of an initialization routine,<br>IE: not per line.</pre>
<pre>$<span style="font-weight: bold;">230/1 = linedraw_lut0</span> - Pixel offset constant 0 .. (65536-Window width)+1 <br><span style="font-weight: bold;">$232/3 = linedraw_lut1</span> - Pixel offset constant 1 .. (65536-Window width)-1<br><span style="font-weight: bold;">$234/5 = linedraw_lut2</span> - Pixel offset constant 2 .. Window width + 1<br><span style="font-weight: bold;">$236/7 = linedraw_lut3</span> - Pixel offset constant 3 .. Window width - 1<br><span style="font-weight: bold;">$238/9 = linedraw_lut4</span> - Pixel offset constant 4 .. 1<br><span style="font-weight: bold;">$23a/b = linedraw_lut5</span> - Pixel offset constant 5 .. 65535<br><span style="font-weight: bold;">$23c/d = linedraw_lut6</span> - Pixel offset constant 6 .. (65536 - Window width)<br><span style="font-weight: bold;">$23e/f = linedraw_lut7</span> - Pixel offset constant 7 .. Window width </pre>
<pre>(See also: Line colour register $20B - "linedraw_colour")</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre style="text-decoration: underline;">Bitplane location registers: $240 - $27f: </pre>
<pre><span style="font-weight: bold;">$240 = bitplane0a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$244 = bitplane1a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$248 = bitplane2a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$24c = bitplane3a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$250 = bitplane4a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$254 = bitplane5a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$258 = bitplane6a_loc</span> (BPl register set A)<br><span style="font-weight: bold;">$25c = bitplane7a_loc</span> (BPl register set A)</pre>
<pre><br>$260-$27f = As above for Bitplane location register set B. Bit 5 of "vreg_vidctrl"<br>controls which set is used by the hardware to build the display.</pre>
<pre>Each bitplane location "register" is 4 bytes long, the data required for each is:</pre>
<pre>Offset:&nbsp; Data:<br>------------------------------------------------<br>+ 0&nbsp;&nbsp; =&nbsp; Location of Bitplane in video RAM [7:0]<br>+ 1&nbsp;&nbsp; =&nbsp; Location of Bitplane in video RAM [15:8]<br>+ 2&nbsp;&nbsp; =&nbsp; Location of Bitplane in video RAM [18:16]<br>+ 3&nbsp;&nbsp; =&nbsp; Reset internal offset counter / Set Modulo - see notes below</pre>
<pre><br>Notes:</pre>
<pre>The value written to the bitplane location registers only needs to be set once,<br>an internal offset counter is added to the address as the frame is built up. There is<br>only one offset counter which acts on all the bitplanes - it can be reset to zero by<br>writing to the 4th byte of the even-numbered bitplane pointers (eg: bitplane0a_loc+3)<br>this actually takes effect at the start of the next scanline. </pre>
<pre>In chunky pixel mode, there is only one data-fetch start address, that is: bitplane0a/b</pre>
<pre><br><span style="text-decoration: underline;">Modulo:</span><br><br>The modulo register holds the number of words to skip at the right of each<br>scanline (positive only). This allows a window from within a larger image to be<br>displayed (EG: can be used for scrolling and skipping lines in interlaced displays).<br>There is one modulo register, it is located at the 4th byte of the odd-numbered<br>bitplane registers (EG: bitplane1a+3) - as mentioned, the granularity is 2 bytes<br>so for example a written value of 1 skips 2 bytes each line. The value in this<br>register is internally latched at the start of each scanline and because of the<br>way it is implemented there is an upper limit on the value it can hold (depends<br>on the display mode) - values up to 192 (IE: skip 384 bytes) are OK. There is<br>also a special case: If $FF is written to the modulo register the bitmap offset<br>counter is reset at the start of each scanline, IE: With no other changes, the<br>same line is used over and over.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<pre><br><span style="text-decoration: underline;">Sprite priority mask registers $280 - $28F: <span style="font-weight: bold;">"priority_registers"</span></span></pre>
<pre>$280: Bit 0: bgnd colours 00-0F mask level 0, Bit 1: bgnd colours 00-0F mask level 1<br>$281: Bit 0: bgnd colours 10-1F mask level 0, Bit 1: bgnd colours 10-1F mask level 1<br>$282: Bit 0: bgnd colours 20-2F mask level 0, Bit 1: bgnd colours 20-2F mask level 1<br>$283: Bit 0: bgnd colours 30-3F mask level 0, Bit 1: bgnd colours 30-3F mask level 1<br>$284: Bit 0: bgnd colours 40-4F mask level 0, Bit 1: bgnd colours 40-4F mask level 1<br>$285: Bit 0: bgnd colours 50-5F mask level 0, Bit 1: bgnd colours 50-5F mask level 1<br>$286: Bit 0: bgnd colours 60-6F mask level 0, Bit 1: bgnd colours 60-6F mask level 1<br>$287: Bit 0: bgnd colours 70-7F mask level 0, Bit 1: bgnd colours 70-7F mask level 1<br>$288: Bit 0: bgnd colours 80-8F mask level 0, Bit 1: bgnd colours 80-8F mask level 1<br>$289: Bit 0: bgnd colours 90-9F mask level 0, Bit 1: bgnd colours 90-9F mask level 1<br>$28A: Bit 0: bgnd colours A0-AF mask level 0, Bit 1: bgnd colours A0-AF mask level 1<br>$28B: Bit 0: bgnd colours B0-BF mask level 0, Bit 1: bgnd colours B0-BF mask level 1<br>$28C: Bit 0: bgnd colours C0-CF mask level 0, Bit 1: bgnd colours C0-CF mask level 1<br>$28D: Bit 0: bgnd colours D0-DF mask level 0, Bit 1: bgnd colours D0-DF mask level 1<br>$28E: Bit 0: bgnd colours E0-EF mask level 0, Bit 1: bgnd colours E0-EF mask level 1<br>$28F: Bit 0: bgnd colours F0-FF mask level 0, Bit 1: bgnd colours F0-FF mask level 1<br><br><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><span style="text-decoration: underline;">Maths Assist Table:</span><br><br>$600-$7FF = "mult_table" WRITE ONLY </pre>
<pre>This table holds 256 signed 16 bit words. The entry selected by "mult_index" is<br>multiplied by the signed word in "mult_write" and 16 bits [29:14] of the 32 bit<br>result appears in "mult_read"</pre>
<pre><br>$700 = "vreg_read" - READ ONLY Status Register (Also available in port: sys_vreg_read)</pre>
<pre>&nbsp;&nbsp; 7 - Interlace field 0 = short field, 1 = long field <br>&nbsp;&nbsp; 6 - LSB of scanline count<br>&nbsp;&nbsp; 5 - 60Hz mode (1 = NTSC config / VGA mode jumper installed and 50Hz not forced.)<br>&nbsp;&nbsp; 4 - Blitter / linedraw status (1 = busy). Check before changing relevant registers <br>&nbsp;&nbsp; 3 - Raster IRQ status (for manual polling)<br>&nbsp;&nbsp; 2 - Y Window (1 = display area, 0 = border)<br>&nbsp;&nbsp; 1 - X Window&nbsp; (1 = display area, 0 = border) *<br>&nbsp;&nbsp; 0 - Last line (VRT). Set during the last line of each frame.</pre>
<pre>* Remember, in VGA mode each scanline's data is output twice at double the normal frequency.<br>This flag reflects the x-window of the normal PAL/NTSC ~15KHz scanline.<br><br><br>$704-705 = "mult_read" READ ONLY - Maths unit result (little endian): </pre>
<pre>Bits 29:14 from the longword result of the maths unit operation appear here.</pre>
<pre><br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br></pre>
<h3><span style="text-decoration: underline;">OSCA's
ROM</span> </h3>
<pre>OSCA locates a boot ROM at $0000-$01FF - this is contained within the FPGA config<br>file.&nbsp; At reset, the ROM clears the following ports and video registers:<br><br>sys_mem_select<br>sys_alt_write_page<br>sys_low_page<br>sys_irq_enable<br>sys_audio_enable<br>sys_ps2_joy_control<br>sys_vram_location<br>sys_timer<br>vreg_sprctrl <br>palette (IE: background colour = $000)<br><br>All interrupts are disabled (IRQs via the Z80 DI instruction and NMIs via <br>bit 0 of sys_hw_settings). The IRQ vector (at $0038) has the instruction<br>"JP $0A00", and the NMI vector (at $0066) has the instruction "JP $0A03".<br>OSCA is designed to use Interrupt Mode 1. <br><br>The ROM then attempts to load the main boot code from the onboard EEPROM.<br>Two locations are checked:<br><br>EEPROM Block 0: $F000 [Primary bootcode location]<br>EEPROM Block 1: $F000 [Backup bootcode location]<br><br>To test for bootcode, a "databurst" command is sent to a PIC microcontroller<br>which responds by sending 3520 bytes from the EEPROM. The ROM reads this data<br>into system RAM $0200 onwards, checks the CRC checksum (held in the last two<br>bytes) and executes it (with a JP $200) if the checksum is good.<br><br> (If the CRC doesn't match, the screen flashes magenta and the databurst is requested<br> again from the backup. If this also fails, the screen goes grey indicating that a<br> bootcode file should be downloaded via the serial link at 115KBPS. This grey screen<br> condition can also be forced by holding up, right and fire on a joystick in port 2 <br> at power up. If at any point the screen flashes yellow, there was a time-out during<br> the EEPROM databurst.)<br><br> <br><span style="text-decoration: underline;">Placing alternate data at $0000-$01FF:</span><br><br>It is possible to have read/write access the system RAM "underneath" the OSCA<br>ROM/Palette at $000-$1ff (see the port "sys_alt_write_page"). In all there are<br>three options for this memory range:<br><br>A) Read ROM / Write palette (default)<br>B) Read system RAM / write palette (set by bit 4 of sys_alt_write_page)<br>c) Read System RAM / write system RAM (set by bit 6 of sys_alt_write_page)<br><br>The IRQ vectors must be set appropriately in system RAM when non-ROM reads are<br>enabled (and interrupts are required).<br><span style="font-weight: bold;"><br><br></span></pre>
<hr style="width: 100%; height: 2px;">
<pre><span style="font-weight: bold;"></span></pre>
<h1>INDEX:</h1>
<pre><br></pre>
<h3 style="text-decoration: underline;">Port List:</h3>
<pre>Port: Dir: Name:<br>-----------------------<br>$00 R/W sys_mem_select<br>$01 R sys_irq_ps2_flags<br>$01 W sys_irq_enable<br>$02 R sys_keyboard_data<br>$02 W sys_clear_irq_flags<br>$03 R sys_mouse_data<br>$03 W sys_ps2_joy_control<br>$04 R/W sys_serial_port<br>$05 R sys_joy_com_flags<br>$05 W sys_sdcard_ctrl1 <br>$06 R/W sys_sdcard_ctrl2 <br>$07 R sys_vreg_read<br>$07 W sys_timer <br>$08 R sys_audio_flags<br>$08 W sys_audio_enable<br>$09 R sys_hw_flags <br>$09 W sys_hw_settings <br>$0a R/W sys_spi_port <br>$0b R/W sys_alt_write_page<br>$0c W sys_baud_rate <br>$0d R sys_eeprom_byte <br>$0d W sys_pic_comms <br>$0e R/W sys_io_pins <br>$0f R/W sys_io_dir <br><br>$10 W audchan0_loc<br>$11 W audchan0_len<br>$12 W audchan0_per<br>$13 W audchan0_vol<br>$14 W audchan1_loc<br>$15 W audchan1_len<br>$16 W audchan1_per<br>$17 W audchan1_vol<br>$18 W audchan2_loc<br>$19 W audchan2_len<br>$1a W audchan2_per<br>$1b W audchan2_vol<br>$1c W audchan3_loc<br>$1d W audchan3_len<br>$1e W audchan3_per<br>$1f W audchan3_vol<br><br>$20 R/W sys_low_page <br>$21 W sys_vram_location<br>$22 W sys_audio_panning <br><br>$24 W audchan0_loc_hi<br>$24 W audchan1_loc_hi<br>$24 W audchan2_loc_hi<br>$24 W audchan3_loc_hi<br><br></pre>
<h3 style="text-decoration: underline;">Video Register
List:</h3>
<pre>($000-$6FF are all write only)<br><br><br>Location: Size: Name:<br>---------------------<br><br>$0000 256*W palette <br><br>$0200 B vreg_xhws<br>$0201 B vreg_vidctrl<br>$0202 B vreg_window<br>$0203 B vreg_yhws_bplcount<br>$0204 B vreg_rasthi<br>$0205 B vreg_rastlo<br>$0206 B vreg_vidpage<br>$0207 B vreg_sprctrl<br>$0208 B mult_write<br>$020a B mult_index<br>$020b B linedraw_colour<br>$020c B vreg_ext_vidctrl<br>$020d B vreg_linecop_lo<br>$020e B vreg_linecop_hi<br>$020f B vreg_palette_ctrl<br><br>$0210 W blit_src_loc<br>$0212 W blit_dst_loc<br>$0214 B blit_src_mod<br>$0215 B blit_dst_mod<br>$0216 B blit_height<br>$0217 B blit_width<br>$0218 B blit_misc<br>$0219 B blit_src_msb<br>$021a B blit_dst_msb<br><br>$0220 W linedraw_reg0<br>$0222 W linedraw_reg1<br>$0224 W linedraw_reg2<br>$0226 W linedraw_reg3<br>$0228 W linedraw_reg4 <br>$022a W linedraw_reg5<br>$022c W linedraw_reg6<br>$022e W linedraw_reg7<br><br>$0230 W linedraw_lut0<br>$0232 W linedraw_lut1<br>$0234 W linedraw_lut2<br>$0236 W linedraw_lut3<br>$0238 W linedraw_lut4 <br>$023a W linedraw_lut5<br>$023c W linedraw_lut6<br>$023e W linedraw_lut7<br><br>$0240 T bitplane0a_loc<br>$0243 B bitplane_reset<br>$0244 T bitplane1a_loc<br>$0247 B bitplane_modulo<br>$0248 T bitplane2a_loc<br>$024c T bitplane3a_loc<br>$0250 T bitplane4a_loc<br>$0254 T bitplane5a_loc<br>$0258 T bitplane6a_loc<br>$025c T bitplane7a_loc<br><br>$0260 T bitplane0b_loc<br>$0264 T bitplane1b_loc<br>$0268 T bitplane2b_loc<br>$026c T bitplane3b_loc<br>$0270 T bitplane4b_loc<br>$0274 T bitplane5b_loc<br>$0278 T bitplane6b_loc<br>$027C T bitplane7b_loc<br><br>$0280 16*B priority_registers<br><br>$0400 128*D sprite_registers<br><br>$0600 256*W mult_table<br><br>$0700 B vreg_read (READ ONLY)<br>$0704 W mult_read (READ ONLY)<br><br><br><span style="text-decoration: underline;">Size key:</span><br><br>B = byte, W = word, T = triple byte, D = Double Word<br></pre>
<hr style="width: 100%; height: 2px;">
<pre><br><br><br>[END]</pre>
</body></html>