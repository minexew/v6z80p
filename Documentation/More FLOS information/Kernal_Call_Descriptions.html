<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>FLOS Kernal Calls</title></head>
<body><span style="text-decoration: underline; font-weight: bold;">List of FLOS kernal calls - last updated 1-12-2011 for FLOS v591</span><br><br><span style="text-decoration: underline;">File System Routines:</span><br><br><span style="font-weight: bold;"><a href="#kjt_check_volume_format">kjt_check_volume_format</a> </span>&nbsp;- Checks if current volume is formatted to FAT16.<br><a href="#kjt_change_volume"><span style="font-weight: bold;">kjt_change_volume</span></a> - Selects drives VOL0: to VOL7:<br><a href="#kjt_get_volume_info"><span style="font-weight: bold;">kjt_get_volume_info</span></a> - Returns data about the volumes mounted<br><a href="#kjt_format_device"><span style="font-weight: bold;">kjt_format_device</span></a> -Formats entire disk (or card) to FAT16<br><a href="#kjt_make_dir"><span style="font-weight: bold;">kjt_make_dir</span></a> -Creates a new sub directory in current directory<br><a href="#kjt_change_dir"><span style="font-weight: bold;">kjt_change_dir</span></a> - Change to subdirectory<br><a href="#kjt_parent_dir"><span style="font-weight: bold;">kjt_parent_dir</span></a> -Move up a directory level<br><a href="#kjt_root_dir"><span style="font-weight: bold;">kjt_root_dir</span></a> -Go to root directory of drive<br><a href="#kjt_delete_dir"><span style="font-weight: bold;">kjt_delete_dir</span></a> - Deletes an (empty) directory<br><a href="#kjt_erase_file"><span style="font-weight: bold;">kjt_erase_file</span></a> -Deletes a file<br><a href="#kjt_get_total_sectors"><span style="font-weight: bold;">kjt_get_total_sectors</span></a> - Returns total sectors on current volume<br><span style="font-weight: bold;"><a href="#kjt_load_file">kjt_load_file</a> </span>- Loads a file in its entirety from disk to RAM<br><a href="#kjt_save_file"><span style="font-weight: bold;">kjt_save_file</span> </a>- Creates and saves a file from RAM to disk<br><a href="#kjt_open_file"><span style="font-weight: bold;">kjt_open_file</span></a> - Looks for a file on current disk, resets file pointer etc<br><a href="#kjt_set_file_pointer"><span style="font-weight: bold;">kjt_set_file_pointer</span></a> - Moves the read point from the start of a file<br><a href="#kjt_set_read_length"><span style="font-weight: bold;">kjt_set_read_length</span></a> - Sets the read length of a file transfer to a certain value<br><a href="#kjt_read_from_file"><span style="font-weight: bold;">kjt_read_from_file</span></a> - Reads data from the opened file to RAM<br><a href="#kjt_create_file"><span style="font-weight: bold;">kjt_create_file</span> </a>-Makes a new file stub.<br><a href="#kjt_write_to_file"><span style="font-weight: bold;">kjt_write_to_file</span></a> - Appends new data to an existing file.<br><a href="#kjt_dir_list_first_entry"><span style="font-weight: bold;">kjt_dir_list_first_entry</span></a> &#8211; Find first entry in current directory.<br><a href="#kjt_dir_list_get_entry"><span style="font-weight: bold;">kjt_dir_list_get_entry</span></a> - Returns data from directory list (see output registers)<br><a href="#kjt_dir_list_next_entry"><span style="font-weight: bold;">kjt_dir_list_next_entry</span> </a>- Moves directory list pointer to the next entry<br><a href="#kjt_get_dir_name"><span style="font-weight: bold;">kjt_get_dir_name</span></a> - Returns the name of the current directory.<br><a href="#kjt_mount_volumes"><span style="font-weight: bold;">kjt_mount_volumes</span></a> - Initializes the attached disk list.<br><a href="#kjt_store_dir_position"><span style="font-weight: bold;">kjt_store_dir_position</span></a> - Internally remembers the current directory position.<br><a href="#kjt_restore_dir_position"><span style="font-weight: bold;">kjt_restore_dir_position</span></a> &#8211; Restores directory to that stored by above.<br><a href="#kjt_get_device_info"><span style="font-weight: bold;">kjt_get_device_info</span></a> &#8211; Returns info about the storage devices.<br><a href="#kjt_get_dir_cluster"><span style="font-weight: bold;">kjt_get_dir_cluster</span> </a>- Returns the cluster address of the current dir<br><a href="#kjt_set_dir_cluster"><span style="font-weight: bold;">kjt_set_dir_cluster</span></a> - Sets the dir from a cluster address<br><a href="#kjt_rename_file"><span style="font-weight: bold;">kjt_rename_file</span></a> - Renames files and directories<br><br><span style="text-decoration: underline;">Low-Level Sector Access Routines:</span><br><br><a href="#kjt_read_sector"><span style="font-weight: bold;">kjt_read_sector</span></a> - Loads 512 byte sector to the sector buffer<br><a href="#kjt_write_sector"><span style="font-weight: bold;">kjt_write_sector</span></a> -Writes 512 byte sector to the current device<br><a href="#kjt_file_sector_list"><span style="font-weight: bold;">kjt_file_sector_list</span></a> - To list the disk sectors that files occupy<br><br><span style="text-decoration: underline;">Kernal Serial Comms Routines:</span><br><br><a href="#kjt_serial_receive_header"><span style="font-weight: bold;">kjt_serial_receive_header</span></a> - Waits for a file header from serial port<br><a href="#kjt_serial_receive_file"><span style="font-weight: bold;">kjt_serial_receive_file</span></a> - Receives serial file data<br><a href="#kjt_serial_send_file"><span style="font-weight: bold;">kjt_serial_send_file</span></a> - Sends a file to serial port (Serial Link App format)<br><a href="#kjt_serial_rx_byte"><span style="font-weight: bold;">kjt_serial_rx_byte</span></a> - Wait for a byte from serial port<br><a href="#kjt_serial_tx_byte"><span style="font-weight: bold;">kjt_serial_tx_byte</span></a> - Send a byte to serial port<br><br><span style="text-decoration: underline;">Kernal Keyboard And Mouse Routines</span><br><br><a href="#kjt_wait_key_press"><span style="font-weight: bold;">kjt_wait_key_press</span></a> - Pauses until a key is pressed<br><span style="font-weight: bold;"><a href="#kjt_get_key">kjt_get_key</a> </span>- Returns value of key, if one has been pressed (does not wait)<br><span style="font-weight: bold;"><a href="#kjt_get_key_mod_flags">kjt_get_key_mod_flags</a> </span>- Returns status of the shift, ctrl, alt etc keys<br><a href="#kjt_enable_mouse"><span style="font-weight: bold;">kjt_enable_mouse</span></a> - Activates mouse driver (enables IRQ etc).<br><a href="#kjt_get_mouse_position"><span style="font-weight: bold;">kjt_get_mouse_position</span></a> - Returns absolute mouse position and button data<br><a href="#kjt_get_mouse_motion_"><span style="font-weight: bold;">kjt_get_mouse_motion</span></a> - Returns relative mouse displacement<br><a href="#kjt_keyboard_irq_code"><span style="font-weight: bold;">kjt_keyboard_irq_code</span></a> - Allows external apps to invoke FLOS keybaord IRQ code<br><a href="#kjt_mouse_irq_code"><span style="font-weight: bold;">kjt_mouse_irq_code</span></a> - Allows external apps to invoke FLOS mouse IRQ code<br><a href="#kjt_get_key_buffer"><span style="font-weight: bold;">kjt_get_key_buffer</span></a> - Allows monitoring of the keyboard without affecting the buffer.<br><br><span style="text-decoration: underline;">Kernal Text and Display Routines</span><br><br><a href="#kjt_print_string"><span style="font-weight: bold;">kjt_print_string</span></a> - Prints ASCII text string at the current cursor position<br><a href="#kjt_clear_screen"><span style="font-weight: bold;">kjt_clear_screen</span></a> - Clears OS screen and sets cursor position to top left (0,0)<br><a href="#kjt_plot_char"><span style="font-weight: bold;">kjt_plot_char</span> </a>- Prints character at given coords using current pen colours<br><a href="#kjt_set_pen"><span style="font-weight: bold;">kjt_set_pen</span></a> - Changes current pen colour<br><span style="font-weight: bold;"><a href="#kjt_get_pen_">kjt_get_pen</a> </span>- Returns current pen colour<br><a href="#kjt_background_colours"><span style="font-weight: bold;">kjt_background_colours</span></a> - Change FLOS paper and border colours<br><span style="font-weight: bold;"><a href="#kjt_draw_cursor">kjt_draw_cursor</a> </span>- Draws (or removes) the cursor at the current cursor position<br><a href="#kjt_get_input_string"><span style="font-weight: bold;">kjt_get_input_string</span></a> - Waits for user to enter a string of characters<br><span style="font-weight: bold;"><a href="#kjt_set_cursor_position">kjt_set_cursor_position</a> </span>- Repositions the text printing (cursor) position<br><a href="#kjt_get_cursor_position"><span style="font-weight: bold;">kjt_get_cursor_position</span></a> - Returns the current cursor position<br><a href="#kjt_scroll_up"><span style="font-weight: bold;">kjt_scroll_up</span></a> - Scrolls the screen (and character map) up a line.<br><span style="font-weight: bold;"><a href="#kjt_flos_display">kjt_flos_display</a> </span>- Restores the video registers to the state used by the OS. <br><a href="#kjt_get_display_size"><span style="font-weight: bold;">kjt_get_display_size</span></a> -Returns size of OS_window<br><a href="#kjt_get_charmap_addr_xy"><span style="font-weight: bold;">kjt_get_charmap_addr_xy</span></a> - Returns the charmap address of coordinates x,y<br><span style="font-weight: bold;"><a href="#kjt_wait_vrt">kjt_wait_vrt</a> </span>- Wait for vertical retrace (IE: last scanline of display)<br><br style="text-decoration: underline;"><span style="text-decoration: underline;">Kernal Memory Management Routines:</span><br><br><a href="#kjt_set_bank"><span style="font-weight: bold;">kjt_set_bank</span></a> - Switches the upper RAM page to a specific bank<br><a href="#kjt_get_bank"><span style="font-weight: bold;">kjt_get_bank</span></a> - Returns the current bank number in A<br><a href="#kjt_inc_bank"><span style="font-weight: bold;">kjt_inc_bank</span></a> - Change to the next bank<br><a href="#kjt_page_in_video"><span style="font-weight: bold;">kjt_page_in_video</span></a> - Pages video memory into $2000-$3FFF<br><a href="#kjt_page_out_video"><span style="font-weight: bold;">kjt_page_out_video</span></a> - Pages system memory into $2000-$3FFF<br><a href="#kjt_read_sysram_flat"><span style="font-weight: bold;">kjt_read_sysram_flat</span></a> - read flat system memory location (E:HL) into A<br><span style="font-weight: bold;"><a href="#kjt_write_sysram_flat">kjt_write_sysram_flat</a> </span>- write A into flat system memory location (E:HL)<br><br><span style="text-decoration: underline;">Kernal Misc Routines:</span><br><br><span style="font-weight: bold;"><a href="#kjt_hex_byte_to_ascii">kjt_hex_byte_to_ascii</a> </span>&#8211; Make ASCII version of a hex byte<br><span style="font-weight: bold;"><a href="#kjt_ascii_to_hex_word">kjt_ascii_to_hex_word</a> </span>- Converts text hex number to real hex word<br><a href="#kjt_dont_store_registers"><span style="font-weight: bold;">kjt_dont_store_registers</span></a> &#8211; Stops the OS updating the stored register values on exit<br><a href="#kjt_get_version"><span style="font-weight: bold;">kjt_get_version</span></a> - Returns OS and hardware ID numbers<br><a href="#kjt_compare_strings"><span style="font-weight: bold;">kjt_compare_strings</span></a> - Compares two ASCII strings<br><span style="font-weight: bold;"><a href="#kjt_bchl_memfill_">kjt_bchl_memfill</a> </span>- Fill memory with value in accumulator<br><a href="#kjt_timer_wait_"><span style="font-weight: bold;">kjt_timer_wait</span> </a>- Waits n periods of 16 microseconds and returns<br><span style="font-weight: bold;"><a href="#kjt_set_commander">kjt_set_commander</a> </span>- Specifies a command string to be run when programs exit<br><br><span style="text-decoration: underline;">Environment Variable Routines:</span><br><br><span style="font-weight: bold;"><a href="#kjt_set_envar">kjt_set_envar</a>&nbsp;</span>&nbsp;&nbsp; - Sets/updates an environment variable<br><a href="#kjt_get_envar"><span style="font-weight: bold;">kjt_get_envar</span></a>&nbsp;&nbsp;&nbsp; - Gets (address of) value of an environment variable<br><span style="font-weight: bold;"><a href="#kjt_delete_envar">kjt_delete_envar</a> </span>- Deletes an environment variable<br><br><br><hr style="width: 100%; height: 2px;">FILE SYSTEM RELATED CALLS - &nbsp;Some Details:<br><hr style="width: 100%; height: 2px;"><br>There are two ways to load a file, a simple single-call approach and a more flexible random-access approach.<br><br>To
load a file simply, set HL to a zero terminated ASCII filename string,
IX to the destination address and B to the destination bank, then call
"kjt_load_file" - check the return code (if the zero flag is set,
everything is OK).<br><br>The more flexible way to load file data is as
follows: Set HL to a zero terminated ASCII filename string and call
"kjt_find_file". If the zero flag is set on return, the file was found
the length of the file will be in IX:IY (if the zero flag is not set,
check the error code flags).<br><br>Next, the following two routines can be called *if required*<br><br>&nbsp;*
"kjt_set_file_pointer" - this allows data to be read from anywhere
within a file, instead of right from the start. Registers required:<br><br>&nbsp;&nbsp;&nbsp; IX:IY = Offset in bytes from start of file. &nbsp;&nbsp; &nbsp;<br><br><br>&nbsp;* "kjt_set_file_length" - allows the length of transfer to be set.&nbsp;Registers required:<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; IX:IY = Bytes to load. <br><br><br>Finally, "kjt_read_file_data" should be called to transfer the data to memory.<br><br>&nbsp; Registers required:<br>&nbsp; &nbsp;<br>&nbsp;&nbsp; HL = Load address.<br>&nbsp;&nbsp; B&nbsp; = Bank of load address.<br><br>Again, on return, if the zero flag is set then the operation completed OK.<br><br>The
file pointer is automatically incremented by the number of bytes
transferred, therefore it is not necessary call "kjt_set_file_pointer"
each time if&nbsp;chunks of a file are required sequentially.
Attempting to read beyond the end of a file will return an error (code
$1B). The load length MUST be set for each read (and load address set
appropriately each call). <br><br>To maintain speed, a fresh seek from
the start of the file is not performed each time "kjt_read_file_data"
is called unless the filepointer has been changed. Internal variables
must be maintained, therefore do not perform any other &nbsp;disk /
serial operations (or anything that changes the sector buffer) between
successive calls to this routine.<br><br>Whenever a disk file transfer reaches address $FFFF, it wraps around to $8000 and continues onto the next bank. <br><br>Most of the file system kernal calls return one of these standard error codes:<br><br>&nbsp; If the zero flag is set, the operation was a success.<br>&nbsp; If the zero flag is not set, there was an error. A = error code:<br><br>&nbsp;&nbsp;&nbsp; $00 - Hardware error: B contains the device's H/W error code (If B = 0 it timed out).<br>&nbsp;&nbsp;&nbsp; $01 - Disk full<br>&nbsp;&nbsp;&nbsp; $02 - File not found<br>&nbsp;&nbsp;&nbsp; $03 - (Root) dir table is full<br>&nbsp;&nbsp;&nbsp; $04 - Directory requested is actually a file<br>&nbsp;&nbsp;&nbsp; $05 - Cant delete dir, it is not empty<br>&nbsp;&nbsp;&nbsp; $06 - Not a file<br>&nbsp;&nbsp;&nbsp; $07 - File length is zero<br>&nbsp;&nbsp;&nbsp; $08 - File too big (IE: Memory address out of range)<br>&nbsp;&nbsp;&nbsp; $09 - Filename already exists<br>&nbsp;&nbsp;&nbsp; $0a - Already at root directory<br>&nbsp;&nbsp;&nbsp; $0e - Invalid filename<br>&nbsp;&nbsp;&nbsp; $13 - Unknown/incorrect disk format<br>&nbsp;&nbsp;&nbsp; $1b - Requested bytes beyond EOF<br>&nbsp;&nbsp;&nbsp; $1e - Bad range (sector out of range)<br>&nbsp;&nbsp;&nbsp; $21 - Invalid disk <br>&nbsp;&nbsp;&nbsp; $22 - Device not present&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; $23 - Directory not found<br>&nbsp;&nbsp;&nbsp; $24 - End of directory list<br>&nbsp;&nbsp;&nbsp; $25 - Device does not use MBR<br>&nbsp;&nbsp;&nbsp; $26 - Cant find volume label<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_check_volume_format"></a>&nbsp;kjt_check_volume_format</span><br><br>Action: Checks if current volume is available and formatted to FAT16<br><br>Input Registers&nbsp; : None<br><br>Output Registers : Standard error codes <br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_change_volume"></a>&nbsp;kjt_change_volume</span><br><br>Action: Selects a new volume<br><br>Input Registers&nbsp; : A = volume to select<br><br>Output Registers :&nbsp; Standard error codes <br><br>Notes: Will not allow a change to an invalid Volume (non-FAT16 etc)<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_format_device"></a>&nbsp;kjt_format_device</span><br><br>Action: Formats a device (entire drive as single partition, no MBR)<br><br>Input Registers&nbsp; :<br><br>A&nbsp; = Device to format<br>HL = Disk label ascii <br><br>Output Registers : Standard error codes <br><br>Notes: It is highly recommended that "kjt_mount_volumes" is called after this routine.<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_make_dir"></a>kjt_make_dir</span><br><br>Action: Creates a new sub directory in current directory<br><br>Input Registers:<br><br>HL = zero terminated dir name<br><br>Output Registers : Standard error codes <br><br><hr style="width: 100%; height: 2px;"><a name="kjt_change_dir"></a><br><span style="font-weight: bold;">&nbsp;kjt_change_dir</span><br><br>Action: Change to subdirectory<br><br>Input Registers:<br><br>HL = zero terminated dir name<br><br>Output Registers : Standard error codes <br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_parent_dir"></a>kjt_parent_dir</span><br><br>Action: Move up a directory level<br><br>Input Registers&nbsp; : None<br><br>Output Registers : Standard error codes<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_root_dir"></a>&nbsp;kjt_root_dir</span><br><br>Action: Go to root directory of drive<br><br>Input Registers&nbsp; : None<br><br>Output Registers : Standard error codes<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_delete_dir"></a>kjt_delete_dir</span><br><br>Action: Deletes an (empty) directory<br><br>Input Registers&nbsp; :<br><br>HL = zero terminated dir name<br><br>Output Registers : Standard error codes<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_erase_file"></a>kjt_erase_file</span><br><br>Action: Deletes a file<br><br>Input Registers&nbsp; :<br><br>HL = zero terminated file name<br><br>Output Registers : Standard error codes<br><br><br><hr style="width: 100%; height: 2px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><span style="font-weight: bold;"><a name="kjt_get_total_sectors"></a>kjt_get_total_sectors</span><br><br>Action: Returns total sectors on current volume<br><br>Input Registers&nbsp; : none<br><br>Output Registers :<br><br>C:DE = number of sectors<br><br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br><a name="kjt_load_file"></a>kjt_load_file</span><br><br>Action: Loads the specified file in its entirity to the specifed address.<br><br>Input registers:<br><br>IX&nbsp;&nbsp; = address to load to<br>B&nbsp;&nbsp;&nbsp; = bank to load to<br>HL&nbsp;&nbsp; = zero terminated filename<br><br>Output registers: Standard error codes <br><br>Notes:<br><br>This
routine both opens a file and reads all the data to RAM - for more
flexibility use "kjt_open_file", "kjt_set_file_pointer",
"kjt_set_read_length" and "kjt_read_file_data"<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_save_file"></a>kjt_save_file</span><br><br>Action: Saves a file to current disk / directory.<br><br>Input registers:<br><br>IX&nbsp;&nbsp; = Source data start address<br>B&nbsp;&nbsp;&nbsp; = bank to save data from<br>C:DE = number of bytes to save<br>HL&nbsp;&nbsp; = zero terminated filename<br><br>Output registers: Standard error codes <br><br>Notes:<br><br>This
routine both creates a new file and saves data to it - it cannot be
used append new data to an existing file (will return "file already
exists" error if attempted).<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_open_file"></a>kjt_open_file (formerly "kjt_find_file")</span><br><br>Action: Looks for a file on current disk and sets internal registers ready&nbsp;for "kjt_read_file_data" call.<br><br>Input Registers&nbsp; :<br><br>HL = pointer to zero terminated filename to look for<br><br>Output Registers :<br><br>If the Zero Flag is set: All OK. Registers are:<br><br>IX:IY = Length of file<br>DE&nbsp;&nbsp;&nbsp; = First disk cluster used by file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>If zero flag is not set: standard error codes.<br><br>Notes:&nbsp; File pointer is set to 0, default transfer length = total file size <br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_set_file_pointer"></a>kjt_set_file_pointer</span><br><br>Action: Moves the read point from the start of a file<br><br>Input Registers&nbsp; :<br><br>&nbsp;IX:IY = Offset in bytes from start of file.<br><br>Output Registers :&nbsp; none<br><br>Notes: Use after "kjt_open_file" (if required)<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_set_read_length"></a>kjt_set_read_length - formerly "kjt_get_load_length" </span><br><br>Action: Forces the read length of the file transfer to a certain value<br><br>Input Registers&nbsp; :<br><br>IX:IY = Bytes to load<br><br>Output Registers : none<br><br>Notes: Use after kjt_find_file, if desired)<br><br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_read_from_file"></a>kjt_read_from_file (formerly "kjt_force_load") </span><br><br>Action:&nbsp; Loads data (from the previously opened file) to a specified address.<br><br>Input Registers&nbsp; :<br><br>HL = Destination address<br>B&nbsp; = Destination bank<br><br>Output Registers : Standard error codes<br><br>Notes:<br><br>&nbsp;"kjt_find_file" MUST be called first before using this routine.<br><br>Whenever a disk file transfer reaches address $FFFF, it wraps around to $8000 and continues onto the next bank. <br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_create_file"></a>kjt_create_file</span><br><br>Action: Makes a file stub for a new file on current disk, current directory.<br><br>Input Registers :<br><br>HL = address of zero-terminated filename.<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>Output Registers : Standard error codes<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_write_to_file"></a>kjt_write_to_file (formerly "kjt_write_bytes_to_file")</span><br><br>Action: Appends new data to an existing file on current disk / directory.<br><br>Input Registers:<br><br>HL&nbsp;&nbsp; = null-terminated ascii filename of file to be appended to<br>IX&nbsp;&nbsp; = address of source data<br>B&nbsp;&nbsp;&nbsp; = bank of source data<br>C:DE = number of bytes to write<br><br>Output Registers : Standard error codes &nbsp;<br><br>Notes:<br><br>Returns "file not found" error if the file has not been previously created &nbsp;with "kjt_create_file" or "kjt_save_file"<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_dir_list_first_entry"></a>kjt_dir_list_first_entry</span><br><br>Action: Finds the first listing in a directory, returns info.<br><br>Input registers: None<br><br>Output registers: If zero flag is set:<br><br>HL&nbsp;&nbsp;&nbsp; = Location of null terminated filename string<br>IX:IY = Length of file (if applicable)<br>B&nbsp;&nbsp;&nbsp;&nbsp; = File flag (1 = directory, 0 = file)<br><br>If zero flag is not set, standard error codes&nbsp; (EG: $24 = Reached end of directory)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_dir_list_get_entry"></a>kjt_dir_list_get_entry</span><br><br>Action: Returns data about the entry at the current position in the directory list.<br><br>Input registers: None<br><br>Output registers: If zero flag is set:<br><br>HL&nbsp;&nbsp;&nbsp; = Location of null terminated filename string<br>IX:IY = Length of file (if applicable)<br>B&nbsp;&nbsp;&nbsp;&nbsp; = File flag (1 = directory, 0 = file)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>If zero flag is not set, standard error codes&nbsp;(EG: $24 = Reached end of directory)<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_dir_list_next_entry"></a>kjt_dir_list_next_entry</span><br><br>Action: Moves the internal directory list pointer to the next entry and&nbsp;returns details about the entry found.<br><br>Input registers: None<br><br>Output registers: If zero flag is set:<br><br>HL&nbsp;&nbsp;&nbsp; = Location of null terminated filename string<br>IX:IY = Length of file (if applicable)<br>B&nbsp;&nbsp;&nbsp;&nbsp; = File flag (1 = directory, 0 = file)<br><br>If zero flag is not set, standard error codes&nbsp; (EG: $24 = Reached end of directory)<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_dir_name"></a>kjt_get_dir_name</span><br><br>Action: Returns ascii string of current dir name (null terminated)<br><br>Input registers: None<br><br>Output registers :<br><br>If zero flag set: HL = ascii string.<br>&nbsp;&nbsp;&nbsp; &nbsp;<br>If zero flag is not set, standard error codes<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_store_dir_position"></a>kjt_store_dir_position</span><br><br>Action: Internally remembers the current directory position.<br><br>Input registers: None<br><br>Output registers :None<br><br>Notes: <br><br>All flags and registers are preserved.<br>kjt_get_dir_cluster is more useful.<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_restore_dir_position"></a>kjt_restore_dir_position</span><br><br>Action: Restores the directory position to that set by "kjt_store_dir_position".<br><br>Input registers: None<br><br>Output registers :None<br><br>Notes:<br><br>All flags and registers are preserved.<br>kjt_set_dir_cluster is more useful.<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_mount_volumes"></a>kjt_mount_volumes</span><br><br>Action: Reinitializes the drives and mount list<br><br>Input registers:<br><br>If A = 1, mount quietly (no text output)<br><br>Output registers :None<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_volume_info"></a>kjt_get_volume_info</span><br><br>Action: Returns info about the volumes mounted.<br><br>Input Registers&nbsp; : None<br><br>Output Registers :<br><br>HL = address of volume mount list&nbsp;&nbsp; &nbsp;<br>B = Number of volumes mounted<br>A = currently Selected volume<br><br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br><a name="kjt_get_device_info"></a>kjt_get_device_info</span><br><br>Action: Returns info from the device list.<br><br>Input Registers&nbsp; : None<br><br>Output Registers :<br><br>&nbsp;HL = address of device info table&nbsp;&nbsp; &nbsp;<br>&nbsp;DE = address of driver table<br>&nbsp;B =&nbsp; number of devices initialized <br>&nbsp;A = current active driver number<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_dir_cluster"></a>kjt_get_dir_cluster</span><br><br>Action: Returns the location of the directory cluster<br><br>Input Registers&nbsp; : None<br><br>Output Registers :<br><br>DE = cluster pointed at by current directory<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;<hr style="width: 100%; height: 2px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><span style="font-weight: bold;"><a name="kjt_set_dir_cluster"></a>kjt_set_dir_cluster</span><br style="font-weight: bold;"><br>Action: Sets the directory cluster (for use with above command)<br><br>Input Registers&nbsp; :<br><br>DE = desired cluster number to be used as current dir<br><br>Output Registers : None<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_rename_file"></a>kjt_rename_file</span><br><br>Action: Rename files / folders.<br><br>Input Registers&nbsp; :<br><br>HL = Pointer to filename to change (null terminated ASCII)<br>DE = Pointer to replacement filename (null terminated ASCII)<br><br>Output Registers : Standard error codes&nbsp;&nbsp; &nbsp;<br><br><br><hr style="width: 100%; height: 2px;">Low-Level Disk Sector Access Routines<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_read_sector"></a>kjt_read_sector</span><br><br>Action: Loads a 512 byte sector from the device and address selected to the sector buffer<br><br>Input registers:<br><br>A = Device number to access (normally 0)<br>BC:DE = absolute LBA address for desired sector<br><br>Output registers: Standard error codes (relevant errrors: $1e, $22)<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_write_sector"></a>kjt_write_sector</span><br><br>Action: Writes a 512 byte sector from the sector buffer to the device and address selected<br><br>Input registers:<br><br>A = Device number to access (normally 0)<br>BC:DE = absolute LBA address for desired sector<br><br>Output registers: Standard error codes (relevant errrors: $1e, $22)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_file_sector_list"></a>kjt_file_sector_list</span><br><br>Action: Retrieves the location of the (next) disk sector that a file occupies.<br><br>Input registers:<br><br>A&nbsp; = Sector offset (within current cluster)<br>DE = Cluster number<br><br>Output registers:<br><br>A&nbsp; = Next sector offset<br>DE = Updated cluster<br>HL = Memory address of LSB of 4 byte sector location<br><br>How to use:<br><br>To
obtain the list of sectors that a file uses, first call "kjt_find_file"
with the filename in HL as normal. On exit, DE will be equal the first
cluster that the file occupies. Clear the accumulator (as we're
starting at the first sector of this cluster), and call
"kjt_file_sector_list". On return A and DE are updated to the values
required for the next time the routine is called and HL points to the
lowest significant byte of the sector address (LBA0). Next, copy the 4
bytes from HL to HL+3 to your sector list buffer and loop around,
calling "kjt_file_sector_list" for as many sectors as are used by the
file (simply subtract 512 from a variable holding the file size every
call until variable is = &lt; 0)<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_sector_read_addr"></a>kjt_get_sector_read_addr</span><br><br>Action: Returns the address of the selected drive's sector read routine, also LBA variable and sector_location_variable<br><br>Input Registers :<br><br>A = Device to access (normally 0)<br><br>Output Registers:<br><br>&nbsp;HL = Address of sector read routine<br>&nbsp;DE = Location of the LSB of the 32bit LBA variable<br>&nbsp;BC = Location of the sector buffer location variable <br><br><br>Note: <br><br>The
sector buffer location is automatically reset to the location that the
OS requires whenever a filesystem routine is called (this includes the
KJT read/write sector calls above.) Similarly, altering the LBA
variable manually should not affect the filesystem.<br><br><br><hr style="width: 100%; height: 2px;">&nbsp;SERIAL I/O ROUTINES<br><hr style="width: 100%; height: 2px;"><br>As
with the disk routines, whenever a serial file transfer command reaches
address $FFFF, it wraps around to $8000 and continues onto the next
bank.<br><br>The Serial Header Format:<br><br>$00 - $0F: ASCII filename<br>$10 - $11: Length of file (low word)<br>$12 - $13: Length of file (high word)<br>$14 - $1F: ASCII "Z80P.FHEADER" (12 chars)<br>$20 - $FF: All must be zero<br><br>(All words are in normal Z80 little-endian format)<br><br>Serial transfer format:<br><br>Bytes
from the file are sent in 256 byte packets followed by a 2 byte
checksum word. The checksum calculation is described as a "standard
CRC-CCITT that uses polynomial $1021". It produces a 16 bit output. The
Z80 code (slow, unoptimized) to generate it is as follows:<br><br>crc_checksum<br><br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ld
hl,$ffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; makes checksum in
HL, src addr = DE, length = C bytes<br>crcloop&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ld a,(de)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; xor
h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ld
h,a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ld b,8<br>crcbyte&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; add hl,hl<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; jr nc,crcnext<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ld a,h<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; xor 10h<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ld h,a<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ld a,l<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; xor 21h&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ld l,a<br>crcnext&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; djnz crcbyte<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inc de<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dec c&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; jr nz,crcloop<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ret<br><br><br><hr style="width: 100%; height: 2px;"><a name="kjt_serial_receive_header"></a><br><span style="font-weight: bold;">kjt_serial_receive_header</span><br><br>Action: Waits for a file header from serial port.<br><br>Input Registers&nbsp; :<br><br>&nbsp;HL = Location of filename<br>&nbsp;A&nbsp; = Time allowed in seconds before give up waiting<br><br>Output Registers :<br><br>Zero Flag: If set, all OK<br>IX = location of serial file header (details below)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>If Zero Flag is NOT set, A = serial error code.<br><br>A = $07 : Save length is zero<br>A = $08 : File too big (IE: Memory address out of range)<br>A = $0f : Checksum bad<br>A = $11 : Comms error<br>A = $14 : Time out error<br>A&nbsp;= $25 : Filename mismatch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>A = $2A : Aborted with ESC key<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>Note: Filename can be "*" if any file is to be accepted.<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_serial_receive_file"></a>kjt_serial_receive_file</span><br><br>Action: Receives serial file data <br><br>Input Registers&nbsp; :<br><br>HL = Address to load file to<br>B&nbsp; = Bank to load file into <br><br>Output Registers :<br><br>Zero Flag: If set, all OK<br><br>IX = location of of serial file header<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>If Zero Flag is NOT set, A = serial error code.<br><br>A&nbsp;= $07 : Save length is zero<br>A = $08 : File too big (IE: Memory address out of range)<br>A = $0f : Checksum bad<br>A = $11 : Comms error<br>A = $14 : Time out error<br>A = $25 : Filename mismatch<br><br>Note: "kjt_serial_receive_header" MUST be called before this routine!<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_serial_send_file"></a>kjt_serial_send_file</span><br><br>Action: Sends a file to serial port (Serial Link App format)<br><br>Input Registers&nbsp; :<br><br>HL&nbsp;&nbsp;&nbsp;&nbsp; = filename<br>C:DE&nbsp;&nbsp; = length of file<br>B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Bank number that file starts in<br>IX&nbsp;&nbsp;&nbsp;&nbsp; = Start address<br><br>Output Registers : Zero flag, set if all OK.<br><br>If zero flag not set, A = serial error code.<br><br>A = $07 : Save length is zero<br>A&nbsp;= $08 : File too big (IE: Memory address out of range)<br>A = $0f : Checksum bad<br>A = $11 : Comms error<br>A = $14 : Time out error<br>A = $25 : Filename mismatch<br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br><a name="kjt_serial_rx_byte"></a>kjt_serial_rx_byte</span><br><br>Action: Wait for a byte from serial port<br><br>Input Registers&nbsp; :<br><br>&nbsp;A.&nbsp; Bits: [0:5] = max time to wait in seconds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [6] = If set, the wait can be aborted with the ENTER key<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;[7] = If set, the wait can be aborted with ESCAPE key<br><br>Output Registers : If Carry flag is clear all OK, A = byte received.<br>&nbsp; <br>If Carry flag is set, error code in A as follows:<br><br>A = $14 - Timed out<br>A = $2A - Aborted with key.<br><br>Notes: All registers except A preserved<br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br><a name="kjt_serial_tx_byte"></a>kjt_serial_tx_byte</span><br><br>Action: Send a byte to serial port<br><br>Input Registers&nbsp; : none<br><br>Output Registers : A = byte to send<br><br>Notes: All registers except A preserved.<br><br><br><hr style="width: 100%; height: 2px;">KEYBOARD AND MOUSE ROUTINES&nbsp;<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_wait_key_press"></a>kjt_wait_key_press</span><br><br>Action: Pauses until a key is pressed<br><br>Input Registers&nbsp; : None<br><br>Output Registers :<br><br>A = Scancode of key pressed<br>&nbsp;B = ASCII code (B=$00 if no valid ascii char equivalent.)<br><br>Notes: ASCII code is modified by shift / Alt key status<br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br><a name="kjt_get_key"></a>kjt_get_key</span><br><br>Action: Returns value of key, if one has been pressed (does not wait)<br><br>Input Registers&nbsp; : None<br><br>Output Registers :<br><br>&nbsp;A = Scancode of key pressed (A = $00 if no key pressed)<br>&nbsp;B = ASCII code (B=$00 if no valid ascii char equivalent.)<br><br>Notes: ASCII code is modified by shift / Alt key status<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_key_mod_flags"></a>kjt_get_key_mod_flags</span><br><br>Action: Returns current status of key modifiers<br><br>Input Registers&nbsp; : None<br><br>Output Registers : A, bits<br><br>[0] - left shift<br>[1] - left/right ctrl<br>[2] - left GUI<br>[3] - left/right alt<br>[4] - right shift<br>[5] - right GUI<br>[6] - Apps<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_keyboard_irq_code"></a>kjt_keyboard_irq_code</span><br><br>Action: Keyboard IRQ handler.<br><br>When
a custom interrupt handler is set up but kernal-based keyboard handling
is required, this routine can be called when the keyboard IRQ flag is
set <br>The above kernal keyboard routines will then still work. (The call clears the relevant IRQ flag).<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_enable_mouse"></a>kjt_enable_mouse</span><br><br>Action: Activates mouse pointer (called by MOUSE.EXE) and sets x/y boundaries<br><br>Input Registers&nbsp; : <br><br>HL = Window size X<br>DE = Window size Y<br><br>Output Registers : None<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_mouse_position"></a>kjt_get_mouse_position</span><br><br>Action: Returns absolute mouse position and button data<br><br>Input Registers&nbsp; : none <br><br>Output Registers : Zero Flag - If not set, the mouse driver was not enabled, otherwise:<br><br>HL = x coordinate<br>DE = y coordinate<br>A = buttons status<br><br>The x and y coordinates cannot overflow from the boundaries set with &nbsp;"kjt_enable_mouse"<br><br>(Note:
the mouse driver is currently somewhat primative - it may become out of
sync with the three-byte packets that the mouse sends if say,<br>interrupts are disabled)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_mouse_motion_"></a>kjt_get_mouse_motion </span><br><br>Action: Returns relative mouse motion and button data. <br><br>Input Registers&nbsp; : none <br><br>Output Registers : Zero Flag: if not set, the mouse driver was not enabled, Otherwise:<br><br>HL = x motion since last called<br>DE = y motion since last called<br>A = buttons status<br><br>(Note:
the mouse driver is currently somewhat primative - it may become out of
sync with the three-byte packets that the mouse sends if say,<br>interrupts are disabled)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<hr style="width: 100%; height: 2px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><span style="font-weight: bold;"><a name="kjt_mouse_irq_code"></a>kjt_mouse_irq_code</span><br><br>Action: Mouse IRQ handler<br><br>When
a custom interrupt handler is set up but kernal-based mouse handling is
required, this routine can be called when the mouse IRQ flag is set.<br>The above kernal mouse routines will then still work. (The call clears the relevant IRQ flag).<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_key_buffer"></a>kjt_get_key_buffer</span><br><br>Action: Returns values for monitoring the keyboard buffer<br><br>Input Registers: None<br><br>Output Registers:<br><br>HL&nbsp; = Location of the keyboard buffer WRITE index variable (The actual keyboard buffer starts 32 bytes lower in memory)<br>A = The value of the keyboard READ index variable.<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>Notes: On return, if A = (HL) no key has been pressed (IE: the keyboard buffer is empty)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><hr style="width: 100%; height: 2px;">&nbsp;MEMORY MANAGEMENT ROUTINES&nbsp;<br><hr style="width: 100%; height: 2px;"><br>Under
FLOS, Z80 Address space $5000-$FFFF is available for user programs.
FLOS allows the upper 32KB of Z80 address space ($8000-$FFFF) to be
paged. 15 pages of system RAM&nbsp;can appear in this region, starting
at system RAM address $08000 (FLOS does not normally allow the first
32KB of system RAM to be paged into $8000-$FFFF). Therefore, when using
the KJT routines for bank management, the figures are as follows:<br><br><span style="text-decoration: underline;">Bank | &nbsp;SYSTEM RAM&nbsp; |&nbsp; Z80 ADDRESS</span><br><br>$00 = $08000-$0ffff @ $8000-$ffff<br>$01 = $10000-$17fff @ $8000-$ffff<br>$02 = $18000-$1ffff @ $8000-$ffff<br>$03 = $20000-$27fff @ $8000-$ffff<br>$04 = $28000-$2ffff @ $8000-$ffff<br>$05 = $30000-$37fff @ $8000-$ffff<br>$06 = $38000-$3ffff @ $8000-$ffff<br>$07 = $40000-$47fff @ $8000-$ffff<br>$08 = $48000-$4ffff @ $8000-$ffff<br>$09 = $50000-$57fff @ $8000-$ffff<br>$0a = $58000-$5ffff @ $8000-$ffff<br>$0b = $60000-$67fff @ $8000-$ffff<br>$0c = $68000-$6ffff @ $8000-$ffff<br>$0d = $70000-$77fff @ $8000-$ffff<br>$0e = $78000-$7ffff @ $8000-$ffff<br><br>(You
may have noticed that the figures are different to the values used if
writing directly to the bank selection hardware port: sys_mem_select).<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_set_bank"></a>kjt_set_bank (formely kjt_force_bank</span>)<br><br>Action: Changes the currently selected upper RAM page<br><br>Input Registers&nbsp; : <br><br>A = bank number $00 to $0e<br><br>Output Registers : none<br><br>Trashes: A<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_get_bank"></a><br><span style="font-weight: bold;">&nbsp;kjt_get_bank</span><br><br>Action: Returns the upper bank number in A<br><br>Input Registers&nbsp; : none<br><br>Output Registers :<br><br>A = current bank number ($00 to $0e)<br><br>Trashes: none<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_inc_bank"></a><br><span style="font-weight: bold;">kjt_inc_bank</span><br><br>Action: change to the next bank<br><br>Input Registers&nbsp; : none<br><br>Output Registers :<br><br>&nbsp;If Zero flag set: all OK,<br>&nbsp;If Zero is not set: A = $08 - bank out of range<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_page_in_video"></a>kjt_page_in_video</span><br><br>Action: Pages 8KB of video memory specified by (hardware register vreg_vidpage) into Z80 address space $2000-$3FFF. <br><br>CAUTION: This area is used by part of FLOS so ideally no other FLOS call should be made until&nbsp;<span style="font-weight: bold;">kjt_page_out_video</span> is called.<br><br>Input Registers&nbsp; : none<br><br>Output Registers : none<br><br>Trashes: A<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_page_out_video"></a><br><span style="font-weight: bold;">kjt_page_out_video</span><br><br>Action: Pages normal system memory (part of the FLOS!) back into $2000-$3FFF<br><br>Input Registers&nbsp; : none<br><br>Output Registers : none<br><br>Trashes: A<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_read_sysram_flat"></a>kjt_read_sysram_flat</span><br><br>Action: Reads system memory in a flat, linear addressing mode<br><br>Input Registers&nbsp; :<br><br>E:HL = $00000 - $7FFFF (address to read)<br><br>Output Registers :<br><br>A (byte read from address)<br><br>Trashes: BC,DE,HL<br><br>Notes: &nbsp;<br><br>*
The routine saves and restores the current bank setting around the
read&nbsp;so make sure any interrupt service routine is in unpaged
memory (&lt;$8000)<br>&nbsp; or disable interrupts to avoid problems.<br><br>* As this routine is very slow, only use if convenience is more important than speed.<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_write_sysram_flat"></a>kjt_write_sysram_flat</span><br><br>Action: Writes to system memory in a flat, linear addressing mode<br><br>Input Registers&nbsp; <br><br>E:HL = $00000 - $7FFFF (address to write),<br>A = byte to write<br><br>Output Registers : None (but see below)<br><br>Trashes: BC, DE, HL<br><br>Notes: &nbsp;<br><br>*
The routine saves and restores the current bank setting around the
write&nbsp; so make sure any interrupt service routine is in unpaged
memory (&lt;$8000)<br>&nbsp; or disable interrupts to avoid problems.<br><br>* As this routine is not fast, only use if convenience is more important than speed.<br><br><br><hr style="width: 100%; height: 2px;">&nbsp;KERNAL TEXT AND DISPLAY ROUTINES&nbsp;<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_print_string"></a>kjt_print_string</span><br><br>Action: Prints ASCII text string at cursor position<br><br>Input Registers : HL address of string (zero terminated)<br><br>Output Registers: None<br><br>Notes:<br><br>ASCII Char $0a = line feed<br>ASCII Char $0d = carriage return<br>ASCII Char $0b = Line Feed and Carriage return<br><br>HL returns pointing to the zero byte at end of the string<br><br>All other registers are preserved by this routine.<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_clear_screen"></a>kjt_clear_screen</span><br><br>Action: clears OS screen and set cursor position to top left (0,0)<br><br>Input Registers&nbsp; : None<br><br>Output Registers : None<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_plot_char"></a>kjt_plot_char</span><br><br>Action: Prints ASCII character at supplied coordinates using current pen colours<br><br>Input Registers&nbsp; :<br><br>A = ASCII character<br>B = x coord<br>C = y coord<br><br>Output Registers : None<br><br>Notes: <br><br>Plot_char does not change the current cursor position.<br>If a coordinate is outside the window, it is taken as zero<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_pen_"></a>kjt_get_pen </span><br><br>Action: Returns current pen colour<br><br>Input Registers&nbsp; : None<br><br>Output Registers :<br><br>A = $nm where "n" is the background and "m" is the foreground colour (see colour table below)<br><br><br><hr style="width: 100%; height: 2px;"><br style="font-weight: bold;"><span style="font-weight: bold;"><a name="kjt_set_pen"></a>kjt_set_pen</span><br><br>Action: Changes current pen colour<br><br>Input Registers&nbsp; : A = $nm where "n" is the background and "m" is the foreground colour <br><br>Available (default) colours:<br><br>0 - transparent (shows UI "paper" colour)<br>1 - black<br>2 - blue<br>3 - red<br>4 - magenta<br>5 - green<br>6 - cyan<br>7 - yellow<br>8 - white<br>9 - dark grey<br>a - mid grey<br>b - light grey<br>c - orange<br>d - light blue<br>e - light green<br>f - brown<br><br>Output Registers : None<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_background_colours"></a>kjt_background_colours</span><br><br>Action: Change paper and border colours<br><br>Input Registers&nbsp; :<br><br>BC = paper colour ($RGB), DE = border colour ($RGB)<br><br>Output Registers : None<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_draw_cursor"></a>kjt_draw_cursor</span><br><br>Action: Draws (or removes) the cursor at the current cursor position<br><br>Input Registers&nbsp; :<br><br>HL = offset of cursor char image in VRAM font area.<br><br>EG: <br><br>HL = $0000 : delete cursor<br>HL = $043f : underscore cursor ($400-$45f are ASCII chars 32-95)<br>HL=&nbsp; $0c00 : solid block cursor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>Output Registers : None<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_get_input_string"></a><br><span style="font-weight: bold;">kjt_get_input_string</span><br><br>Action: waits for user to enter a string of characters followed by Enter (characters appear on screen)<br><br>Input Registers&nbsp; : None <br><br>Output Registers :<br><br>HL = string location (zero terminated)<br>A&nbsp; = number of characters of entered string (zero if aborted by pressing ESCAPE)<br><br><br><hr style="width: 100%; height: 2px;"><a name="kjt_set_cursor_position"></a><br><span style="font-weight: bold;">kjt_set_cursor_position</span><br><br>Action: Repositions the text printing (cursor) position. If a coordinate is out of range it will be set to 0.<br><br>Input Registers :<br><br>B = X coord<br>C = Y coord<br><br>Output Registers:<br><br>&nbsp;Zero flag set if all OK<br>&nbsp;If zero flag not set: Invalid coordinates<br><br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_flos_display"></a>kjt_flos_display</span><br><br>Action:
Restores the video registers to the state used by the OS. Can be called
by FLOS based programs that change the display mode etc, meaning the OS
does not have to be complete restarted on program exit.<br><br>Input registers: None<br><br>Output registers: None<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><span style="font-weight: bold;"><a name="kjt_get_cursor_position"></a>kjt_get_cursor_pos</span>ition</span><br><br>Action: Returns the current cursor position<br><br>Input Registers : None<br><br>Output registers :<br><br>B= x coord<br>C =y coord<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_scroll_up"></a>kjt_scroll_up</span><br><br>Action: Scrolls the screen (and character map) up a line, inserting a blank line at the bottom of the screen.<br><br>Input Registers : None<br><br>Output registers : None<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_display_size"></a>kjt_get_display_size</span><br><br>Returns size of OS_window.<br><br>Input registers: None<br><br>Output registers:<br><br>B= x coord<br>C =y coord<br><br>Notes: All other registers preserved.<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_charmap_addr_xy"></a>&nbsp;kjt_get_charmap_addr_xy</span><br><br>Action: Returns the charmap address of the character at coordinates x,y<br><br>Input registers :<br><br>B= x coord<br>C =y coord<br><br>Output registers: HL = character map address of coords<br><br>Notes: All other registers are preserved.<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_wait_vrt"></a><br><span style="font-weight: bold;">kjt_wait_vrt</span><br><br>Action: Wait for last scanline of display<br><br>Input Registers&nbsp; : none<br><br>Output Registers : none<br><br>Trashes: A<br><br><hr style="width: 100%; height: 2px;">MISC KERNAL ROUTINES<br><hr style="width: 100%; height: 2px;"><a name="kjt_hex_byte_to_ascii"></a><br style="font-weight: bold;"><span style="font-weight: bold;">&nbsp;kjt_hex_byte_to_ascii</span><br><br>Action: puts ASCII version of the hex byte value in A at HL (two chars), HL=HL+2<br><br>Input Registers&nbsp; : A<br><br>Output Registers : none (HL=HL+2)<br><br>Trashes: A <br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_ascii_to_hex_word"></a>kjt_ascii_to_hex_word</span><br><br>Action: converts text string version of hex number at HL (1 to 4 chars) to actual hex word in DE<br><br>Input Registers&nbsp; : <br><br>HL = source text (scans for first non-zero character)<br><br>Output Registers :<br><br>DE = result<br><br>A = $00 : OK<br>A = $0c : Bad chars for hex<br>A = $1F : No chars found<br><br>Trashes: HL<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_dont_store_registers"></a>kjt_dont_store_registers</span><br><br>Action: Prevents the OS from noting the register values when a program exits and returns to OS.<br><br>Input Registers&nbsp; : None<br><br>Output Registers : None<br><br>Trashes: A<br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><a name="kjt_get_version"></a><br>kjt_get_version</span><br><br>Action: Returns OS and hardware ID numbers<br><br>Input Registers&nbsp; : none<br><br>Output Registers :<br><br>&nbsp;HL = OS version word<br>&nbsp;DE = Hardware version word<br><br>Trashes: BC<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_compare_strings"></a><br><span style="font-weight: bold;">kjt_compare_strings</span><br style="font-weight: bold;"><br>Action: Compares two ASCII strings <br><br>Input Registers&nbsp; :<br><br>&nbsp;DE = address of string 1<br>&nbsp;HL = address of string 2<br>&nbsp;B&nbsp; = maximum number characters to compare<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>Output Registers : Carry flag: Only set if strings are the same.<br><br>Notes:<br><br>* Both strings should be zero terminated.<br>* Compare fails if string lengths are different unless count is reached first.<br>* Original HL/DE values are preserved.<br><br>Trashes: A<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_bchl_memfill_"></a>kjt_bchl_memfill</span><br><br>Action: Fill memory with value in accumulator<br><br>Input Registers&nbsp; :<br><br>HL = start address<br>BC = number of bytes to write<br>A = value to write<br><br>Output Registers : none<br><br>Notes: <br><br>Does NOT overflow from $FFFF into next bank.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>Trashes: HL, BC, A<br><br><hr style="width: 100%; height: 2px;"><a name="kjt_timer_wait_"></a><br><span style="font-weight: bold;">kjt_timer_wait </span><br><br>Action: Waits n x 16 microseconds and returns.<br><br>Input Registers: A = number of 16 microsecond periods to wait<br><br>Output Registers: None (A is trashed)<br><br>Note: Preserves all other registers.<br><br><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br><a name="kjt_set_commander"></a>kjt_set_commander</span><br><br>Action: Sets a "permanent" command string that is to be launched when progams exit<br><br>Input Registers:<br><br>HL = location of command string (40 chars max)<br><br>Output Registers: None<br><br>Notes: <br><br>*
The "commander program" will run on when a program exits back to FLOS
unless that program specifically&nbsp; tells FLOS to launch some other
program (with A=$FE on exit). In this case, the commander program
will&nbsp;eventually launch when control is passed back to the FLOS CLI
(IE: A &lt;&gt; $FE on exit)<br><br>* To remove the commander string, point HL at a null string (a zero btyte in memory) and call the routine.<br><br><br><hr style="width: 100%; height: 2px;">ENVIRONMENT VARIABLE RELATED CALLS&nbsp;<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_set_envar"></a>kjt_set_envar</span><br><br>Action: Sets an environment variable (or updates a variable if it already exists)<br><br>Input Registers:<br><br>HL = name of variable (4 chars max, zero-termination required if less than 4 chars)<br>DE = address of data for variable (4 bytes)<br><br>Output Registers: Zero Flag = set if all OK, not set if no space for new variable<br><br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_get_envar"></a>kjt_get_envar</span><br><br>Action: gets (address of) value of an environment variable<br><br>Input Registers :<br><br>HL = name of variable (4 chars max, zero-termination required if less than 4 chars)<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>Output Registers:<br><br>If zero Flag = Set : all OK,&nbsp; HL = address of data for variable (4 bytes)<br>If Zero Flag = Not set: variable was not found, HL = address of envar list, A = max entries<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><hr style="width: 100%; height: 2px;"><br><span style="font-weight: bold;"><a name="kjt_delete_envar"></a>&nbsp;kjt_delete_envar</span><br><br>Action: deletes an environment variable<br><br>Input Registers :<br><br>HL = name of variable (4 chars max, zero-termination required if less than 4 chars)<br><br>Output Registers:<br><br>Zero flag = set if all OK, not set if named variable not found<br><br><hr style="width: 100%; height: 2px;"><br><br><span style="font-weight: bold;"></span><br><br></body></html>