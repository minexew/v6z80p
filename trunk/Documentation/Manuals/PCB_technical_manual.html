<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>V6Z80P PCB technical manual</title></head>
<body><h2>V6Z80P PCB Technical Manual</h2><pre>Last updated 23-08-2012</pre><pre><br><span style="text-decoration: underline; font-weight: bold;">Brief circuit description:</span></pre><pre>The V6Z80P is based around a Xilinx Spartan 2 XS2S150 FPGA, Zilog 20MHz Z80 and 3 SRAM memory ICs.<br>Also onboard are two PIC chips (one handles FPGA configuration, whilst the other&nbsp;is used as a<br>parallel-to-serial converter for the joystick inputs),&nbsp; an SPI EEPROM (which holds FPGA config<br>patterns and other data), an ST232 voltage convertor for serial comms and a 74HCT08 quad AND gate<br>(for CPU clock and reset, see descriptions below).</pre><pre><br><span style="text-decoration: underline; font-weight: bold;">Memory ICs:</span></pre><pre>1. 512KB SRAM 10ns, 3.3v - direct connection to FPGA&nbsp; /CS permanently active (pulled low).</pre><pre>2. 128KB SRAM 10ns, 3.3v&nbsp; direct connection to FPGA,&nbsp; /CS permanently active (pulled low).</pre><pre>3. 512KB SRAM 25ns, 5v. Some connections direct&nbsp; to CPU and FPGA, some are routed through<br> &nbsp; the FPGA&nbsp; (see description below). This chip is referred to as "System RAM".</pre><pre><br><span style="text-decoration: underline; font-weight: bold;">CPU:</span></pre><pre>All Z80 control pins (except CLOCK, /RFSH and /HALT) are connected to FPGA pins. /RD, /WR and D0:D7<br>and A0:A14 are also connected direct to System RAM. To allow 32KB memory paging, A15 is routed<br>through the FPGA, (On the V6Z80P+,&nbsp; A14 is also routed through the FPGA allowing 16KB paging)<br>System RAM lines A18:A16 are driven direct from the FPGA.<br><br>The Z80 / RESET signal is also connected to the output of an 74HCT08 AND gate: AND input A is<br>connected to the FPGA's DONE signal, and input B is connected to an FPGA output pin. This&nbsp;means<br>the Z80 is held in reset state until the FPGA has started, and can also be reset by the FPGA.<br>(FPGA configurations should pull this reset line low for a short period upon start up to<br>guarantee CPU reset time with the clock running) <br><br>The Z80's clock signal is driven by the output of a 74HCT08 gate, the inputs of this gate are<br>connected&nbsp; differently depending on the version of the board:</pre><pre><br><span style="font-weight: bold;">Original V6Z80P (v1.1)</span></pre><pre>&nbsp;&nbsp; &nbsp;AND gate input A is connected to the 16MHz oscillator, input B is pulled high.</pre><pre><br><span style="font-weight: bold;">V6Z80P+ V1.0</span></pre><pre>&nbsp;&nbsp; &nbsp;AND gate input A is connected to the 16MHz oscillator, input B is connected to an FPGA pin (p75).<br>&nbsp;&nbsp; &nbsp;Normally, the FPGA pin should be pulled high.</pre><pre><br><span style="font-weight: bold;">V6Z80P+ V1.1</span><br><br>&nbsp;&nbsp; &nbsp;AND gate input A can either be connected to the 16MHz oscillator or pulled high - an onboard switch<br>&nbsp;&nbsp; &nbsp;called "OSC SEL" selects the operating mode:</pre><pre>&nbsp;&nbsp; &nbsp;When the switch is down, input A is pulled high, and the CPU clock signal should be supplied<br>&nbsp;&nbsp; &nbsp;to Input B from the FPGA (pin 75). </pre><pre>&nbsp;&nbsp; &nbsp;When the switch is up, input A is connected to the 16MHz clock, so input B (p75)<br>&nbsp;&nbsp; &nbsp;should normally be pulled high.</pre><pre>&nbsp;&nbsp;&nbsp; &nbsp;(The OSC SEL only needs to be up position if using FPGA configs designed for the V6Z80P+ V1.0)</pre><pre style="font-weight: bold;"><br>V6Z80P+ v1.1b</pre><pre>&nbsp;&nbsp; &nbsp;There is no OSC SEL switch, the board is wired as if the switch were fixed in the down position,<br>    IE:&nbsp;the CPU clock always comes from the FPGA.</pre><br><pre style="text-decoration: underline; font-weight: bold;">Header Pins:</pre><pre>The 2x5 pin header has 6 pins connected directly to general purpose FPGA IOs (5 on the V6Z80P+)<br>they have no fixed purpose (in OSCA they are used for NMI, RESET and VGA select, with the others<br>configured as Z80 I/O ports). The layout of the pins depends on the model of V6Z80P:</pre><pre><br><span style="font-weight: bold;">Original V6Z80P (v1.1)</span><br><br>                <span style="font-weight: bold;">G 0</span>&nbsp; --&gt; FPGA pin 148<br>                <span style="font-weight: bold;">G 1</span>&nbsp; --&gt; FPGA pin 149<br>                <span style="font-weight: bold;">G 2</span>&nbsp; --&gt; FPGA pin 150<br>                <span style="font-weight: bold;">G 3</span>&nbsp; --&gt; FPGA pin 151<br>FPGA pin 160--&gt; <span style="font-weight: bold;">4 5</span> - -&gt; FPGA pin 152</pre><pre><br><span style="font-weight: bold;">V6Z80P+ V1.0 and V1.1</span></pre><pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="font-weight: bold;">N  G  G  G  G</span><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="font-weight: bold;">0&nbsp; 1&nbsp; 2&nbsp; 3&nbsp; 4</span> -----&gt;FPGA pin 148<br>        |&nbsp;&nbsp;|&nbsp; |&nbsp; '------&gt;FPGA pin 149<br>        |&nbsp;&nbsp;|&nbsp; '----------&gt;FPGA pin 150<br>        |&nbsp;&nbsp;'--------------&gt;FPGA pin 151<br>        '------------------&gt;FPGA pin 152</pre><pre><br>The V6Z80P+ boards also have a 3x1 pin header connected to the FPGA's unused GCLK inputs</pre><pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">&nbsp;G&nbsp; 5  6 </span>--&gt; FPGA pin 185<br>           '------&gt; FPGA pin 182</pre><pre>G = Ground, N = No connection</pre><pre><br><br><span style="text-decoration: underline; font-weight: bold;">Video Port:</span></pre><pre>12 FPGA outputs drive three&nbsp;4-resistor DACs for Red, Green and Blue analog outputs (which&nbsp;allows<br>a palette of 4096 colours). The RGB levels (once connected to standard 75Ohm loads) are &lt; 0.7v<br>suitable for TV for VGA monitors.&nbsp; 2 additional FPGA outputs drive Horizontal sync and Vertical<br>sync outputs. The connections vary, depending on the model of V6Z80P.</pre><pre><br><span style="font-weight: bold;">Original V6Z80P (v1.1)</span></pre><pre>&nbsp;&nbsp; &nbsp;An 8 pin mini-DIN socket is used for video out, so custom cables are required for both VGA and TV<br>&nbsp;&nbsp; &nbsp;displays. The outputs are:</pre><pre>&nbsp;&nbsp; &nbsp;"Select" (5volts, via 100Ohms),&nbsp; Ground,&nbsp; Red,&nbsp; Green,&nbsp; Blue, V-sync (TTL), H-Sync (TTL),</pre><pre>&nbsp; &nbsp; "Composite Sync" (V-Sync via 750 Ohms).</pre><pre><br><span style="font-weight: bold;">V6Z80P plus V1.0 and V1.1</span></pre><pre>&nbsp;&nbsp; &nbsp;A standard 15 pin VGA connector is used so a custom cable is only required for TV displays. The<br>&nbsp;&nbsp; &nbsp;outputs are:</pre><pre>&nbsp;&nbsp; &nbsp;Ground, Red, Green, Blue, TTL V-Sync (via 100 Ohms), TTL H-sync (via 100 Ohms).</pre><pre>&nbsp;&nbsp; &nbsp;The custom SCART TV cable connects TTL V-Sync to Composite sync via 660Ohms, this then presents the<br>    correct analogue voltage level. TTL H-sync is connected to the SCART "Select" line to&nbsp;active RGB<br>    mode - note that that the FPGA must be aware that TV mode is being used, so it can pull-up the<br>    H-Sync line continually.</pre><pre><br><span style="text-decoration: underline; font-weight: bold;">Audio:</span><br>&nbsp;<br>Two outputs from the FPGA (Sigma/Delta pulse trains) drive a simple resistor/capacitor filter.<br>The output of which has its amplitude halved by a potential divider (2 x 10K), passed via 1uf<br>capacitor to the left and right of the 3.5mm audio socket. </pre><pre><br></pre><pre style="font-weight: bold;"><span style="text-decoration: underline;">Serial Port:</span> </pre><pre>A 4-pin mini DIN (3-pin on the V6Z80P+ V1.0) is used for the V6Z80P com port (to avoid confusion<br>with the joystick ports) RX, TX and Ground are connected. The lines are routed via a ST232 level<br>converter chip to and from the FPGA.</pre><pre><br></pre><pre style="text-decoration: underline; font-weight: bold;">PS/2 ports:</pre><pre>Keyboard and mouse. CLOCK and DATA are directly connected to FPGA (and pulled up to 5v via 10K<br>resistors). These lines can be pulled down (for output) by transistors connected to the FPGA..</pre><pre><br></pre><pre style="font-weight: bold;"><span style="text-decoration: underline;">Joysticks:</span> </pre><pre>There are two Atari 2600 / Amiga style connectors: 6 inputs each. All lines are pulled up by<br>resistors and pulled down by the switches in the joystick. The 12 lines are connected to a PIC<br>16F62xA microcontroller acting as a parallel-to-serial converter. Two FPGA pins for Clock and<br>Data are used to read the joystick data from the PIC. On the V6Z80P+, pin 5 of the joystick<br>ports is pulled to 3.3v via 22 Ohm resistors - this should allow Megadrive/Genesis pads to work also.</pre><pre><br></pre><pre style="text-decoration: underline; font-weight: bold;">MMC / SD memory card: </pre><pre>Uses 5 FPGA pins to connect to Power, /Card Select, Data_in, Data_out and Clock. /Card select is<br>also connected to an LED via resistor for access indication. The FPGA /Power line switches a PNP<br>transistor to apply power to the card.</pre><pre><br></pre><pre style="text-decoration: underline; font-weight: bold;">Other pins connected to the FPGA:</pre><pre>The PIC-based configuration system uses several FPGA pins to upload config data and communicate<br>with the PIC after config (includes reprogramming the EEPROM etc)</pre><pre>JTAG port: Used for "live" configuration of the FPGA, standard Xilinx pin out sequence.</pre><pre>Config selection jumpers: (J1 and J2, where marked) These select between JTAG config mode and<br>normal EEPROM configuration (slave serial mode). For JTAG configuration both jumpers should<br>be installed.</pre><pre>Full pin outs and more details of the PCB can be found in the "Specifics" folders.</pre><br>&nbsp;<br><hr style="width: 100%; height: 2px;"><br><h3 style="text-decoration: underline;">Normal V6Z80P Power On Sequence:</h3><pre><br></pre><pre>1. Power is switched on.</pre><pre>2. Z80 CPU is held reset (by the FPGA's "done" line being low)</pre><pre>3. Config PIC checks JTAG-mode jumper J2 (Note: J1 sets the FPGA itself to JTAG mode)</pre><pre>&nbsp; * If jumper J2 is installed, the status LED flashes rapidly until the FPGA has <br>&nbsp;&nbsp;&nbsp; been manually configured by downloading a .bit file from Xilinx Impact software<br>&nbsp;&nbsp;&nbsp; on PC.</pre><pre>&nbsp; * If jumper J2 is not installed, the PIC sends the config data stored in<br>&nbsp;&nbsp;&nbsp; the current active slot of the EEPROM to the FPGA. </pre><pre>4. If the FPGA starts up correctly with the architecture file supplied (ie: the<br>&nbsp;&nbsp; FPGA's "Done" line goes high) the status LED stays on. If the config fails, the<br>&nbsp;&nbsp; status LED will pulse and the PIC goes back to step 3.</pre><pre>5. The Z80 is released from reset and starts executing code from address $0</pre><br><br><hr style="width: 100%; height: 2px;"><br><h3 style="text-decoration: underline;">The PIC-EEPROM System:</h3><pre><br>The V6Z80P has an onboard 25-series SPI EEPROM chip (the capacity varies but it is normally<br>1MB or more). Mainly, this chip is used to hold the configuration data for the various FPGA<br>architectures (IE: OSCA, Spectrum emulator etc).</pre><pre>The FPGA cannot read an EEPROM such as this directly, therefore a PIC  microcontroller<br>(16F627A or 16F628A) is used as a controller. Under normal operating conditions (IE:<br>non-JTAG mode) Upon power on, the PIC tells the EEPROM to send approx 128KB of config<br>data from the EEPROM to the FPGA.</pre><pre>Once the FPGA is configured, the Z80 CPU is released from RESET state and the system starts.</pre><pre>As the EEPROM is large enough to hold several different configuration patterns a custom<br>communications protocol is employed which allows the CPU to talk to the PIC, allowing it<br>to select a differerent config pattern etc. Additionally, the PIC-EEPROM system allows<br>the CPU to read arbitrary data from the EEPROM for uses other than configuration<br>(EG: under OSCA, boot code is required - this is stored in the EEPROM. The default<br>bootcode also allows an OS to be loaded from the EEPROM, although this is normally<br>loaded from SD card).<br><br></pre><pre style="text-decoration: underline;">PIC / EEPROM Communications - hardware connections</pre><pre>Aside from the signals required for basic configuration, the following connections<br>are used: </pre><pre>FPGA pin -&gt; PIC pin: Data (OSCA's Z80 port sys_pic_comms - bit 0 output)&nbsp; </pre><pre>FPGA pin -&gt; PIC pin: Clock (OSCA's Z80 port sys_pic_comms - bit 1 output)&nbsp; </pre><pre>PIC pin -&gt; FPGA pin: Clock/Busy (OSCA's Z80 port sys_hw_flags - bit 3 input<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (also serial-parallel converter clock)&nbsp; </pre><pre><br>EEPROM output pin -&gt; FPGA pin and PIC pin: EEPROM Data (converted to bytes,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and read from OSCA's Z80 port: sys_eeprom_byte) </pre><pre>Note that the physical pin connections are different on the various revisions<br>of the V6Z80P, refer to the schematics in the appropriate folder for details.<br>(The OSCA port bit assignments remain constant however.)</pre><pre><br></pre><pre style="text-decoration: underline;">Sending commands and args</pre><pre>Command and argument bytes are sent serially to the PIC MSb first, with bits latched<br>by the PIC on the rising edge of the clock line. Use the OSCA port "sys_pic_comms"<br>to bit-bang the data to the PIC). To prevent bits being missed or the system timing<br>out, the bit rate should be between 2KHz and 100 KHz. If a clock/busy signal is<br>received from the PIC (see OSCA port "sys_hw_flags") this indicates the data is<br>not acceptible (args out of range etc). Also, use a short delay (around 100<br>microseconds) between subsequent commands (EG: after a databurst) to allow the<br>PIC to return to its "waiting for command" state.</pre><pre><br><span style="text-decoration: underline;">PIC Command List:</span></pre><pre><br>Configuration-related:</pre><pre style="font-weight: bold;">$88 + $a1 </pre><pre>Immediately reconfigure the FPGA from the current config address base</pre><pre><br><span style="font-weight: bold;">$88 + $b8 + $low + $middle + $high address bytes </span></pre><pre>Set the config address base</pre><pre style="font-weight: bold;"><br>$88 + $37 + $d8 + $06 </pre><pre>make the current FPGA config base address permanent (IE: store it in<br>the PIC's flashram. Note: "Programming mode" must be enabled first)</pre><pre><br></pre><pre><br><span style="text-decoration: underline;">Databurst-related:</span></pre><pre><br><span style="font-weight: bold;">$88 + $c9 </span></pre><pre>send data to FPGA using current databurst base address and length<br>(Under OSCA, the bit stream is converted into bytes and appears in<br>the port: sys_eeprom_byte)</pre><pre><br><span style="font-weight: bold;">$88 + $d4 + $low + $middle + $high address bytes</span> </pre><pre>Set databurst address base</pre><pre><br><span style="font-weight: bold;">$88 + $e2 + $low + $middle + $high count bytes</span> </pre><pre>Set databurst length</pre><pre><br></pre><pre><br><span style="text-decoration: underline;">Programming-related:</span></pre><pre><br><span style="font-weight: bold;">$88 + $25 + $fa + $99 </span></pre><pre>Allow EEPROM/PIC programming</pre><pre><br><span style="font-weight: bold;">$88 + $1f </span></pre><pre>Disable EEPROM/PIC programming</pre><pre><br><span style="font-weight: bold;">$88 + $f5 + $low + $middle + $high address bytes </span></pre><pre>Erase 64KB block of SPI EEPROM ($middle and $low = $00) (Programming mode must be enabled first)</pre><pre><br><span style="font-weight: bold;">$88 + $98 + $low + $middle + $high address bytes + 64 data bytes </span></pre><pre>Program 64 bytes into the EEPROM (The 64KB EEPROM block in which the bytes are to be located <br>must be erased prior to programming new data.)</pre><pre><br></pre><pre><br><span style="text-decoration: underline;">Status-related:</span></pre><pre style="font-weight: bold;"><br>$88 + $53 (added in PIC firmware v6.17 - Nov '09)</pre><pre>&nbsp;Request EEPROM sends its size/ID byte (response to SPI command $AB) - Note: if the EEPROM<br>&nbsp;is a SST25VFxxx type, this will return a manufacturer's code ($BF) instead. If this byte<br>&nbsp;is received, use command $88 + $6c (see details below).<br><br>&nbsp;Valid bytes returned by this command:</pre><pre><br>&nbsp;<span style="text-decoration: underline;">ID Byte:&nbsp;&nbsp;&nbsp; Capacity of EEPROM:</span></pre><pre><br>&nbsp;&nbsp; $12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512 KB<br>&nbsp;&nbsp; $13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; MB<br>&nbsp;&nbsp; $14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; MB<br>&nbsp;&nbsp; $15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; MB</pre><pre>&nbsp;&nbsp; $BF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n/a: SST25VF chip, use $88 + $6c to obtain capacity code</pre><pre><br></pre><pre><span style="font-weight: bold;">$88 + $76</span> (added in PIC firmware v6.17 - Nov '09) </pre><pre>Request PIC sends the MSB of the config base address (IE: slot selection * 2) As this data<br>is sent from the PIC and not the EEPROM, it is not received as a byte in the usual port.<br>(See "Reading data from the PIC" below)</pre><pre><br><span style="font-weight: bold;">$88 + $4e</span> (added in v6.18 - Nov' 09)</pre><pre>Request PIC sends its firmware revision (last two BCD digits of the firmware version.<br>EG: if fw version is 6.18, the byte is $18)&nbsp; The byte is sent in the same way as the active<br>slot.</pre><pre><br><span style="font-weight: bold;">$88 + $6c</span> (added in V6.35) Optional EEPROM ID read if Command $88+$53 returns manufacturer's</pre><pre>ID ($BF) instead of the capacity.&nbsp; NOTE: data sent by this command is sent by the PIC, not EEPROM)</pre><pre><br></pre><pre style="text-decoration: underline;">Reading data from EEPROM: Databurst</pre><pre><br>The location and length of the data required should be sent using the commands as shown<br>above. Next a "send databurst" command sequence is sent to the PIC. Afterwards, the outgoing<br>clock line should be raised (set port sys_pic_comms bit 1) - this prompts the PIC to send eight<br>bits of data. When the bits have been received (in OSCA, the "byte ready" flag in port <br>sys_hw_flags becomes set), the clock line should then be cleared and the byte<br>received read from the port "sys_eeprom_byte". Whenever this port is read, the serial count<br>and byte received flags are reset. The clock should stay low for at least 4 microseconds (to ensure<br>that the PIC does not miss it). This cycle should be repeated for the all bytes required.<br> <br>To read a single byte (IE: response from get_EEPROM_ID command $88+$53, just go through<br>the above procedure one time.</pre><pre><br><br></pre><pre style="text-decoration: underline;">Reading data from the PIC</pre><pre>To read data from the PIC (as opposed to the EEPROM), a slower, manual method must<br>be used: First send the command that is to return data from the PIC (EG: $88+$76 = get PIC<br>firmware version). Raise the clock (set "sys_pic_comms" port bit 1), wait about 100 microseconds and<br>then reset the clock bit. Read the PIC input line (bit 3 of "sys_hw_flags") and put this bit<br>into bit 0 of a left shift register (IE: MSb is sent first), wait about 100 microseconds, and<br>then repeat the process for the next 7 bits.</pre><pre><br><br></pre><pre style="text-decoration: underline;">Sending data to burn to EEPROM</pre><pre>Due to limitations imposed by the EEPROM, the entire 64KB page must be erased before<br>inserting arbitary data into it. Therefore if only a few bytes are required to be changed,<br>the entire page must first be read, the data changed in a buffer, the EEPROM page erased<br>and the new 64KB of data uploaded from the buffer.</pre><pre>Also, although the EEPROM can accept single bytes for programming, the V6Z80P system<br>stipulates that 64 byte packets must be sent. When sending DATA to the PIC, the CPU<br>should check for a clock high from the PIC (OSCA's sys_hw_flags port bit 3). This means<br>the CPU should pause the transmission as the PIC/EEPROM is busy (burning to flashram etc).</pre><pre><br></pre><pre><br><span style="text-decoration: underline;">EEPROM data arrangement as used in the OSCA/FLOS system</span></pre><pre><br>The EEPROM memory is arranged as 64KB blocks. In the OSCA/FLOS documentation a "Slot"<br>is two consecutive blocks.</pre><pre><br></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .---------------. &lt;-$00000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / !&nbsp;&nbsp;&nbsp; BLOCK 0&nbsp;&nbsp;&nbsp; !<br>SLOT 0&nbsp; !---------------! &lt;-$10000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ !&nbsp;&nbsp;&nbsp; BLOCK 1&nbsp;&nbsp;&nbsp; !<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !---------------! &lt;-$20000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / !&nbsp;&nbsp;&nbsp; BLOCK 2&nbsp;&nbsp;&nbsp; !<br>SLOT 1&nbsp; !---------------! &lt;-$30000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ !&nbsp;&nbsp;&nbsp; BLOCK 3&nbsp;&nbsp;&nbsp; !<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !---------------! &lt;-$40000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / !&nbsp;&nbsp;&nbsp; BLOCK 4&nbsp;&nbsp;&nbsp; !<br>SLOT 2&nbsp; !---------------! &lt;-$50000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ !&nbsp;&nbsp;&nbsp; BLOCK 5&nbsp;&nbsp;&nbsp; !<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !---------------! &lt;-$60000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / !&nbsp;&nbsp;&nbsp; BLOCK 6&nbsp;&nbsp;&nbsp; !<br>SLOT 3&nbsp; !---------------! &lt;-$70000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ !&nbsp;&nbsp;&nbsp; BLOCK 7&nbsp;&nbsp;&nbsp; !<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !---------------!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! etc etc etc&nbsp;&nbsp; !</pre><pre><br></pre><pre>Slot 0 is reserved for OS / bootcode / user data:</pre><pre>&nbsp;<span style="text-decoration: underline;">Block 0:</span></pre><pre>&nbsp;$0000-$07FF: Unused</pre><pre>&nbsp;$0800-$EFFF: FLOS / other OS can be installed here</pre><pre>&nbsp;$F000-$FFFF: Primary bootcode</pre><pre><br>&nbsp;<span style="text-decoration: underline;">Block 1:</span></pre><pre>&nbsp;$0000-$EFFF: Not used</pre><pre>&nbsp;$F000-$FFFF: Backup bootcode</pre><pre><br>The other slots can each take a spartan II XS2S150 FPGA config .bin file<br>(or other arbitrary user data).</pre>&nbsp;<br><hr style="width: 100%; height: 2px;"><br><h3 style="text-decoration: underline;">Joystick Interface Description:</h3><pre><br>A PIC microcontroller is used to read 2 x 6 pin digital inputs from Atari/Amiga<br>standard 9 pin D-Sub connectors and send data serially to the FPGA using two pins:<br>Clock and Data. The FPGA provides the clock, Data is always PIC -&gt; FPGA.</pre><pre>Data bits are output following detection of a rising edge on READ_CLOCK_IN<br>The FPGA therefore latches each bit on the following clock high edge.</pre><pre><br></pre><pre>&nbsp;ACTION......&nbsp;&nbsp;&nbsp; Latch 0&nbsp;&nbsp;&nbsp; Latch 1&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ____&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_____&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_____<br>&nbsp;CLOCK __!&nbsp;&nbsp;&nbsp; !_____!&nbsp;&nbsp;&nbsp;&nbsp; !_____!&nbsp;&nbsp;&nbsp;&nbsp; !____ </pre><pre>&nbsp;DATA------&lt;===BIT 0==&gt;&lt;==BIT 1===&gt;&lt;==BIT2==&gt;</pre><pre><br></pre><pre>When the clock stays low for more than ~300 microseconds, the data packet send<br>is aborted, new joystick values are read from the ports and the data transmission<br>begins on the next clock high.</pre><pre>Transmission is a 16 bit word in the following order:</pre><pre>(Joy A) U,D,L,R,F1,F2, 0,0, (Joy B) U,D,L,R,F1,F2, 0,0</pre><pre>See the board specific schematics for physical pin connections as these vary<br>across the V6Z80P revisions.</pre><pre><br></pre><hr style="width: 100%; height: 2px;"><pre><br></pre><pre><br></pre><pre><br></pre></body></html>