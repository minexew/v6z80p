;-----------------------------------------------------------------------------------------------
; Bulk file loader. Allows a directory of files to be replaced with a single consolidated file
; containing an index (Bulkfile generated by FLOS command BULKFILE.EXE) The bulkfile can optionally
; attached to an executable allowing everything to be contained in a single file.
;-----------------------------------------------------------------------------------------------
;
; V1.01 - added sprite load, video ram load and find_file routines
;
;
; Set the following EQUATES in main code:
;
; index_start_lo  (Set to 0 if bulk file is seperate to main .exe)
; index_start_hi  (""                                          "")
;
; bulkfile_fn     (If bulk file is attached to main .exe, make this the same filename and use
;                  a FLOS program header to truncate the program load to stop at the bulk file part)
;
; All routines return with ZF set if sucessful
;
;-----------------------------------------------------------------------------------------------
;
;
; Key routines:
; -------------
;
; * bf_find
;
;   Looks for file and returns length if found (IX:IY)
;   Set HL = filename location
;
;
; * bf_load
;
;   Load from bulk file to system RAM using FLOS BANK and Z80_RAM addressing
;   Set HL = Filename location, DE = Z80 address, B = FLOS bank
;
;
; * bf_flat_load
;
;   Load from bulk file to system RAM using FLAT style addressing
;   Set HL = Filename location, C:DE = System RAM address
;
;
; * bf_load_sprite_data
;
;   Load from bulk file direct to Sprite RAM
;   Set HL = Filename location, C:DE = Sprite RAM address
;
;
; * bf_load_video_data
;
;   Load from bulk file direct to Video RAM
;   Set HL = Filename location, C:DE = Video RAM address
;
;   WARNING! VIDEO WINDOW IS TEMP LOCATED AT $E000-$FFFF - this routine the SP or IRQ code cannot be
;   located between these addresses - the video window is replaced to $2000-$3fff on return.
;
;
; * bf_change_to_programs_dirvol
;
;   Called before a bulk file load, this is used to ensure the volume and directory are set to that
;   from which the host program loaded - this is important where assigned directories are used.
;
;
; * bf_restore_original_dirvol
;
;   Called after a load to restore the volume and directory to that which were set prior to calling
;   bf_change_to_programs_dirvol
;
;-----------------------------------------------------------------------------------------------
;
;Format of bulk file:
;--------------------

;Index:
;------
;$00 1st entry $FF, 12 * 0, total length_of_index ((entries * 16) + 1) 
;$10 2nd entry: Filename.bin, 0, length_of_file (filename always padded to 12 chars, l-o-f is 24 bit)
;$20 3rd entry: Filename.bin, 0, length_of_file (filename always padded to 12 chars, l-o-f is 24 bit)
;.. for n entries..
;$00 - end of index
;
;Files
;-----
;File1
;File2
;File3
; 
;-----------------------------------------------------------------------------------------------



;===============================================================================================

bf_load
load_from_bulk_file

;Set HL = filename location
;    DE = load address (in Z80 address space)
;     B = load bank (FLOS bank)

;===============================================================================================

	
		ld a,b
		ld (bf_load_bank),a
		ld (bf_load_addr),de
		call bf_scan
		ret nz
		
		call bf_set_offset_and_length
		ld hl,(bf_load_addr)
		ld a,(bf_load_bank)
		ld b,a
		call kjt_read_from_file
		ret



		
;===============================================================================================

bf_flat_load

;Set HL   = filename location
;    C:DE = load address in system RAM

;===============================================================================================
		

		ex de,hl
		call bf_convflat
		ex de,hl
		ld b,a
		jr bf_load


bf_convflat	push hl			;in: a:hl= flat addr, out: a=flos bank / hl=addr
		add hl,hl
		pop hl
		rl a
		ret z
		dec a
		set 7,h
		ret




;===============================================================================================

bf_find

;Set HL   = filename location

;===============================================================================================


		call bf_scan
		ret nz
		call bf_set_offset_and_length
		xor a
		ret



		
;-----------------------------------------------------------------------------------------------


bf_scan		ld (bf_fn_addr),hl

		ld hl,0
		ld (bf_bulk_offset),hl
		ld (bf_bulk_offset+2),hl
		
		ld hl,bulkfile_fn
		call kjt_open_file
		ret nz
		
		ld iy,index_start_lo
		ld ix,index_start_hi
		call kjt_set_file_pointer
	
find_fn		ld iy,16			;length of each entry in index
		ld ix,0
		call kjt_set_load_length
		
		ld hl,bf_index_buffer
		ld b,0
		call kjt_read_from_file
		ret nz	
	
		ld hl,bf_index_buffer
		ld a,(hl)			;1st char of entry = $00?
		or a
		jr nz,not_fnf
		ld a,$02			;if so, file not found error
		or a
		ret
	
not_fnf		ld de,(bf_fn_addr)		;compare entry filename with desired filename
		ld b,13
		call kjt_compare_strings
		jr c,found_file
	
		ld hl,(bf_bulk_offset)		;not a filename match, so add the length of this
		ld de,(bf_index_buffer+13)	;file to the offset total
		add hl,de
		ld (bf_bulk_offset),hl
		ld hl,(bf_bulk_offset+2)
		ld a,(bf_index_buffer+15)
		ld e,a
		ld d,0
		adc hl,de
		ld (bf_bulk_offset+2),hl
		jr find_fn			;and load next index entry
	

found_file	ld hl,bulkfile_fn		;the filename matched, so we need to load the data from
		call kjt_open_file		;the computed offset (get length from this entry)
		ret 
	
	

	
bf_set_offset_and_length


		ld hl,(bf_bulk_offset)
		ld de,index_start_lo
		add hl,de
		push hl
		pop iy
		ld hl,(bf_bulk_offset+2)
		ld de,index_start_hi
		adc hl,de
		push hl
		pop ix	
		call kjt_set_file_pointer
		
		ld iy,(bf_index_buffer+13)
		ld a,(bf_index_buffer+15)
		ld l,a
		ld h,0
		push hl
		pop ix
		call kjt_set_load_length
		ret


	
bf_fn_addr	dw 0
bf_load_addr	dw 0
bf_load_bank	db 0

bf_bulk_offset	dw 0,0
bf_index_buffer	ds 16,0


;=============================================================================================================================
	
bf_load_sprite_data

;Set HL = filename location
;    C:DE = load address (in Sprite RAM)
;
;=============================================================================================================================

		call bf_sprvid_common
		ret nz
		
		ex de,hl				; convert flat address to 4KB_page and cpu_address				
		push hl
		ld a,c
		ld b,4
bflsr_pagelp	add hl,hl
		rla
		djnz bflsr_pagelp
		or $80
		ld (vreg_vidpage),a
		ld (bflsvr_page),a
		pop hl
		ld a,h
		and $0f
		or  $10
		ld h,a
		ld (bflsvr_addr),hl
		ex de,hl
		
		in a,(sys_mem_select)			; page in sprite window (for writes) at $1000-$1fff
		ld (bflsvr_orig_mem_select),a
		or %10000000
		out (sys_mem_select),a
		
bflsr_loadloop	ld de,(bflsvr_remaining)
		ld a,(bflsvr_remaining+2)		; if remaining bytes in file >= 4096, set load length to 4096
		or a
		jr nz,bflsr_setmaxl
		ld a,d
		cp $10
		jr c,bflsr_llok
bflsr_setmaxl	ld de,$1000

bflsr_llok	ld hl,(bflsvr_addr)			; will proposed read length overlap end of Sprite window?
		dec de
		add hl,de
		inc de
		ld a,h
		cp $20
		jr c,bflsr_isprwok
		ld hl,$2000				; if so, truncate load length on this pass
		ld de,(bflsvr_addr)
		xor a
		sbc hl,de
		ex de,hl
		
bflsr_isprwok	ld (bflsvr_bytes_to_load),de
		push de
		pop iy
		ld ix,0
		call kjt_set_load_length
				
		ld b,0					; load data directly to sprite window
		ld hl,(bflsvr_addr)
		call kjt_read_from_file
		jr nz,bflsr_exit
				
bflsr_loadok	ld hl,(bflsvr_remaining)		; subtract bytes_to_load from remaining bytes
		ld a,(bflsvr_remaining+2)
		ld bc,(bflsvr_bytes_to_load)
		or a
		sbc hl,bc
		sbc a,0
		ld (bflsvr_remaining),hl
		ld (bflsvr_remaining+2),a
		or h
		or l
		jr nz,bflsr_morebytes			; have all bytes been loaded?	
		xor a					; all done, quit without error
		
bflsr_exit	push af
		ld a,(bflsvr_orig_mem_select)		; restore original mem_select value
		out (sys_mem_select),a
		pop af
		ret
		
bflsr_morebytes	ld a,(bflsvr_page)			; next sprite page
		inc a
		ld (bflsvr_page),a
		ld (vreg_vidpage),a
		ld hl,$1000
		ld (bflsvr_addr),hl
		jr bflsr_loadloop
		
		

;------------------------------------------------------------------------------------------------

bf_sprvid_common
 
		ld a,c
		ld (bf_load_bank),a
		ld (bf_load_addr),de
		call bf_scan
		ret nz
		
		call bf_set_offset_and_length
		ld (bflsvr_remaining),iy
		ld (bflsvr_remaining+2),ix
		
		ld a,(bf_load_bank)			
		ld c,a
		ld de,(bf_load_addr)
		cp a
		ret


bflsvr_bytes_to_load	dw 0
bflsvr_remaining	dw 0,0
bflsvr_page		db 0
bflsvr_addr		dw 0
bflsvr_orig_mem_select	db 0

;=============================================================================================================================
	
bf_load_video_data

;Set HL = filename location
;    C:DE = load address (in video RAM)
;
; WARNING: VRAM WINDOW TEMP PAGED INTO $E000-$FFFF: THIS ROUTINE, INTERRUPT CODE OR SP CANNOT BE LOCATED BETWEEN THESE ADDRESSES!
;
;==============================================================================================================================


		call bf_sprvid_common
		ret nz
		
		ex de,hl				; convert flat address to 8KB page and video window address
		push hl
		ld a,c
		ld b,3
bflvr_pagelp	add hl,hl
		rla
		djnz bflvr_pagelp
		ld (vreg_vidpage),a
		ld (bflsvr_page),a
		pop hl
		ld a,h
		and $1f
		or  $e0
		ld h,a
		ld (bflsvr_addr),hl
		ex de,hl
		
		ld a,7
		out (sys_vram_location),a		; locate window memory window at Z80 $e000-$ffff
		in a,(sys_mem_select)			 
		ld (bflsvr_orig_mem_select),a
		or %01000000
		out (sys_mem_select),a			; open the video window in CPU address space
		
bflvr_loadloop	ld de,(bflsvr_remaining)
		ld a,(bflsvr_remaining+2)		; if remaining bytes in file >= 8192, set load length to 8192
		or a
		jr nz,bflvr_setmaxl
		ld a,d
		cp $20
		jr c,bflvr_llok
bflvr_setmaxl	ld de,$2000

bflvr_llok	ld hl,(bflsvr_addr)			; will proposed read length overlap end of video window?
		dec de
		add hl,de
		inc de
		jr nc,bflvr_ividwok
		ld hl,$0				; if so, truncate load length on this pass
		ld de,(bflsvr_addr)
		xor a
		sbc hl,de
		ex de,hl
		
bflvr_ividwok	ld (bflsvr_bytes_to_load),de
		push de
		pop iy
		ld ix,0
		call kjt_set_load_length
				
		ld b,0					; load data directly to video window
		ld hl,(bflsvr_addr)
		call kjt_read_from_file
		jr nz,bflvr_ferr
				
bflvr_loadok	ld hl,(bflsvr_remaining)		; subtract bytes_to_load from remaining bytes
		ld a,(bflsvr_remaining+2)
		ld de,(bflsvr_bytes_to_load)
		or a
		sbc hl,de
		sbc a,0
		ld (bflsvr_remaining),hl
		ld (bflsvr_remaining+2),a
		or h
		or l
		jr nz,bflvr_morebytes			; have all bytes been loaded?	
		xor a					; all done, quit with no error
		
bflvr_ferr	push af
		ld a,(bflsvr_orig_mem_select)		; restore original mem_select value
		out (sys_mem_select),a
		ld a,1
		out (sys_vram_location),a		; location video window back at FLOS standard (Z80 $2000)
		pop af
		ret
		
bflvr_morebytes	ld a,(bflsvr_page)			; next video page
		inc a
		ld (bflsvr_page),a
		ld (vreg_vidpage),a
		ld hl,$e000
		ld (bflsvr_addr),hl
		jr bflvr_loadloop
		
		



;==================================================================================================
; Two routines that can be called around a bulk_file load to ensure the directory and volume that
; a program loaded from is selected for loading bulkfile data. This is important if a program is
; loaded using an assigned path.
;==================================================================================================

bf_change_to_programs_dirvol
bfl_change_to_programs_dirvol

; set A to volume, DE to cluster

	push de
	push af
	call kjt_get_volume_info
	ld (bfl_orig_vol),a
	pop af
	call kjt_change_volume
	call kjt_get_dir_cluster
	ld (bfl_orig_dir),de
	pop de
	call kjt_set_dir_cluster
	ret



bf_restore_original_dirvol		
bfl_restore_original_dirvol

	ld de,(bfl_orig_dir)
	call kjt_set_dir_cluster
	ld a,(bfl_orig_vol)
	call kjt_change_volume
	ret
	
bfl_orig_dir	dw 0
bfl_orig_vol	db 0


;--------------------------------------------------------------------------------------------------

